#Если Сервер ИЛИ ТолстыйКлиентОбычноеПриложение ИЛИ ВнешнееСоединение Тогда

#Область ОписаниеПеременных

Перем НомерПроверки Экспорт;							 // Номер текущей проверки.
Перем РесурсыПравила;									 // Ресурсы, определенные в правиле по имени.
Перем ВсеРесурсыПравил;									 // Все закэшированные ресурсы, определенные в правиле по имени.
Перем ТекущееПравило;									 // Текущее правило.
Перем Объект Экспорт;									 // Ссылка на проверяемый объект.
Перем ОбъектПроверкиСсылка;								 // Ссылка на проверяемый объект.
Перем ОбъектПроверкиКод;								 // Код проверяемого объекта для вычисления ключа.
Перем ОбъектПроверкиНаименование;						 // Наименование проверяемого объекта.
Перем ОбъектПроверкиТипОбъекта;							 // Тип проверяемого объекта.
Перем ОбъектПроверкиПуть;								 // Путь проверяемого объекта.
Перем ОбъектПроверкиРодитель;							 // Ссылка на родителя проверяемого объекта.
Перем ОбъектПроверкиРодительТипОбъекта;					 // Тип объекта родителя проверяемого объекта.
Перем ОбъектПроверкиЭтоРасширение;						 // Флаг, является ли проверяемый объект объектом расширения.
Перем ОбъектПроверкиПринадлежностьОбъекта;				 // Значение принадлежности объекта расширения.
Перем ОбъектПроверкиЭтоЗаимствованныйОбъектРасширения;	 // Флаг, является ли проверяемый объект заимствованным объектом расширения.
Перем КодПравила;										 // Код правила проверки для вычисления ключа.
Перем ОбъектМетаданных Экспорт;							 // Объект метаданных, к которому относится проверяемый объект.
Перем РегистрироватьВТаблице;							 // Флаг режима регистрации ошибок.
Перем НайденныеОшибки Экспорт;							 // Таблица для регистрации ошибок без записи в регистр.
Перем ИмяСтруктурыПоМодулю;								 // Соответствие получения структуры модуля.
Перем ЭтоМодуль;										 // Соответствие для определения модуля.
Перем ИмяСостСвойства;									 // Соответствие для определения составного свойства.
Перем СписокПолномочийПоТипу;							 // Полномочия по типу.
Перем КэшЗначений;										 // Кэш для значений.
Перем Контекст;											 // Окружение проверки.
Перем ТипыОбъектовМетаданных;							 // Соответствие, в котором типам объектов метаданных установлено Истина.
Перем ОшибкиВОбъекте;									 // Набор записей для накопления ошибок в объекте.
Перем УточненияПроверок;								 // Соответствие для хранения уточнения проверок.
Перем Расширение;										 // Проверяемое расширение, если Неопределено или пустая ссылка, то проверяется конфигурация.

// Переменные для поддержки проверки орфографии
Перем ТаблицаОшибокОрфографии;							 // Таблица для накопления ошибок.
Перем ВерныеСлова;										 // Соответствие для хранения словаря верных слов (внутренний словарь АПК из макета).
Перем СоответствиеСвязныхСлов;							 // Соответствие для хранения склеенных слов, которые уже были проверены в словаре.
Перем СоответствиеОтдельныхСлов;						 // Соответствие для хранения отдельных слов, которые уже были проверены в словаре.
Перем РазбиватьСвязныеСлова;							 // Режим проверки связных слов типа "ПроверитьОрфографию".
Перем ШаблонЗаменыДляПроверкиОрфографии;				 // Шаблон незначимых символов для удаления из текста при проверке орфографии.

Перем СоответствиеОшибок;								 // Соответствие: ошибка - количество.
Перем МаксимальноеКоличествоОшибокОдногоВида;			 // Максимальное количество ошибок одного вида.
Перем ИдентификаторыСодержанияОбъектов;					 // Перечисление "ИдентификаторыСодержанияОбъектов".
Перем ТаблицаИсключенийИзПроверки;						 // Таблица исключений из проверки объектов конфигурации и текстов модулей.

#КонецОбласти

#Область ПроцедурыИФункцииОбщегоНазначения

// Заполняет соответствие для получения имя структуры модуля по имени модуля.
//
Процедура ЗаполнитьИмяСтруктурыПоМодулю()
	
	ИмяСтруктурыПоМодулю = Новый Соответствие;
	ИД = ИдентификаторыСодержанияОбъектов;
	
	ИмяСтруктурыПоМодулю.Вставить(ИД.Модуль, ИД.МодульБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульВнешнегоСоединения, ИД.МодульВнешнегоСоединенияБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульКоманды, ИД.МодульКомандыБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульМенеджера, ИД.МодульМенеджераБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульМенеджераЗначения, ИД.МодульМенеджераЗначенияБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульНабораЗаписей, ИД.МодульНабораЗаписейБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульОбъекта, ИД.МодульОбъектаБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульПриложения, ИД.МодульПриложенияБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульОбычногоПриложения, ИД.МодульОбычногоПриложенияБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульУправляемогоПриложения, ИД.МодульУправляемогоПриложенияБлоки);
	ИмяСтруктурыПоМодулю.Вставить(ИД.МодульСеанса, ИД.МодульСеансаБлоки);
	
КонецПроцедуры

// Заполняет соответствие для определения по имени составного свойства, что это модуль.
//
Процедура ЗаполнитьСоответствиеИменМодулей()
	
	ЭтоМодуль = Новый Соответствие;
	ИД = ИдентификаторыСодержанияОбъектов;
	
	ЭтоМодуль.Вставить(ИД.Модуль, Истина);
	ЭтоМодуль.Вставить(ИД.МодульВнешнегоСоединения, Истина);
	ЭтоМодуль.Вставить(ИД.МодульКоманды, Истина);
	ЭтоМодуль.Вставить(ИД.МодульМенеджера, Истина);
	ЭтоМодуль.Вставить(ИД.МодульМенеджераЗначения, Истина);
	ЭтоМодуль.Вставить(ИД.МодульНабораЗаписей, Истина);
	ЭтоМодуль.Вставить(ИД.МодульОбъекта, Истина);
	ЭтоМодуль.Вставить(ИД.МодульПриложения, Истина);
	ЭтоМодуль.Вставить(ИД.МодульОбычногоПриложения, Истина);
	ЭтоМодуль.Вставить(ИД.МодульУправляемогоПриложения, Истина);
	ЭтоМодуль.Вставить(ИД.МодульСеанса, Истина);
	
КонецПроцедуры

// Заполняет соответствие для определения имени составного свойства по его строковому представлению.
//
Процедура ЗаполнитьИмяСостСвойства()
	
	ИмяСостСвойства = Новый Соответствие;
	ИД = ИдентификаторыСодержанияОбъектов;
	
	ИмяСостСвойства.Вставить("Макет",                         ИД.Макет);
	ИмяСостСвойства.Вставить("Модуль",                        ИД.Модуль);
	ИмяСостСвойства.Вставить("МодульБлоки",                   ИД.МодульБлоки);
	ИмяСостСвойства.Вставить("МодульВнешнегоСоединения",      ИД.МодульВнешнегоСоединения);
	ИмяСостСвойства.Вставить("МодульВнешнегоСоединенияБлоки", ИД.МодульВнешнегоСоединенияБлоки);
	ИмяСостСвойства.Вставить("МодульКоманды",                 ИД.МодульКоманды);
	ИмяСостСвойства.Вставить("МодульКомандыБлоки",            ИД.МодульКомандыБлоки);
	ИмяСостСвойства.Вставить("МодульМенеджера",               ИД.МодульМенеджера);
	ИмяСостСвойства.Вставить("МодульМенеджераБлоки",          ИД.МодульМенеджераБлоки);
	ИмяСостСвойства.Вставить("МодульМенеджераЗначения",       ИД.МодульМенеджераЗначения);
	ИмяСостСвойства.Вставить("МодульМенеджераЗначенияБлоки",  ИД.МодульМенеджераЗначенияБлоки);
	ИмяСостСвойства.Вставить("МодульНабораЗаписей",           ИД.МодульНабораЗаписей);
	ИмяСостСвойства.Вставить("МодульНабораЗаписейБлоки",      ИД.МодульНабораЗаписейБлоки);
	ИмяСостСвойства.Вставить("МодульОбъекта",                 ИД.МодульОбъекта);
	ИмяСостСвойства.Вставить("МодульОбъектаБлоки",            ИД.МодульОбъектаБлоки);
	ИмяСостСвойства.Вставить("МодульПриложения",              ИД.МодульПриложения);
	ИмяСостСвойства.Вставить("МодульПриложенияБлоки",         ИД.МодульПриложенияБлоки);
	ИмяСостСвойства.Вставить("МодульОбычногоПриложения",      ИД.МодульОбычногоПриложения);
	ИмяСостСвойства.Вставить("МодульОбычногоПриложенияБлоки", ИД.МодульОбычногоПриложенияБлоки);
	ИмяСостСвойства.Вставить("МодульУправляемогоПриложения",  ИД.МодульУправляемогоПриложения);
	ИмяСостСвойства.Вставить("МодульУправляемогоПриложенияБлоки", ИД.МодульУправляемогоПриложенияБлоки);
	ИмяСостСвойства.Вставить("МодульСеанса",                  ИД.МодульСеанса);
	ИмяСостСвойства.Вставить("МодульСеансаБлоки",             ИД.МодульСеансаБлоки);
	ИмяСостСвойства.Вставить("Подсистемы",                    ИД.Подсистемы);
	ИмяСостСвойства.Вставить("Права",                         ИД.Права);
	ИмяСостСвойства.Вставить("СодержимоеМакета",              ИД.СодержимоеМакета);
	ИмяСостСвойства.Вставить("СправочнаяИнформация",          ИД.СправочнаяИнформация);
	ИмяСостСвойства.Вставить("Тип",                           ИД.Тип);
	ИмяСостСвойства.Вставить("ТипПараметраКоманды",           ИД.ТипПараметраКоманды);
	ИмяСостСвойства.Вставить("Форма",                         ИД.Форма);
	ИмяСостСвойства.Вставить("ШаблоныЗаданийОчереди",         ИД.ШаблоныЗаданийОчереди);
	ИмяСостСвойства.Вставить("РегламентныеЗаданияЗависимыеОтФункциональныхОпций", ИД.РегламентныеЗаданияЗависимыеОтФункциональныхОпций);
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСоСтруктуройМетаданных

// Возвращает элемент структуры конфигурации по переданному пути или типу/имени.
//
// Параметры:
//
//   ТипИлиПуть - Строка - тип или путь искомого объекта структуры конфигурации.
//   Имя        - Строка - наименование искомого объекта структуры конфигурации.
//
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации, Неопределено - искомый объект структуры конфигурации или Неопределено.
//
Функция НайтиВСтруктуреКонфигурации(ТипИлиПуть, Имя = "")
	
	Если СтрНайти(ТипИлиПуть, ".") > 0 Тогда
		// Есть точки - в строке задан путь.
		ЗапросПоПути = Новый Запрос;
		ЗапросПоПути.Текст = "
		|ВЫБРАТЬ
		|	СтруктураКонфигурации.Ссылка
		|ИЗ
		|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
		|ГДЕ
		|	СтруктураКонфигурации.Владелец = &Версия
		|	И СтруктураКонфигурации.Путь = &Путь
		|	И СтруктураКонфигурации.Расширение = &Расширение
		|	И НЕ СтруктураКонфигурации.ПометкаУдаления";
		
		ЗапросПоПути.УстановитьПараметр("Версия", Версия);
		ЗапросПоПути.УстановитьПараметр("Путь", ТипИлиПуть);
		ЗапросПоПути.УстановитьПараметр("Расширение", Расширение);
		
		Выборка = ЗапросПоПути.Выполнить().Выбрать();
	Иначе
		// Нет точек - в строке задан тип.
		ТипыОбъектов = Неопределено;
		ТипЭлемента = НайтиВТаблицеТиповОбъектов(ТипыОбъектов, ТипИлиПуть, "ПеречислениеТип", "ИмяВЕдинственномЧисле",
			Перечисления.ТипыОбъектов.ВеткаМетаданных);
		
		ЗапросПоТипу = Новый Запрос;
		ЗапросПоТипу.Текст = "
		|ВЫБРАТЬ
		|	СтруктураКонфигурации.Ссылка
		|ИЗ
		|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
		|ГДЕ
		|	СтруктураКонфигурации.Владелец = &Версия
		|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
		|	И СтруктураКонфигурации.Наименование = &Наименование
		|	И СтруктураКонфигурации.Расширение = &Расширение
		|	И НЕ СтруктураКонфигурации.ПометкаУдаления";
		
		ЗапросПоТипу.УстановитьПараметр("Версия", Версия);
		ЗапросПоТипу.УстановитьПараметр("ТипОбъекта", ТипЭлемента);
		ЗапросПоТипу.УстановитьПараметр("Наименование", Имя);
		ЗапросПоТипу.УстановитьПараметр("Расширение", Расширение);
		
		Выборка = ЗапросПоТипу.Выполнить().Выбрать();
	КонецЕсли;
	
	Возврат ?(Выборка.Следующий(), Выборка.Ссылка, Неопределено);
	
КонецФункции

// По переданному описанию объекта возвращает ссылку на него или его содержание,
// если запрошенный объект хранится как часть другого объекта.
//
// Параметры:
//   Составляющие - Массив - массив элементов пути объекта метаданных. Количество элементов массива 1 или 2.
//                           Если 1 элемент, то значением должно являться наименование объекта.
//                           Если 2 элемента, то значения должны содержать путь к объекту:
//                           полный путь образовывается по правилу Значение[0] + "." + Значение[1].
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации, Неопределено - искомый объект структуры конфигурации или Неопределено.
//
Функция НайтиОбъектПоОписанию(Знач Составляющие)
	
	Если Составляющие.Количество() = 1 Тогда
		
		// Описана ветка метаданных.
		ЗапросПоВетке = Новый Запрос;
		ЗапросПоВетке.Текст = "
		|ВЫБРАТЬ
		|	СтруктураКонфигурации.Ссылка
		|ИЗ
		|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
		|ГДЕ
		|	СтруктураКонфигурации.Владелец = &Владелец
		|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
		|	И СтруктураКонфигурации.Наименование = &Наименование
		|	И СтруктураКонфигурации.Расширение = &Расширение";
		
		ЗапросПоВетке.УстановитьПараметр("Владелец", Версия);
		ЗапросПоВетке.УстановитьПараметр("ТипОбъекта", Перечисления.ТипыОбъектов.ВеткаМетаданных);
		ЗапросПоВетке.УстановитьПараметр("Наименование", Составляющие[0]);
		ЗапросПоВетке.УстановитьПараметр("Расширение", Расширение);
		
		Выборка = ЗапросПоВетке.Выполнить().Выбрать();
		
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Ссылка;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	Иначе
		
		Путь = Составляющие[0] + "." + Составляющие[1];
		
		ЗапросПоПредставлению = Новый Запрос;
		ЗапросПоПредставлению.Текст = "
		|ВЫБРАТЬ
		|	СтруктураКонфигурации.Ссылка
		|ИЗ
		|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
		|ГДЕ
		|	СтруктураКонфигурации.Владелец = &Владелец
		|	И СтруктураКонфигурации.Путь = &Путь
		|	И СтруктураКонфигурации.Расширение = &Расширение";
		
		ЗапросПоПредставлению.УстановитьПараметр("Владелец", Версия);
		ЗапросПоПредставлению.УстановитьПараметр("Путь", Путь);
		ЗапросПоПредставлению.УстановитьПараметр("Расширение", Расширение);
		
		Выборка = ЗапросПоПредставлению.Выполнить().Выбрать();
		
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Ссылка;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции

// Возвращает таблицу с объектами проверяемой конфигурации.
//
// Параметры:
//   ТипОбъекта - Неопределено, ПеречислениеСсылка.ТипыОбъектов, Массив - тип или массив типов искомых объектов
//                структуры конфигурации. Если параметр не задан, в таблице будут объекты всех типов.
//   ТолькоСобраныСведения - Булево - флаг, указывающий, какие объекты необходимо получить.
//                                    Если указано значение "Истина", то в таблице объектов будут только те объекты,
//                                    у которых реквизит "СобраныСведения" = "Истина", иначе все.
//   РасширениеКонфигурации - СправочникСсылка.Расширения, Неопределено - ссылка на запись справочника расширений.
//                            Если Неопределено, то в таблице будут только объекты текущего расширения.
//                            Если непустая ссылка, то в таблице будут только объекты указанного расширения.
//                            Если пустая ссылка, то в таблице будут только объекты конфигурации.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Ссылка       - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     Наименование - Строка                                 - наименование объекта;
//     ТипОбъекта   - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     Путь         - Строка                                 - полный путь к объекту в дереве метаданных;
//     Родитель     - СправочникСсылка.СтруктураКонфигурации - ссылка на родительский объект.
//
Функция ПолучитьОбъектыКонфигурации(ТипОбъекта = Неопределено, ТолькоСобраныСведения = Ложь,
	РасширениеКонфигурации = Неопределено)
	
	Если ТипОбъекта = Неопределено Тогда
		ТипОбъектаСтрокой = "";
	ИначеЕсли ТипЗнч(ТипОбъекта) = Тип("ПеречислениеСсылка.ТипыОбъектов") Тогда
		ТипОбъектаСтрокой = Строка(ТипОбъекта);
	ИначеЕсли ТипЗнч(ТипОбъекта) = Тип("Массив") Тогда
		ТипОбъектаСтрокой = СтрСоединить(ТипОбъекта, "_");
	Иначе
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
	РасширениеКонфигурацииСсылка = ?(РасширениеКонфигурации = Неопределено, Расширение, РасширениеКонфигурации);
	
	КлючКонтекста = СтрШаблон("ТаблицаОбъектыКонфигурации_%1_%2_%3", ТипОбъектаСтрокой, ТолькоСобраныСведения,
		РасширениеКонфигурацииСсылка);
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК Ссылка,
	|	СтруктураКонфигурации.Наименование КАК Наименование,
	|	СтруктураКонфигурации.ТипОбъекта КАК ТипОбъекта,
	|	СтруктураКонфигурации.Путь КАК Путь,
	|	СтруктураКонфигурации.Родитель КАК Родитель,
	|	СтруктураКонфигурации.СобраныСведения КАК СобраныСведения
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Владелец
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И (НЕ СтруктураКонфигурации.ПометкаУдаления)";
	
	Запрос.УстановитьПараметр("Владелец", Версия);
	Запрос.УстановитьПараметр("Расширение", РасширениеКонфигурацииСсылка);
	
	Если ТолькоСобраныСведения Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И СтруктураКонфигурации.СобраныСведения";
	КонецЕсли;
	
	Если ТипЗнч(ТипОбъекта) = Тип("ПеречислениеСсылка.ТипыОбъектов") Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта";
		Запрос.УстановитьПараметр("ТипОбъекта", ТипОбъекта);
	ИначеЕсли ТипЗнч(ТипОбъекта) = Тип("Массив") Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И СтруктураКонфигурации.ТипОбъекта В(&МассивТипов)";
		Запрос.УстановитьПараметр("МассивТипов", ТипОбъекта);
	КонецЕсли;
	
	Результат = Запрос.Выполнить().Выгрузить();
	
	Контекст.Вставить(КлючКонтекста, Результат);
	
	Возврат Результат;
	
КонецФункции

// Получает соответствие объектов конфигурации с типом "Роль".
//
// Возвращаемое значение:
//   Соответствие - соответствие ролей:
//     Ключ     - Строка                                 - наименование роли в верхнем регистре.
//     Значение - СправочникСсылка.СтруктураКонфигурации - ссылка на роль.
//
Функция ПолучитьОбъектыКонфигурацииРоли()
	
	КлючКонтекста = "ОбъектыКонфигурацииРоли";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	СоответствиеРолей = Новый Соответствие;
	
	ТаблицаРолей = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.Роль, Ложь);
	
	Для Каждого Роль Из ТаблицаРолей Цикл
		СоответствиеРолей.Вставить(ВРег(Роль.Наименование), Роль.Ссылка);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеРолей);
	
	Возврат СоответствиеРолей;
	
КонецФункции

// Получает соответствие объектов конфигурации с типами: "Реквизит", "Ресурс", "Измерение" и "СтандартныйРеквизит".
//
// Возвращаемое значение:
//   Соответствие - Соответствие объектов.
//     Ключ     - Строка                                 - путь к объекту в верхнем регистре.
//     Значение - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации.
//
Функция ПолучитьОбъектыКонфигурацииРеквизиты()
	
	КлючКонтекста = "ОбъектыКонфигурацииРеквизиты";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Реквизит);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Ресурс);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Измерение);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.СтандартныйРеквизит);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК Ссылка,
	|	СтруктураКонфигурации.Путь КАК Путь
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Владелец
	|	И СтруктураКонфигурации.ТипОбъекта В (&ТипыОбъектов)
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Владелец", Версия);
	Запрос.УстановитьПараметр("ТипыОбъектов", МассивТипов);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	ВыборкаРеквизитов = Запрос.Выполнить().Выбрать();
	
	СоответствиеРеквизиты = Новый Соответствие;
	Пока ВыборкаРеквизитов.Следующий() Цикл
		СоответствиеРеквизиты.Вставить(ВРег(ВыборкаРеквизитов.Путь), ВыборкаРеквизитов.Ссылка);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеРеквизиты);
	
	Возврат СоответствиеРеквизиты;
	
КонецФункции

// Возвращает таблицу объектов проверяемой конфигурации с типом "Подсистема".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Ссылка                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     Наименование                - Строка                                 - наименование объекта;
//     ТипОбъекта                  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     Путь                        - Строка                                 - полный путь к объекту в дереве метаданных;
//     ПодсистемаВерхнегоУровня    - СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему, которая является
//                                                                            родительской подсистемой на самом верхнем
//                                                                            уровне для текущей подсистемы;
//     ВключатьВКомандныйИнтерфейс - Булево                                 - значение свойства
//                                                                            "Включать в командный интерфейс".
//
Функция ПолучитьОбъектыКонфигурацииПодсистемы()
	
	КлючКонтекста = "ОбъектыКонфигурацииПодсистемы";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТекстВключатьВКомандныйИнтерфейс = "ВключатьВКомандныйИнтерфейс";
	
	// Соберем информацию о подсистемах.
	ТаблицаПодсистем = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.Подсистема);
	ТаблицаПодсистем.Колонки.Добавить("ПодсистемаВерхнегоУровня");
	ТаблицаПодсистем.Колонки.Добавить(ТекстВключатьВКомандныйИнтерфейс);
	ТаблицаПодсистем.ЗаполнитьЗначения(Истина, ТекстВключатьВКомандныйИнтерфейс);
	
	Для Каждого СтрокаПодсистемы Из ТаблицаПодсистем Цикл
		
		ПодсистемаСсылка = СтрокаПодсистемы.Ссылка;
		
		// Получим значение флажка "ВключатьВКомандныйИнтерфейс".
		ЗначениеСвойства = ПолучитьСвойство(ТекстВключатьВКомандныйИнтерфейс, ПодсистемаСсылка);
		Если ЗначениеСвойства = Ложь Тогда
			СтрокаПодсистемы[ТекстВключатьВКомандныйИнтерфейс] = Ложь;
		КонецЕсли;
		
		// Получим подсистему самого верхнего уровня.
		ПодсистемаВерхнегоУровня = ПодсистемаСсылка;
		Пока Истина Цикл
			ПодсистемаРодитель = ПодсистемаВерхнегоУровня.Родитель;
			Если ПодсистемаРодитель.Пустая()
			 ИЛИ ПодсистемаРодитель.ТипОбъекта = Перечисления.ТипыОбъектов.ВеткаМетаданных Тогда
				Прервать;
			КонецЕсли;
			
			ПодсистемаВерхнегоУровня = ПодсистемаРодитель;
		КонецЦикла;
		
		СтрокаПодсистемы.ПодсистемаВерхнегоУровня = ПодсистемаВерхнегоУровня;
		
	КонецЦикла;
	
	ТаблицаПодсистем.Индексы.Добавить("Ссылка");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаПодсистем);
	
	Возврат ТаблицаПодсистем;
	
КонецФункции

// Возвращает таблицу объектов проверяемой конфигурации с типом "Общий модуль".
//
// Параметры:
//   ФлагКлиент - Булево - флаг, определяющий, какие общие модули будут получены.
//                         Если значение флага "Истина", то в таблицу попадут общие модули
//                         с установленным свойством "Клиент (управляемое приложение)".
//   ФлагСервер - Булево - флаг, определяющий, какие общие модули будут получены.
//                         Если значение флага "Истина", то в таблицу попадут общие модули
//                         с установленным свойством "Сервер".
// Если не установлен ни один флаг из параметров, то будут получены все общие модули.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Ссылка                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     Наименование                - Строка                                 - наименование объекта;
//     ТипОбъекта                  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     Путь                        - Строка                                 - полный путь к объекту в дереве метаданных.
//
Функция ПолучитьОбъектыКонфигурацииОбщиеМодули(ФлагКлиент = Ложь, ФлагСервер = Ложь)
	
	КлючКонтекста = СтрШаблон("ОбъектыКонфигурацииОбщиеМодули_%1_%2", ФлагКлиент, ФлагСервер);
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТаблицаОбщихМодулей = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.ОбщийМодуль);
	
	Если ТаблицаОбщихМодулей.Колонки.Найти("НаименованиеВРег") = Неопределено Тогда
		ТаблицаОбщихМодулей.Колонки.Добавить("НаименованиеВРег");
		
		Для Каждого СтрокаТаблицы Из ТаблицаОбщихМодулей Цикл
			СтрокаТаблицы.НаименованиеВРег = ВРег(СтрокаТаблицы.Наименование);
		КонецЦикла;
	КонецЕсли;
	
	Если (НЕ ФлагКлиент) И (НЕ ФлагСервер) Тогда
		Контекст.Вставить(КлючКонтекста, ТаблицаОбщихМодулей);
		Возврат ТаблицаОбщихМодулей;
	КонецЕсли;
	
	ТаблицаОбщихМодулейОтбор = ТаблицаОбщихМодулей.СкопироватьКолонки();
	
	Для Каждого СтрокаТаблицы Из ТаблицаОбщихМодулей Цикл
		
		ОбщийМодульСсылка = СтрокаТаблицы.Ссылка;
		ОбщийМодульСвойства = ПолучитьСвойства(ОбщийМодульСсылка);
		
		Если ФлагКлиент Тогда
			
			СвойствоКлиент = Неопределено;
			ОбщийМодульСвойства.Свойство("КлиентУправляемоеПриложение", СвойствоКлиент);
			
			Если СвойствоКлиент = Истина Тогда
				ЗаполнитьЗначенияСвойств(ТаблицаОбщихМодулейОтбор.Добавить(), СтрокаТаблицы);
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ФлагСервер Тогда
			
			СвойствоСервер = Неопределено;
			ОбщийМодульСвойства.Свойство("Сервер", СвойствоСервер);
			
			Если СвойствоСервер = Истина Тогда
				ЗаполнитьЗначенияСвойств(ТаблицаОбщихМодулейОтбор.Добавить(), СтрокаТаблицы);
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОбщихМодулейОтбор);
	
	Возврат ТаблицаОбщихМодулейОтбор;
	
КонецФункции

// Получает соответствие объектов конфигурации с различными типами объектов, имеющих свойство "История выбора при вводе".
//
// Возвращаемое значение:
//   Соответствие - Соответствие объектов:
//     Ключ     - Строка                                 - путь к объекту  в верхнем регистре.
//     Значение - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//
Функция ПолучитьОбъектыКонфигурацииСИсториейВыбораПриВводе()
	
	КлючКонтекста = "ОбъектыКонфигурацииСИсториейВыбораПриВводе";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	МассивПолучаемыхТипов = Новый Массив;
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.БизнесПроцесс);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.Документ);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.Задача);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.Константа);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.ОбщийРеквизит);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.Перечисление);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.ПланВидовРасчета);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.ПланВидовХарактеристик);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.ПланОбмена);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.ПланСчетов);
	МассивПолучаемыхТипов.Добавить(Перечисления.ТипыОбъектов.Справочник);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК Ссылка,
	|	СтруктураКонфигурации.Путь КАК Путь
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Владелец
	|	И СтруктураКонфигурации.ТипОбъекта В (&ТипыОбъектов)
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("Владелец", Версия);
	Запрос.УстановитьПараметр("ТипыОбъектов", МассивПолучаемыхТипов);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	ВыборкаОбъектов = Запрос.Выполнить().Выбрать();
	
	СоответствиеОбъектовСИсториейВыбора = Новый Соответствие;
	Пока ВыборкаОбъектов.Следующий() Цикл
		СоответствиеОбъектовСИсториейВыбора.Вставить(ВРег(ВыборкаОбъектов.Путь), ВыборкаОбъектов.Ссылка);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеОбъектовСИсториейВыбора);
	
	Возврат СоответствиеОбъектовСИсториейВыбора;
	
КонецФункции

// Получает соответствие объектов конфигурации с ошибками при тестировании объектов.
//
// Возвращаемое значение:
//   Соответствие - Соответствие объектов:
//     Ключ     - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//     Значение - Строка                                 - текст ошибки тестирования.
//
Функция ПолучитьОбъектыКонфигурацииСОшибкамиПриТестировании()
	
	КлючКонтекста = "ОбъектыКонфигурацииСОшибкамиПриТестировании";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	СоответствиеОбъектовСОшибкамиТестирования = Новый Соответствие;
	
	ЗапросПоОбъектамСОшибками = Новый Запрос;
	ЗапросПоОбъектамСОшибками.Текст = "
	|ВЫБРАТЬ
	|	ОбъектыСОшибками.Объект КАК Объект,
	|	ОбъектыСОшибками.ТекстОшибки КАК ТекстОшибки
	|ИЗ
	|	РегистрСведений.ОбъектыСОшибками КАК ОбъектыСОшибками
	|ГДЕ
	|	ОбъектыСОшибками.Объект.Владелец = &Версия";
	
	ЗапросПоОбъектамСОшибками.УстановитьПараметр("Версия", Версия);
	
	Выборка = ЗапросПоОбъектамСОшибками.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		СоответствиеОбъектовСОшибкамиТестирования.Вставить(Выборка.Объект, Выборка.ТекстОшибки);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеОбъектовСОшибкамиТестирования);
	
	Возврат СоответствиеОбъектовСОшибкамиТестирования;
	
КонецФункции

// Возвращает таблицу объектов верхнего уровня проверяемой конфигурации, для которых родителем является ветка метаданных,
// например, все справочники, документы, РС и т.д.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Родитель                    - СправочникСсылка.СтруктураКонфигурации - ссылка на родительский объект;
//     Ссылка                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     Наименование                - Строка                                 - наименование объекта;
//     ТипОбъекта                  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     Путь                        - Строка                                 - полный путь к объекту в дереве метаданных.
//
Функция ПолучитьОбъектыКонфигурацииВерхнегоУровня()
	
	КлючКонтекста = "ОбъектыКонфигурацииВерхнегоУровня";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Родитель КАК Родитель,
	|	СтруктураКонфигурации.Ссылка КАК Ссылка,
	|	СтруктураКонфигурации.Наименование КАК Наименование,
	|	СтруктураКонфигурации.ТипОбъекта КАК ТипОбъекта,
	|	СтруктураКонфигурации.Путь КАК Путь
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Владелец
	|	И СтруктураКонфигурации.Родитель.ТипОбъекта = &ВеткаМетаданных
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|УПОРЯДОЧИТЬ ПО
	|	СтруктураКонфигурации.НомерПоПорядку";
	
	Запрос.УстановитьПараметр("Владелец", Версия);
	Запрос.УстановитьПараметр("ВеткаМетаданных", Перечисления.ТипыОбъектов.ВеткаМетаданных);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	ТаблицаОбъектов = Запрос.Выполнить().Выгрузить();
	
	ТаблицаОбъектов.Индексы.Добавить("Родитель");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОбъектов);
	
	Возврат ТаблицаОбъектов;
	
КонецФункции

// Возвращает массив типов объектов верхнего уровня проверяемой конфигурации, для которых родителем является ветка метаданных.
//
// Возвращаемое значение:
//   Массив - массив, элементы массива - ПеречислениеСсылка.ТипыОбъектов.
//
Функция ПолучитьТипыОбъектовКонфигурацииВерхнегоУровня()
	
	КлючКонтекста = "ТипыОбъектовКонфигурацииВерхнегоУровня";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТаблицаОбъектов = ПолучитьОбъектыКонфигурацииВерхнегоУровня();
	ТаблицаТиповОбъектов = ТаблицаОбъектов.Скопировать();
	ТаблицаТиповОбъектов.Свернуть("ТипОбъекта");
	
	МассивТипов = ТаблицаТиповОбъектов.ВыгрузитьКолонку("ТипОбъекта");
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Конфигурация);
	
	Контекст.Вставить(КлючКонтекста, МассивТипов);
	
	Возврат МассивТипов;
	
КонецФункции

// Возвращает таблицу объектов конфигурации, имеющих модули.
//
// Параметры:
//   РасширениеКонфигурации - СправочникСсылка.Расширения, Неопределено - ссылка на запись справочника расширений.
//                            Если Неопределено, то в таблице будут только объекты текущего расширения.
//                            Если непустая ссылка, то в таблице будут только объекты указанного расширения.
//                            Если пустая ссылка, то в таблице будут только объекты конфигурации.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Ссылка                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     Наименование                - Строка                                 - наименование объекта;
//     ТипОбъекта                  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     Путь                        - Строка                                 - полный путь к объекту в дереве метаданных;
//     Родитель                    - СправочникСсылка.СтруктураКонфигурации - ссылка на родительский объект.
//
Функция ПолучитьТаблицуОбъектовКонфигурацииСМодулями(РасширениеКонфигурации = Неопределено)
	
	РасширениеКонфигурацииСсылка = ?(РасширениеКонфигурации = Неопределено, Расширение, РасширениеКонфигурации);
	
	КлючКонтекста = СтрШаблон("ТаблицаОбъектыСМодулями_%1", РасширениеКонфигурацииСсылка);
	ТаблицаОбъектыСМодулями = Контекст[КлючКонтекста];
	Если ТаблицаОбъектыСМодулями <> Неопределено Тогда
		Возврат ТаблицаОбъектыСМодулями;
	КонецЕсли;
	
	ТаблицаОбъектыКонфигурации = ПолучитьОбъектыКонфигурации(,, РасширениеКонфигурацииСсылка);
	МассивТипов = ПолучитьТипыОбъектовИмеющихМодули();
	
	ЗапросПоМодулям = Новый Запрос;
	ЗапросПоМодулям.Текст = "
	|ВЫБРАТЬ
	|	ТаблицаКонфигурации.Ссылка КАК Ссылка,
	|	ТаблицаКонфигурации.Наименование КАК Наименование,
	|	ТаблицаКонфигурации.ТипОбъекта КАК ТипОбъекта,
	|	ТаблицаКонфигурации.Путь КАК Путь,
	|	ТаблицаКонфигурации.Родитель КАК Родитель
	|ПОМЕСТИТЬ ВТ_Объекты
	|ИЗ
	|	&ТаблицаКонфигурации КАК ТаблицаКонфигурации
	|ГДЕ
	|	ТаблицаКонфигурации.ТипОбъекта В(&ТипОбъекта)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_Объекты.Ссылка КАК Ссылка,
	|	ВТ_Объекты.Наименование КАК Наименование,
	|	ВТ_Объекты.ТипОбъекта КАК ТипОбъекта,
	|	ВТ_Объекты.Путь КАК Путь,
	|	ВТ_Объекты.Родитель КАК Родитель
	|ИЗ
	|	ВТ_Объекты КАК ВТ_Объекты";
	
	ЗапросПоМодулям.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	ЗапросПоМодулям.УстановитьПараметр("ТаблицаКонфигурации", ТаблицаОбъектыКонфигурации);
	ЗапросПоМодулям.УстановитьПараметр("ТипОбъекта", МассивТипов);
	
	ТаблицаОбъектыСМодулями = ЗапросПоМодулям.Выполнить().Выгрузить();
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОбъектыСМодулями);
	
	Возврат ТаблицаОбъектыСМодулями;
	
КонецФункции

// Возвращает таблицу объектов конфигурации, состоящую из общих модулей и объектов, имеющих модули менеджеров.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Имя         - Строка                                 - наименование объекта.
//     ИмяРодителя - Строка                                 - наименование родителя объекта.
//     Объект      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//     ТипОбъекта  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//
Функция ПолучитьТаблицуОбъектовОбщиеМодулиИМодулиМенеджера(РасширениеКонфигурации = Неопределено)
	
	РасширениеКонфигурацииСсылка = ?(РасширениеКонфигурации = Неопределено, Расширение, РасширениеКонфигурации);
	
	КлючКонтекста = СтрШаблон("ТаблицаОбщиеМодулиИМодулиМенеджеров_%1", РасширениеКонфигурацииСсылка);
	ТаблицаОбщиеМодулиИМодулиМенеджеров = Контекст[КлючКонтекста];
	Если ТаблицаОбщиеМодулиИМодулиМенеджеров <> Неопределено Тогда
		Возврат ТаблицаОбщиеМодулиИМодулиМенеджеров;
	КонецЕсли;
	
	ТаблицаОбъектыКонфигурации = ПолучитьОбъектыКонфигурации(,, РасширениеКонфигурацииСсылка);
	
	// Только общие модули и методы модуля менеджера.
	ЗапросПоОбщимМодулям = Новый Запрос;
	ЗапросПоОбщимМодулям.Текст = "
	|ВЫБРАТЬ
	|	ТаблицаКонфигурации.Ссылка КАК Объект,
	|	ТаблицаКонфигурации.Наименование КАК Имя,
	|	ТаблицаКонфигурации.ТипОбъекта
	|ПОМЕСТИТЬ ВТ_ДАННЫЕ
	|ИЗ
	|	&ТаблицаКонфигурации КАК ТаблицаКонфигурации
	|ГДЕ
	|	ТаблицаКонфигурации.ТипОбъекта В(&ТипОбъекта)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТ_ДАННЫЕ.Объект КАК Объект,
	|	ВТ_ДАННЫЕ.Имя КАК Имя,
	|	ВТ_ДАННЫЕ.ТипОбъекта КАК ТипОбъекта,
	|	ВТ_ДАННЫЕ.Объект.Родитель.Наименование КАК ИмяРодителя
	|ИЗ
	|	ВТ_ДАННЫЕ КАК ВТ_ДАННЫЕ";
	
	МенеджерВТ = Новый МенеджерВременныхТаблиц;
	ЗапросПоОбщимМодулям.МенеджерВременныхТаблиц = МенеджерВТ;
	ЗапросПоОбщимМодулям.УстановитьПараметр("ТаблицаКонфигурации", ТаблицаОбъектыКонфигурации);
	
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.БизнесПроцесс);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Документ);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ЖурналДокументов);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Задача);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Обработка);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ОбщийМодуль);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Отчет);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ПланВидовРасчета);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ПланВидовХарактеристик);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ПланОбмена);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.ПланСчетов);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.РегистрБухгалтерии);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.РегистрНакопления);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.РегистрРасчета);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.РегистрСведений);
	МассивТипов.Добавить(Перечисления.ТипыОбъектов.Справочник);
	
	ЗапросПоОбщимМодулям.УстановитьПараметр("ТипОбъекта", МассивТипов);
	
	ТаблицаОбщиеМодулиИМодулиМенеджеров = ЗапросПоОбщимМодулям.Выполнить().Выгрузить();
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОбщиеМодулиИМодулиМенеджеров);
	
	Возврат ТаблицаОбщиеМодулиИМодулиМенеджеров;
	
КонецФункции

// Возвращает таблицу объектов определенного типа, для которых переданный объект является родителем.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации  - родительский объект, для которого необходимо
//                                                                  получить подчиненные.
//   ТипПодчиненных     - Строка, ПеречислениеСсылка.ТипыОбъектов - тип подчиненных объектов.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Ссылка       - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//     Наименование - Строка                                 - наименование объекта.
//     ТипОбъекта   - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//     Путь         - Строка                                 - полный путь к объекту в дереве метаданных.
//
Функция ПолучитьПодчиненныеЭлементы(ОбъектКонфигурации, ТипПодчиненных = Неопределено)
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка,
	|	СтруктураКонфигурации.ТипОбъекта,
	|	СтруктураКонфигурации.Наименование,
	|	СтруктураКонфигурации.Путь
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Версия
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|	И СтруктураКонфигурации.Родитель = &ОбъектКонфигурации
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	%1
	|
	|УПОРЯДОЧИТЬ ПО
	|	СтруктураКонфигурации.НомерПоПорядку";
	
	Если ТипЗнч(ТипПодчиненных) = Тип("Строка") Тогда
		ТипыОбъектов = Неопределено;
		ТипЭлемента = НайтиВТаблицеТиповОбъектов(ТипыОбъектов, ТипПодчиненных, "ПеречислениеТип", "ИмяВЕдинственномЧисле",
			Перечисления.ТипыОбъектов.ВеткаМетаданных);
	ИначеЕсли ТипЗнч(ТипПодчиненных) = Тип("ПеречислениеСсылка.ТипыОбъектов") Тогда
		ТипЭлемента = ТипПодчиненных;
	Иначе
		ТипЭлемента = Неопределено;
	КонецЕсли;
	
	УсловиеПоТипуОбъекта = "";
	Если (ТипЭлемента <> Неопределено) И (ТипЭлемента <> Перечисления.ТипыОбъектов.ВеткаМетаданных) Тогда
		УсловиеПоТипуОбъекта = "И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта";
	КонецЕсли;
	
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, УсловиеПоТипуОбъекта);
	
	ЗапросПоСтруктуре = Новый Запрос(ТекстЗапроса);
	ЗапросПоСтруктуре.УстановитьПараметр("Версия", Версия);
	ЗапросПоСтруктуре.УстановитьПараметр("ОбъектКонфигурации", ОбъектКонфигурации);
	ЗапросПоСтруктуре.УстановитьПараметр("Расширение", Расширение);
	Если (ТипЭлемента <> Неопределено) И (ТипЭлемента <> Перечисления.ТипыОбъектов.ВеткаМетаданных) Тогда
		ЗапросПоСтруктуре.УстановитьПараметр("ТипОбъекта", ТипЭлемента);
	КонецЕсли;
	
	Возврат ЗапросПоСтруктуре.Выполнить().Выгрузить();
	
КонецФункции

// Возвращает таблицу объектов, подчиненных регистрам сведений.
// Типы возвращаемых объектов: "Измерение", "Ресурс", "Реквизит".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Родитель   - СправочникСсылка.СтруктураКонфигурации - ссылка на родительский объект (РС).
//     Ссылка     - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//     ТипОбъекта - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//
Функция ПолучитьПодчиненныеЭлементыРегистровСведений()
	
	КлючКонтекста = "ПодчиненныеЭлементыРегистровСведений";
	ПодчиненныеЭлементыРегистровСведений = Контекст[КлючКонтекста];
	Если ПодчиненныеЭлементыРегистровСведений <> Неопределено Тогда
		Возврат ПодчиненныеЭлементыРегистровСведений;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Родитель.Ссылка КАК Родитель,
	|	СтруктураКонфигурации.Ссылка КАК Ссылка,
	|	СтруктураКонфигурации.ТипОбъекта
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Версия
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|	И СтруктураКонфигурации.СобраныСведения
	|	И СтруктураКонфигурации.Родитель.ТипОбъекта = &ТипОбъектаРодителя
	|	И СтруктураКонфигурации.ТипОбъекта В (&МассивТипов)
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|
	|УПОРЯДОЧИТЬ ПО
	|	СтруктураКонфигурации.НомерПоПорядку";
	
	МассивТиповПодчиненныхОбъектов = Новый Массив;
	МассивТиповПодчиненныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Измерение);
	МассивТиповПодчиненныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Ресурс);
	МассивТиповПодчиненныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Реквизит);
	
	Запрос.УстановитьПараметр("Версия", Версия);
	Запрос.УстановитьПараметр("ТипОбъектаРодителя", Перечисления.ТипыОбъектов.РегистрСведений);
	Запрос.УстановитьПараметр("МассивТипов", МассивТиповПодчиненныхОбъектов);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	ПодчиненныеЭлементыРегистровСведений = Запрос.Выполнить().Выгрузить();
	
	ПодчиненныеЭлементыРегистровСведений.Индексы.Добавить("Родитель, ТипОбъекта");
	
	Контекст.Вставить(КлючКонтекста, ПодчиненныеЭлементыРегистровСведений);
	
	Возврат ПодчиненныеЭлементыРегистровСведений;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации с типом объекта "Конфигурация".
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - объект конфигурации с типом "Конфигурация" (корень конфигурации).
//
Функция ПолучитьКореньКонфигурации()
	
	КлючКонтекста = "КореньКонфигурации";
	КореньКонфигурации = Контекст[КлючКонтекста];
	Если КореньКонфигурации <> Неопределено Тогда
		Возврат КореньКонфигурации;
	КонецЕсли;
	
	КореньКонфигурации = ПолучитьЭлементСтруктурыМетаданных(Версия,,, Перечисления.ТипыОбъектов.Конфигурация, Расширение);
	
	Контекст.Вставить(КлючКонтекста, КореньКонфигурации);
	
	Возврат КореньКонфигурации;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "СтандартныеПодсистемы".
// Сначала поиск происходит среди подсистем верхнего уровня, если не найдена, то среди всех подсистем.
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "СтандартныеПодсистемы".
//
Функция ПолучитьПодсистемуСтандартныеПодсистемы()
	
	КлючКонтекста = "ПодсистемаСтандартныеПодсистемы";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаПуть = "Общие.Подсистемы.СтандартныеПодсистемы";
	ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданныхПоПути(Версия, ПодсистемаПуть, Расширение);
	
	Если ПодсистемаСсылка.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия,, "СтандартныеПодсистемы",
			Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "БазоваяФункциональность".
// Сначала поиск происходит в подсистеме "СтандартныеПодсистемы", если не найдена, то среди всех подсистем.
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "БазоваяФункциональность".
//
Функция ПолучитьПодсистемуБазоваяФункциональность()
	
	КлючКонтекста = "ПодсистемаБазоваяФункциональность";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаСсылка = Справочники.СтруктураКонфигурации.ПустаяСсылка();
	
	ПодсистемаСтандартныеПодсистемы = ПолучитьПодсистемуСтандартныеПодсистемы();
	Если НЕ ПодсистемаСтандартныеПодсистемы.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия, ПодсистемаСтандартныеПодсистемы,
			"БазоваяФункциональность", Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "ТехнологияСервиса".
// Сначала поиск происходит среди подсистем верхнего уровня, если не найдена, то среди всех подсистем.
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "ТехнологияСервиса".
//
Функция ПолучитьПодсистемуТехнологияСервиса()
	
	КлючКонтекста = "ПодсистемаТехнологияСервиса";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаПуть = "Общие.Подсистемы.ТехнологияСервиса";
	ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданныхПоПути(Версия, ПодсистемаПуть, Расширение);
	
	Если ПодсистемаСсылка.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия,, "ТехнологияСервиса",
			Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "ВнешниеКомпоненты".
// Поиск происходит среди дочерних подсистем подсистемы "СтандартныеПодсистемы".
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "ВнешниеКомпоненты".
//
Функция ПолучитьПодсистемуВнешниеКомпоненты()
	
	КлючКонтекста = "ПодсистемаВнешниеКомпоненты";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаСсылка = Справочники.СтруктураКонфигурации.ПустаяСсылка();
	
	ПодсистемаСтандартныеПодсистемы = ПолучитьПодсистемуСтандартныеПодсистемы();
	Если НЕ ПодсистемаСтандартныеПодсистемы.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия, ПодсистемаСтандартныеПодсистемы, "ВнешниеКомпоненты",
			Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "ДополнительныеОтчетыИОбработки".
// Поиск происходит среди дочерних подсистем подсистемы "СтандартныеПодсистемы".
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "ДополнительныеОтчетыИОбработки".
//
Функция ПолучитьПодсистемуДополнительныеОтчетыИОбработки()
	
	КлючКонтекста = "ПодсистемаДополнительныеОтчетыИОбработки";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаСсылка = Справочники.СтруктураКонфигурации.ПустаяСсылка();
	
	ПодсистемаСтандартныеПодсистемы = ПолучитьПодсистемуСтандартныеПодсистемы();
	Если НЕ ПодсистемаСтандартныеПодсистемы.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия, ПодсистемаСтандартныеПодсистемы,
			"ДополнительныеОтчетыИОбработки", Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает ссылку на объект проверяемой конфигурации
// с типом объекта "Подсистема" и наименованием "ОбновлениеКонфигурации".
// Поиск происходит среди дочерних подсистем подсистемы "СтандартныеПодсистемы".
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - подсистема с наименованием "ОбновлениеКонфигурации".
//
Функция ПолучитьПодсистемуОбновлениеКонфигурации()
	
	КлючКонтекста = "ПодсистемаОбновлениеКонфигурации";
	ПодсистемаСсылка = Контекст[КлючКонтекста];
	Если ПодсистемаСсылка <> Неопределено Тогда
		Возврат ПодсистемаСсылка;
	КонецЕсли;
	
	ПодсистемаСсылка = Справочники.СтруктураКонфигурации.ПустаяСсылка();
	
	ПодсистемаСтандартныеПодсистемы = ПолучитьПодсистемуСтандартныеПодсистемы();
	Если НЕ ПодсистемаСтандартныеПодсистемы.Пустая() Тогда
		ПодсистемаСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия, ПодсистемаСтандартныеПодсистемы,
			"ОбновлениеКонфигурации", Перечисления.ТипыОбъектов.Подсистема, Расширение);
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ПодсистемаСсылка);
	
	Возврат ПодсистемаСсылка;
	
КонецФункции

// Возвращает таблицу устаревших объектов конфигурации. Объект считается устаревшим,
// если его наименование начинается с префикса "Удалить".
//
// Параметры:
//   ТолькоДляПрав               - Булево - флаг, если равен "Истина", то в таблицу попадут только те устаревшие объекты,
//                                          на которые можно назначить права ролей.
//   ТолькоОбъектыВерхнегоУровня - Булево - флаг, если равен "Истина", то в таблицу попадут только объекты верхнего уровня.
//                                          При значении "Ложь" (в сочетании с ТолькоДляПрав = Ложь) в таблицу попадут
//                                          все устаревшие объекты конфигурации независимо от типа.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов с колонками:
//     Наименование                - Строка                                 - наименование объекта;
//     Путь                        - Строка                                 - полный путь к объекту в дереве метаданных;
//     Ссылка                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     ТипОбъекта                  - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//
Функция ПолучитьУстаревшиеОбъектыМетаданных(ТолькоДляПрав = Истина, ТолькоОбъектыВерхнегоУровня = Истина)
	
	КлючКонтекста = СтрШаблон("УстаревшиеОбъектыМетаданных_%1_%2", ТолькоДляПрав, ТолькоОбъектыВерхнегоУровня);
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТекстУдалить = ВРег("Удалить");
	
	// Определяем массив типов объектов.
	Если ТолькоДляПрав Тогда
		МассивТипов = ПолучитьТипыОбъектовНаКоторыеНазначаютсяПрава(ТолькоОбъектыВерхнегоУровня);
	ИначеЕсли ТолькоОбъектыВерхнегоУровня Тогда
		МассивТипов = ПолучитьТипыОбъектовВерхнегоУровня();
	Иначе
		МассивТипов = ПолучитьВсеТипыОбъектов();
	КонецЕсли;
	
	// Получаем все объекты конфигурации.
	ТаблицаВсехОбъектов = ПолучитьОбъектыКонфигурации();
	ТаблицаУстаревшихОбъектов = ТаблицаВсехОбъектов.СкопироватьКолонки();
	
	// Заполняем таблицу устаревших объектов.
	Для Каждого Строка Из ТаблицаВсехОбъектов Цикл
		// Если объект не подходит по типу, то его не записываем в таблицу.
		Если МассивТипов.Найти(Строка.ТипОбъекта) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		НаименованиеОбъекта = ВРег(Строка.Наименование);
		Если СтрНачинаетсяС(НаименованиеОбъекта, ТекстУдалить) Тогда
			ЗаполнитьЗначенияСвойств(ТаблицаУстаревшихОбъектов.Добавить(), Строка);
		КонецЕсли;
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, ТаблицаУстаревшихОбъектов);
	
	Возврат ТаблицаУстаревшихОбъектов;
	
КонецФункции

// Возвращает код основного языка конфигурации.
//
// Возвращаемое значение:
//   Строка - код языка, который установлен как основной язык конфигурации.
//
Функция ПолучитьКодОсновногоЯзыкаКонфигурации()
	
	КлючКонтекста = "КодОсновногоЯзыкаКонфигурации";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	КореньКонфигурации = ПолучитьКореньКонфигурации();
	Если КореньКонфигурации.Пустая() Тогда
		Контекст.Вставить(КлючКонтекста, "");
		Возврат "";
	КонецЕсли;
	
	ОсновнойЯзыкИмя = ПолучитьСвойство("ОсновнойЯзык", КореньКонфигурации);
	Если ОсновнойЯзыкИмя = Неопределено Тогда
		Контекст.Вставить(КлючКонтекста, "");
		Возврат "";
	КонецЕсли;
	
	ОсновнойЯзыкСсылка = ПолучитьЭлементСтруктурыМетаданных(Версия,, ОсновнойЯзыкИмя, Перечисления.ТипыОбъектов.Язык, Расширение);
	Если ОсновнойЯзыкСсылка.Пустая() Тогда
		Контекст.Вставить(КлючКонтекста, "");
		Возврат "";
	КонецЕсли;
	
	ОсновнойЯзыкКод = ПолучитьСвойство("КодЯзыка", ОсновнойЯзыкСсылка);
	Если ОсновнойЯзыкКод = Неопределено Тогда
		ОсновнойЯзыкКод = "";
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ОсновнойЯзыкКод);
	
	Возврат ОсновнойЯзыкКод;
	
КонецФункции

// Возвращает таблицу объектов и подсистем, в которые входят объекты.
// В таблицу попадут только те объекты, которые входят в подсистему напрямую,
// например, форма справочника в этой таблице будет отсутствовать.
// Пара ОбъектСсылка + ПодсистемаСсылка уникальна.
// Таблица отсортирована по НомерПоПорядку для объекта, затем для подсистемы.
// Таблица проиндексирована по ОбъектСсылка и по ПодсистемаСсылка (отдельные индексы).
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с объектами и подсистемами. Колонки:
//     ОбъектСсылка           - СправочникСсылка.СтруктураКонфигурации - ссылка на объект;
//     ОбъектНаименование     - Строка                                 - наименование объекта;
//     ОбъектТип              - ПеречислениеСсылка.ТипыОбъектов        - тип объекта;
//     ОбъектПуть             - Строка                                 - полный путь к объекту в дереве метаданных;
//     ПодсистемаСсылка       - СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему;
//     ПодсистемаНаименование - Строка                                 - наименование подсистемы;
//     ПодсистемаРодитель     - СправочникСсылка.СтруктураКонфигурации - ссылка на родительскую подсистему;
//     ПодсистемаПуть         - Строка                                 - полный путь к подсистеме в дереве метаданных.
//
Функция ПолучитьПодсистемыОбъектов() Экспорт
	
	КлючКонтекста = "ПодсистемыОбъектов";
	ТаблицаПодсистемОбъектов = Контекст[КлючКонтекста];
	Если ТаблицаПодсистемОбъектов <> Неопределено Тогда
		Возврат ТаблицаПодсистемОбъектов;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК ОбъектСсылка,
	|	СтруктураКонфигурации.Наименование КАК ОбъектНаименование,
	|	СтруктураКонфигурации.ТипОбъекта ОбъектТип,
	|	СтруктураКонфигурации.Путь КАК ОбъектПуть,
	|	СтруктураКонфигурацииПодсистемы.Ссылка КАК ПодсистемаСсылка,
	|	СтруктураКонфигурацииПодсистемы.Наименование КАК ПодсистемаНаименование,
	|	СтруктураКонфигурацииПодсистемы.Родитель КАК ПодсистемаРодитель,
	|	СтруктураКонфигурацииПодсистемы.Путь КАК ПодсистемаПуть
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|	ПРАВОЕ СОЕДИНЕНИЕ Справочник.СтруктураКонфигурации.Подсистемы КАК ТабличнаяЧастьПодсистемы
	|	ПО СтруктураКонфигурации.Ссылка = ТабличнаяЧастьПодсистемы.Ссылка
	|	ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СтруктураКонфигурации КАК СтруктураКонфигурацииПодсистемы
	|	ПО ТабличнаяЧастьПодсистемы.Подсистема = СтруктураКонфигурацииПодсистемы.Ссылка
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Версия
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|УПОРЯДОЧИТЬ ПО
	|	СтруктураКонфигурации.НомерПоПорядку,
	|	СтруктураКонфигурацииПодсистемы.НомерПоПорядку";
	
	Запрос.УстановитьПараметр("Версия", Версия);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	ТаблицаПодсистемОбъектов = Запрос.Выполнить().Выгрузить();
	
	ТаблицаПодсистемОбъектов.Колонки.Добавить("ВключатьВКомандныйИнтерфейс");
	ТаблицаПодсистемОбъектов.ЗаполнитьЗначения(Неопределено, "ВключатьВКомандныйИнтерфейс");
	
	Для Каждого СтрокаТаблицы Из ТаблицаПодсистемОбъектов Цикл
		СтрокаТаблицы.ВключатьВКомандныйИнтерфейс = ПолучитьСвойство("ВключатьВКомандныйИнтерфейс", СтрокаТаблицы.ПодсистемаСсылка);
	КонецЦикла;
	
	ТаблицаПодсистемОбъектов.Индексы.Добавить("ОбъектСсылка");
	ТаблицаПодсистемОбъектов.Индексы.Добавить("ОбъектСсылка, ВключатьВКомандныйИнтерфейс");
	ТаблицаПодсистемОбъектов.Индексы.Добавить("ПодсистемаСсылка");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаПодсистемОбъектов);
	
	Возврат ТаблицаПодсистемОбъектов;
	
КонецФункции

// Возвращает таблицу подсистем, к которым относится указанный объект конфигурации.
// Данная функция копирует результат функции ПолучитьПодсистемыОбъектов() с отбором по указанному объекту.
//
// Параметры:
//   ОбъектКонфигурации          - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                                 Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//   ВключатьВКомандныйИнтерфейс - Булево, Неопределено - флаг, по которому будут отфильтрованы подсистемы в результате.
//                                 Если Неопределено, то будут включены все подсистемы в структуре конфигурации.
//                                 Если Истина, то будут включены только подсистемы с включенным флажком
//                                 "Включать в командный интерфейс".
//                                 Если Ложь, то будут включены только подсистемы с выключенным флажком
//                                 "Включать в командный интерфейс".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с объектами и подсистемами. Колонки:
//     ОбъектСсылка           - СправочникСсылка.СтруктураКонфигурации - ссылка на указанный объект;
//     ОбъектНаименование     - Строка                                 - наименование указанного объекта;
//     ОбъектТип              - ПеречислениеСсылка.ТипыОбъектов        - тип указанного объекта;
//     ОбъектПуть             - Строка                                 - полный путь к объекту в дереве метаданных;
//     ПодсистемаСсылка       - СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему;
//     ПодсистемаНаименование - Строка                                 - наименование подсистемы;
//     ПодсистемаРодитель     - СправочникСсылка.СтруктураКонфигурации - ссылка на родительскую подсистему;
//     ПодсистемаПуть         - Строка                                 - полный путь к подсистеме в дереве метаданных.
//
Функция ПолучитьПодсистемыОбъекта(ОбъектКонфигурации = Неопределено, ВключатьВКомандныйИнтерфейс = Неопределено) Экспорт
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = СтрШаблон("Функция_ПолучитьПодсистемыОбъекта_%1", ВключатьВКомандныйИнтерфейс);
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("ОбъектСсылка", ОбъектСсылка);
	Если ВключатьВКомандныйИнтерфейс <> Неопределено Тогда
		СтруктураОтбора.Вставить("ВключатьВКомандныйИнтерфейс", ВключатьВКомандныйИнтерфейс);
	КонецЕсли;
	
	ТаблицаПодсистемОбъектов = ПолучитьПодсистемыОбъектов();
	ТаблицаПодсистемОбъекта = ТаблицаПодсистемОбъектов.Скопировать(СтруктураОтбора);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаПодсистемОбъекта);
	
	Возврат ТаблицаПодсистемОбъекта;
	
КонецФункции

// Возвращает соответствие всех объектов конфигурации.
// Используется для ускорения получения значений реквизитов объектов,
// т.к. получение реквизита через точку, например, "ОбъектКонфигурации.ТипОбъекта", работает очень медленно.
//
// Возвращаемое значение:
//   Соответствие - соответствие объектов конфигурации:
//     Ключ     - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации;
//     Значение - СтрокаТаблицыЗначений                  - строка объекта конфигурации со значениями основных реквизитов,
//                                                         полученная из функции "ПолучитьОбъектыКонфигурации()".
//
Функция ПолучитьСоответствиеОбъектов()
	
	КлючКонтекста = "СоответствиеОбъектов";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	СоответствиеОбъектов = Новый Соответствие;
	
	ТаблицаОбъектов = ПолучитьОбъектыКонфигурации();
	
	Для Каждого СтрокаОбъекта Из ТаблицаОбъектов Цикл
		СоответствиеОбъектов.Вставить(СтрокаОбъекта.Ссылка, СтрокаОбъекта);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеОбъектов);
	
	Возврат СоответствиеОбъектов;
	
КонецФункции

// Возвращает строку таблицы значений, полученную из функции "ПолучитьОбъектыКонфигурации()",
// со значениями основных реквизитов указанного объекта конфигурации.
// Используется для ускорения получения значения реквизита объекта,
// т.к. получение реквизита через точку, например, "ОбъектКонфигурации.ТипОбъекта", работает очень медленно.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации.
//
// Возвращаемое значение:
//   СтрокаТаблицыЗначений - строка таблицы значений со значениями основных реквизитов.
//
Функция ПолучитьОбъект(ОбъектКонфигурации)
	
	СоответствиеОбъектов = ПолучитьСоответствиеОбъектов();
	
	Возврат СоответствиеОбъектов[ОбъектКонфигурации];
	
КонецФункции

// Возвращает значение реквизита указанного объекта конфигурации
// Используется для ускорения получения значения реквизита объекта,
// т.к. получение реквизита через точку, например, "ОбъектКонфигурации.ТипОбъекта", работает очень медленно.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации.
//   ИмяРеквизита       - Строка                                 - имя реквизита объекта конфигурации.
//
// Возвращаемое значение:
//   ЛюбойТип - значение реквизита указанного объекта конфигурации.
//
Функция ПолучитьРеквизитОбъекта(ОбъектКонфигурации, ИмяРеквизита)
	
	Значение = Неопределено;
	
	ЭлементОбъекта = ПолучитьОбъект(ОбъектКонфигурации);
	Если ЭлементОбъекта <> Неопределено Тогда
		Значение = ЭлементОбъекта[ИмяРеквизита];
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Возвращает объект основной конфигурации, который соответствует переданному объекту расширения.
//
// Параметры:
//   ОбъектРасширения - СправочникСсылка.СтруктураКонфигурации - ссылка на объект расширения.
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - ссылка на объект основной конфигурации.
//
Функция ПолучитьОбъектКонфигурацииСоответствующийОбъектуРасширения(ОбъектРасширения = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектРасширения = Неопределено) ИЛИ (ОбъектРасширения = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьОбъектКонфигурацииСоответствующийОбъектуРасширения";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	Если ФлагИспользованиеКэша Тогда
		ОбъектПуть = ОбъектПроверкиПуть;
		ОбъектТип = ОбъектПроверкиТипОбъекта;
	Иначе
		ОбъектПуть = ОбъектРасширения.Путь;
		ОбъектТип = ОбъектРасширения.ТипОбъекта;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СтруктураКонфигурации.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец.Владелец = &Конфигурация
	|	И СтруктураКонфигурации.Путь = &Путь
	|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|
	|УПОРЯДОЧИТЬ ПО
	|	СтруктураКонфигурации.Код УБЫВ";
	
	Запрос.УстановитьПараметр("Конфигурация", Версия.Владелец);
	Запрос.УстановитьПараметр("Путь", ОбъектПуть);
	Запрос.УстановитьПараметр("ТипОбъекта", ОбъектТип);
	Запрос.УстановитьПараметр("Расширение", Справочники.Расширения.ПустаяСсылка());
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ОбъектКонфигурацииСсылка = ?(Выборка.Следующий(), Выборка.Ссылка, Справочники.СтруктураКонфигурации.ПустаяСсылка());
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ОбъектКонфигурацииСсылка);
	КонецЕсли;
	
	Возврат ОбъектКонфигурацииСсылка;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСоСвойствамиМетаданных

// Возвращает структуру со свойствами и их значениями для указанного объекта конфигурации.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Структура - структура свойств объекта конфигурации:
//     Ключ     - Строка   - имя свойства.
//     Значение - ЛюбойТип - значение свойства.
//
Функция ПолучитьСвойства(ОбъектКонфигурации = Неопределено) Экспорт
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьСвойства";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ЗапросПоСвойствам = Новый Запрос;
	ЗапросПоСвойствам.Текст = "
	|ВЫБРАТЬ
	|	ЗначенияСвойствОбъектов.Имя КАК Имя,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Объект = &Объект";
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	ЗапросПоСвойствам.УстановитьПараметр("Объект", ОбъектСсылка);
	
	СтруктураСвойств = Новый Структура;
	ВыборкаСвойств = ЗапросПоСвойствам.Выполнить().Выбрать();
	Пока ВыборкаСвойств.Следующий() Цикл
		СтруктураСвойств.Вставить(ВыборкаСвойств.Имя, ВыборкаСвойств.Значение);
	КонецЦикла;
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	КонецЕсли;
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает структуру со свойствами и их значениями для родителя текущего объекта конфигурации.
//
// Возвращаемое значение:
//   Структура - структура свойств объекта конфигурации:
//     Ключ     - Строка   - имя свойства.
//     Значение - ЛюбойТип - значение свойства.
//
Функция ПолучитьСвойстваРодителя()
	
	КлючЗначенияКэша = "Функция_ПолучитьСвойстваРодителя";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ЗапросПоСвойствам = Новый Запрос;
	ЗапросПоСвойствам.Текст = "
	|ВЫБРАТЬ
	|	ЗначенияСвойствОбъектов.Имя КАК Имя,
	|	ЗначенияСвойствОбъектов.Значение КАК Значение
	|ИЗ
	|	РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Объект = &Объект";
	
	ЗапросПоСвойствам.УстановитьПараметр("Объект", ОбъектПроверкиРодитель);
	
	СтруктураСвойств = Новый Структура;
	ВыборкаСвойств = ЗапросПоСвойствам.Выполнить().Выбрать();
	Пока ВыборкаСвойств.Следующий() Цикл
		СтруктураСвойств.Вставить(ВыборкаСвойств.Имя, ВыборкаСвойств.Значение);
	КонецЦикла;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает значение свойства для указанного объекта конфигурации.
// Значение получается из РС "ЗначенияСвойствОбъектов", в котором хранятся такие свойства, как "Синоним".
//
// Параметры:
//   ИмяСвойства        - Строка                                               - имя свойства.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ЛюбойТип - значение свойства. Если свойство не найдено по имени, возвращается Неопределено.
//
Функция ПолучитьСвойство(ИмяСвойства, ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = ИмяСвойства;
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	Результат = Неопределено;
	
	ЗапросПоСвойству = Новый Запрос;
	ЗапросПоСвойству.Текст = "
	|ВЫБРАТЬ
	|	ЗначенияСвойствОбъектов.Значение
	|ИЗ
	|	РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствОбъектов
	|ГДЕ
	|	ЗначенияСвойствОбъектов.Объект = &Объект
	|	И ЗначенияСвойствОбъектов.Имя = &Имя";
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	ЗапросПоСвойству.УстановитьПараметр("Объект", ОбъектСсылка);
	ЗапросПоСвойству.УстановитьПараметр("Имя", ИмяСвойства);
	
	ВыборкаСвойства = ЗапросПоСвойству.Выполнить().Выбрать();
	Если ВыборкаСвойства.Следующий() Тогда
		Результат = ВыборкаСвойства.Значение;
		Если ФлагИспользованиеКэша Тогда
			КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение составного свойства для указанного объекта конфигурации.
// Значение получается из РС "ЗначенияСоставныхСвойствОбъектов", в котором хранятся такие свойства, как "МодульОбъекта".
//
// Параметры:
//   ИмяСвойства        - Строка                                               - имя свойства.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ХранилищеЗначения - значение свойства. Если свойство не найдено по имени, возвращается Неопределено.
//
Функция ПолучитьСоставноеСвойство(ИмяСвойства, ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = ИмяСвойства;
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗнч(ИмяСвойства) = Тип("Строка") Тогда
		ИмяСвойства = ИмяСостСвойства[ИмяСвойства];
		Если ИмяСвойства = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Результат = Неопределено;
	
	ЗапросПоСоставномуСвойству = Новый Запрос;
	ЗапросПоСоставномуСвойству.Текст = "
	|ВЫБРАТЬ
	|	ЗначенияСоставныхСвойствОбъектов.Значение
	|ИЗ
	|	РегистрСведений.ЗначенияСоставныхСвойствОбъектов КАК ЗначенияСоставныхСвойствОбъектов
	|ГДЕ
	|	ЗначенияСоставныхСвойствОбъектов.Объект = &Объект
	|	И ЗначенияСоставныхСвойствОбъектов.Имя = &Имя";
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	ЗапросПоСоставномуСвойству.УстановитьПараметр("Объект", ОбъектСсылка);
	ЗапросПоСоставномуСвойству.УстановитьПараметр("Имя", ИмяСвойства);
	
	ВыборкаСоставногоСвойства = ЗапросПоСоставномуСвойству.Выполнить().Выбрать();
	Если ВыборкаСоставногоСвойства.Следующий() Тогда
		Результат = ВыборкаСоставногоСвойства.Значение.Получить();
		Если ФлагИспользованиеКэша Тогда
			КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру типа текущего объекта конфигурации, если такой для него определен.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Структура - структура типа. Если свойство "Тип" не определено для объекта конфигурации, то возвращается Неопределено.
//   Структура имеет фиксированные ключи:
//     Длина                   - Число  - длина типа для объекта числового или строкового типа.
//     ДопустимаяДлина         - Строка - допустимая длина типа для объекта строкового типа.
//     ДопустимыйЗнак          - Строка - допустимый знак типа для объекта числового типа.
//     Разрядность             - Число  - разрядность типа для объекта числового типа.
//     РазрядностьДробнойЧасти - Число  - разрядность дробной части типа для объекта числового типа.
//     Тип                     - Массив - массив всех типов объекта, в т.ч. для объекта составного типа.
//     ЧастиДаты               - Строка - части даты типа для объекта типа "Дата".
//
Функция ПолучитьТип(ОбъектКонфигурации = Неопределено) Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Тип, ОбъектКонфигурации);
	
КонецФункции

// Возвращает структуру типа параметра команды текущего объекта конфигурации, если такой для него определен.
// Тип параметра команды определен для команд и общих команд.
//
// Возвращаемое значение:
//   Структура - структура типа параметра команды. Если свойство "ТипПараметраКоманды" не определено для объекта
//   конфигурации, то возвращается Неопределено. Структура имеет фиксированные ключи:
//     Длина                   - Число  - длина типа для объекта числового или строкового типа.
//     ДопустимаяДлина         - Строка - допустимая длина типа для объекта строкового типа.
//     ДопустимыйЗнак          - Строка - допустимый знак типа для объекта числового типа.
//     Разрядность             - Число  - разрядность типа для объекта числового типа.
//     РазрядностьДробнойЧасти - Число  - разрядность дробной части типа для объекта числового типа.
//     Тип                     - Массив - массив всех типов объекта, в т.ч. для объекта составного типа.
//     ЧастиДаты               - Строка - части даты типа для объекта типа "Дата".
//
Функция ПолучитьТипПараметраКоманды()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.ТипПараметраКоманды);
	
КонецФункции

// Возвращает дерево значений с предопределенными элементами текущего объекта конфигурации,
// если такой для него определен.
//
// Возвращаемое значение:
//   ДеревоЗначений, Неопределено - дерево предопределенных элементов с колонками:
//     Имя          - Строка - имя предопределенного элемента.
//     Код          - Строка - код предопределенного элемента.
//     Наименование - Строка - наименование предопределенного элемента.
//     ЭтоГруппа    - Булево - флаг, показывающий является ли предопределенный элемент группой.
//
Функция ПолучитьПредопределенные()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Предопределенные);
	
КонецФункции

// Получает состав общего реквизита.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с объектами метаданных, входящих в состав общего реквизита. Колонки:
//     Использование      - ИспользованиеОбщегоРеквизита - использование общего реквизита;
//     Метаданные         - Строка                       - полное имя объекта метаданных;
//     УсловноеРазделение - Строка                       - полное имя константы.
//
Функция ПолучитьСоставОбщегоРеквизита(ОбъектКонфигурации = Неопределено) Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Состав, ОбъектКонфигурации);
	
КонецФункции

// Получает массив общих реквизитов-разделителей.
//
// Параметры:
//   ИспользованиеРазделяемыхДанных - Строка - значение свойства общего реквизита "Использование разделяемых данных".
//                                             Может принимать значения: "Независимо" и "НезависимоИСовместно".
//                                             По данному свойству и значению будут отфильтрованы общие реквизиты.
//                                             Если параметр не заполнен, то в массив попадут все общие реквизиты.
//
// Возвращаемое значение:
//   Массив - массив общих реквизитов. Элементы массива:
//     СправочникСсылка.СтруктураКонфигурации - ссылка на объект общего реквизита.
//
Функция ПолучитьМассивОбщихРеквизитовРазделителей(ИспользованиеРазделяемыхДанных = "")
	
	КлючКонтекста = СтрШаблон("МассивОбщихРеквизитовРазделителей_%1", ИспользованиеРазделяемыхДанных);
	МассивОбщихРеквизитовРазделителей = Контекст[КлючКонтекста];
	Если МассивОбщихРеквизитовРазделителей <> Неопределено Тогда
		Возврат МассивОбщихРеквизитовРазделителей;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствРазделениеДанных
	|		ПО ЗначенияСвойствРазделениеДанных.Объект = СтруктураКонфигурации.Ссылка
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ЗначенияСвойствОбъектов КАК ЗначенияСвойствИспользованиеРазделяемыхДанных
	|		ПО ЗначенияСвойствИспользованиеРазделяемыхДанных.Объект = СтруктураКонфигурации.Ссылка
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Владелец
	|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|	И ЗначенияСвойствРазделениеДанных.Имя = &ИмяРазделениеДанных
	|	И ЗначенияСвойствРазделениеДанных.Значение = &ЗначениеРазделениеДанных
	|	И ЗначенияСвойствИспользованиеРазделяемыхДанных.Имя = &ИмяИспользованиеРазделяемыхДанных
	|	И ЗначенияСвойствИспользованиеРазделяемыхДанных.Значение В(&ЗначениеИспользованиеРазделяемыхДанных)";
	
	Запрос.УстановитьПараметр("Владелец", Версия);
	Запрос.УстановитьПараметр("ТипОбъекта", Перечисления.ТипыОбъектов.ОбщийРеквизит);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	Запрос.УстановитьПараметр("ИмяРазделениеДанных", "РазделениеДанных");
	Запрос.УстановитьПараметр("ЗначениеРазделениеДанных", "Разделять");
	Запрос.УстановитьПараметр("ИмяИспользованиеРазделяемыхДанных", "ИспользованиеРазделяемыхДанных");
	
	ЗначениеИспользованиеРазделяемыхДанных = Новый Массив;
	Если ПустаяСтрока(ИспользованиеРазделяемыхДанных) Тогда
		ЗначениеИспользованиеРазделяемыхДанных.Добавить("Независимо");
		ЗначениеИспользованиеРазделяемыхДанных.Добавить("НезависимоИСовместно");
	Иначе
		ЗначениеИспользованиеРазделяемыхДанных.Добавить(ИспользованиеРазделяемыхДанных);
	КонецЕсли;
	Запрос.УстановитьПараметр("ЗначениеИспользованиеРазделяемыхДанных", ЗначениеИспользованиеРазделяемыхДанных);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	МассивОбщихРеквизитовРазделителей = РезультатЗапроса.ВыгрузитьКолонку("Ссылка");
	
	Контекст.Вставить(КлючКонтекста, МассивОбщихРеквизитовРазделителей);
	
	Возврат МассивОбщихРеквизитовРазделителей;
	
КонецФункции

// Получает состав общих реквизитов, перечисленных в массиве "МассивРазделителей".
//
// Параметры:
//   МассивРазделителей - Массив - массив со ссылками на общие реквизиты, состав которых необходимо получить.
//
// Возвращаемое значение:
//   Соответствие - состав общих реквизитов.
//     Ключ     - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации.
//     Значение - Булево                                 - Истина.
//
Функция ПолучитьСоставОбщихРеквизитовРазделителей(МассивРазделителей)
	
	СоставРазделяемыхДанных = Новый Соответствие;
	
	Если МассивРазделителей.Количество() = 0 Тогда
		Возврат СоставРазделяемыхДанных;
	КонецЕсли;
	
	ТипыОбъектов = ЗаполнитьТаблицуТиповОбъектов();
	
	Для Каждого Разделитель Из МассивРазделителей Цикл
		
		АвтоИспользование = ПолучитьСвойство("АвтоИспользование", Разделитель);
		ПолныйСоставОбщегоРеквизита = ПолучитьСоставОбщегоРеквизита(Разделитель);
		
		Для Каждого ОбъектСостава Из ПолныйСоставОбщегоРеквизита Цикл
			
			Использование = Строка(ОбъектСостава.Использование);
			
			Если Использование = "НеИспользовать" Тогда
				Продолжить;
			КонецЕсли;
			
			Если (Использование = "Авто") И (АвтоИспользование = "НеИспользовать") Тогда
				Продолжить;
			КонецЕсли;
			
			ОбъектКонфигурации = ПолучитьСсылкуНаОбъектПоПути(Версия, ОбъектСостава.Метаданные, ТипыОбъектов, Расширение);
			СоставРазделяемыхДанных.Вставить(ОбъектКонфигурации, Истина);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат СоставРазделяемыхДанных;
	
КонецФункции

// Получает структуру данных общих реквизитов, у которых в свойстве "Использование разделяемых данных" установлено
// значение "Независимо".
//
// Возвращаемое значение:
//   Структура - структура данных независимых разделителей с ключами:
//     СоставРазделителей               - Соответствие    - состав общих реквизитов с независимым использованием
//                                                          разделяемых данных.
//     ТаблицаРазделителей              - ТаблицаЗначений - таблица общих реквизитов с колонками:
//       Ссылка    - СправочникСсылка.СтруктураКонфигурации - ссылка на объект общего реквизита;
//       ДлинаПоля - Число                                  - длина поля объекта в зависимости от типа (в байтах).
//     МаксимальнаяДлинаПоляРазделителя - Число           - максимальная длина поля общего реквизита (в байтах).
//     СуммаДлинПолейРазделителей       - Число           - сумма длин полей общих реквизитов (в байтах).
//
Функция ПолучитьСтруктуруДанныхНезависимыхРазделителей()
	
	КлючКонтекста = "СтруктураДанныхНезависимыхРазделителей";
	СтруктураДанныхНезависимыхРазделителей = Контекст[КлючКонтекста];
	Если СтруктураДанныхНезависимыхРазделителей <> Неопределено Тогда
		Возврат СтруктураДанныхНезависимыхРазделителей;
	КонецЕсли;
	
	МассивРазделителей = ПолучитьМассивОбщихРеквизитовРазделителей("Независимо");
	
	СоставРазделителей = ПолучитьСоставОбщихРеквизитовРазделителей(МассивРазделителей);
	
	ТаблицаРазделителей = Новый ТаблицаЗначений;
	ТаблицаРазделителей.Колонки.Добавить("Ссылка");
	ТаблицаРазделителей.Колонки.Добавить("ДлинаПоля");
	
	МаксимальнаяДлинаПоляРазделителя = 0;
	СуммаДлинПолейРазделителей = 0;
	
	Для Каждого ЭлементМассива Из МассивРазделителей Цикл
		
		ДлинаПоляРазделителя = ПолучитьДлинуПоляОбъектаМетаданных(ЭлементМассива);
		
		НовыйРазделитель = ТаблицаРазделителей.Добавить();
		НовыйРазделитель.Ссылка = ЭлементМассива;
		НовыйРазделитель.ДлинаПоля = ДлинаПоляРазделителя;
		
		МаксимальнаяДлинаПоляРазделителя = Макс(МаксимальнаяДлинаПоляРазделителя, ДлинаПоляРазделителя);
		СуммаДлинПолейРазделителей = СуммаДлинПолейРазделителей + ДлинаПоляРазделителя;
		
	КонецЦикла;
	
	СтруктураДанныхНезависимыхРазделителей = Новый Структура;
	СтруктураДанныхНезависимыхРазделителей.Вставить("СоставРазделителей", СоставРазделителей);
	СтруктураДанныхНезависимыхРазделителей.Вставить("ТаблицаРазделителей", ТаблицаРазделителей);
	СтруктураДанныхНезависимыхРазделителей.Вставить("МаксимальнаяДлинаПоляРазделителя", МаксимальнаяДлинаПоляРазделителя);
	СтруктураДанныхНезависимыхРазделителей.Вставить("СуммаДлинПолейРазделителей", СуммаДлинПолейРазделителей);
	
	Контекст.Вставить(КлючКонтекста, СтруктураДанныхНезависимыхРазделителей);
	
	Возврат СтруктураДанныхНезависимыхРазделителей;
	
КонецФункции

// Получает состав плана обмена.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Массив - массив с объектами метаданных, входящих в состав плана обмена.
//   Элементы массива - СправочникСсылка.СтруктураКонфигурации.
//
Функция ПолучитьСоставПланаОбмена(ОбъектКонфигурации = Неопределено)
	
	СоставПланаОбмена = Новый Массив;
	
	СвойствоСостав = ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Состав, ОбъектКонфигурации);
	Если СвойствоСостав = Неопределено Тогда
		Возврат СоставПланаОбмена;
	КонецЕсли;
	
	ТипыОбъектов = ЗаполнитьТаблицуТиповОбъектов();
	
	Для Каждого СтрокаСостава Из СвойствоСостав Цикл
		ОбъектСсылка = ПолучитьСсылкуНаОбъектПоПути(Версия, СтрокаСостава.Метаданные, ТипыОбъектов);
		Если НЕ ОбъектСсылка.Пустая() Тогда
			СоставПланаОбмена.Добавить(ОбъектСсылка);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СоставПланаОбмена;
	
КонецФункции

// Получает состав планов обмена.
//
// Параметры:
//   ТолькоСоставПлановОбменаРИБ - Булево - флаг, если равен "Истина", то будет получен состав только тех планов обмена,
//                                          у которых установлено свойство "Распределенная информационная база".
//                                          При значении "Ложь" будет получен состав всех планов обмена.
//
// Возвращаемое значение:
//   Массив - массив с объектами метаданных, входящих в состав планов обмена.
//   Элементы массива - СправочникСсылка.СтруктураКонфигурации.
//
Функция ПолучитьСоставПлановОбмена(ТолькоСоставПлановОбменаРИБ = Истина)
	
	КлючКонтекста = "СоставПлановОбмена_" + ТолькоСоставПлановОбменаРИБ;
	СоставПлановОбмена = Контекст[КлючКонтекста];
	Если СоставПлановОбмена <> Неопределено Тогда
		Возврат СоставПлановОбмена;
	КонецЕсли;
	
	СоставПлановОбмена = Новый Массив;
	
	ТаблицаПлановОбмена = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.ПланОбмена);
	Если ТаблицаПлановОбмена.Количество() = 0 Тогда
		Возврат СоставПлановОбмена;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТаблицаПлановОбмена Цикл
		
		ПланОбменаСсылка = СтрокаТаблицы.Ссылка;
		
		Если ТолькоСоставПлановОбменаРИБ Тогда
			СвойстваПланаОбмена = ПолучитьСвойства(ПланОбменаСсылка);
			Если НЕ СвойстваПланаОбмена.Свойство("РаспределеннаяИнформационнаяБаза") Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ СвойстваПланаОбмена.РаспределеннаяИнформационнаяБаза Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		СоставПланаОбмена = ПолучитьСоставПланаОбмена(ПланОбменаСсылка);
		Для Каждого ОбъектСсылка Из СоставПланаОбмена Цикл
			Если СоставПлановОбмена.Найти(ОбъектСсылка) = Неопределено Тогда
				СоставПлановОбмена.Добавить(ОбъектСсылка);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоставПлановОбмена);
	
	Возврат СоставПлановОбмена;
	
КонецФункции

// Возвращает список шаблонов заданий очереди.
//
// Возвращаемое значение:
//   Массив - имена предопределенных неразделенных регламентных заданий, которые используются
//            в качестве шаблонов для заданий очереди.
//
Функция ПолучитьШаблоныЗаданийОчереди() Экспорт
	
	КлючКонтекста = "ШаблоныЗаданийОчереди";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ВеткаРегламентныеЗадания = ПолучитьЭлементСтруктурыМетаданных(Версия,, "РегламентныеЗадания",
		Перечисления.ТипыОбъектов.ВеткаМетаданных, Расширение);
	МассивШаблонов = ПолучитьСоставноеСвойство(КлючКонтекста, ВеткаРегламентныеЗадания);
	
	Контекст.Вставить(КлючКонтекста, МассивШаблонов);
	
	Возврат МассивШаблонов;
	
КонецФункции

// Формирует таблицу зависимостей регламентных заданий от функциональных опций.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица значений с колонками:
//     РегламентноеЗадание - Строка - имя регламентного задания.
//     ФункциональнаяОпция - Строка - имя функциональной опции, от которой зависит регламентное задание.
//     ЗависимостьПоИ      - Булево - если регламентное задание зависит более, чем
//         от одной функциональной опции и его необходимо включать только тогда,
//         когда все функциональные опции включены, то следует указывать Истина
//         для каждой зависимости.
//         По умолчанию Ложь - если хотя бы одна функциональная опция включена,
//         то регламентное задание тоже включено.
//     ВключатьПриВключенииФункциональнойОпции - Булево, Неопределено - если Ложь, то при
//         включении функциональной опции регламентное задание не будет включаться. Значение
//         Неопределено соответствует значению Истина.
//         По умолчанию - неопределено.
//     ДоступноВПодчиненномУзлеРИБ - Булево, Неопределено - Истина или Неопределено, если регламентное
//         задание доступно в РИБ.
//         По умолчанию - неопределено.
//     ДоступноВМоделиСервиса      - Булево, Неопределено - Истина или Неопределено, если регламентное
//         задание доступно в модели сервиса.
//         По умолчанию - неопределено.
//     РаботаетСВнешнимиРесурсами   - Булево - Истина, если регламентное задание работает
//         с внешними ресурсами (получение почты, синхронизация данных и т.п.).
//         По умолчанию - Ложь.
//
Функция ПолучитьРегламентныеЗаданияЗависимыеОтФункциональныхОпций() Экспорт
	
	КлючКонтекста = "РегламентныеЗаданияЗависимыеОтФункциональныхОпций";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ВеткаРегламентныеЗадания = ПолучитьЭлементСтруктурыМетаданных(Версия,, "РегламентныеЗадания",
		Перечисления.ТипыОбъектов.ВеткаМетаданных, Расширение);
	РегламентныеЗаданияЗависимыеОтФункциональныхОпций = ПолучитьСоставноеСвойство(КлючКонтекста, ВеткаРегламентныеЗадания);
	
	Контекст.Вставить(КлючКонтекста, РегламентныеЗаданияЗависимыеОтФункциональныхОпций);
	
	Возврат РегламентныеЗаданияЗависимыеОтФункциональныхОпций;
	
КонецФункции

// Получает таблицу итераций обновления.
//
// Параметры:
//   КореньКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект корня конфигурации.
//                        Если не параметр заполнен, то корень конфигурации будет получен внутри самой функции.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица итераций обновления с колонками:
//     ПараллельноеОтложенноеОбновлениеСВерсии - Строка - версия подсистемы, с которой происходит параллельное обновление.
//     Подсистема                              - Строка - наименование подсистемы.
//     НачальноеЗаполнение                     - Булево - флаг начального заполнения.
//     Версия                                  - Строка - версия подсистемы.
//     Процедура                               - Строка - имя процедуры-обработчика.
//     РежимВыполнения                         - Строка - режим выполнения, значения: "Монопольно", "Отложенно".
//     ВыполнятьВГруппеОбязательных            - Булево - флаг, надо ли выполнять в группе обязательных обработчиков.
//     ОбщиеДанные                             - Булево - флаг общих данных.
//     УправлениеОбработчиками                 - Булево - флаг управления обработчиками.
//     Комментарий                             - Строка - текст комментария.
//     ПроцедураПроверки                       - Строка - имя процедуры проверки.
//     БлокируемыеОбъекты                      - Строка - полные имена блокируемых объектов через запятую.
//     ПроцедураЗаполненияДанныхОбновления     - Строка - имя процедуры заполнения данных обновления.
//     ОчередьОтложеннойОбработки              - Число  - очередь отложенной обработки.
//     ЗапускатьТолькоВГлавномУзле             - Булево - флаг, запускать только в главном узле.
//     ЗапускатьИВПодчиненномУзлеРИБСФильтрами - Булево - флаг, запускать в главном и подчиненном узле РИБ с фильтрами.
//     ЧитаемыеОбъекты                         - Строка - полные имена читаемых объектов через запятую.
//     ИзменяемыеОбъекты                       - Строка - полные имена изменяемых объектов через запятую.
//     Приоритет                               - Число  - приоритет.
//     МонопольныйРежим                        - Булево - флаг монопольного режима.
//
Функция ПолучитьТаблицуИтерацийОбновления(КореньКонфигурации = Неопределено)
	
	КлючКонтекста = "ТаблицаИтерацийОбновления";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	Если КореньКонфигурации = Неопределено Тогда
		КореньКонфигурации = ПолучитьКореньКонфигурации();
	КонецЕсли;
	
	ТаблицаИтераций = ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.ИтерацииОбновления, КореньКонфигурации);
	Если ТаблицаИтераций = Неопределено Тогда
		Возврат ТаблицаИтераций;
	КонецЕсли;
	
	ТаблицаИтераций.Индексы.Добавить("РежимВыполнения");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаИтераций);
	
	Возврат ТаблицаИтераций;
	
КонецФункции

// Получает доступные версии формата обмена EnterpriseData для текущего плана обмена.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Массив - массив доступных версий формата обмена:
//     Элемент массива - Строка - версия в формате "X.Y", например, "1.3".
//
Функция ПолучитьВерсииФорматаОбменаEnterpriseData(ОбъектКонфигурации = Неопределено) Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.ВерсииФорматаОбменаEnterpriseData, ОбъектКонфигурации);
	
КонецФункции

// Формирует дерево расписаний регламентного задания.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево расписаний регламентного задания с колонками:
//     Свойство - Строка   - имя свойства.
//     Значение - Строка   - значение свойства.
//
Функция ПолучитьРасписаниеРегламентногоЗадания() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьРасписаниеРегламентногоЗадания";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ДеревоРасписаний = Новый ДеревоЗначений;
	ДеревоРасписаний.Колонки.Добавить("Значение");
	ДеревоРасписаний.Колонки.Добавить("Свойство");
	
	МассивРасписаний = ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.РасписаниеРегламентногоЗадания);
	
	Если ТипЗнч(МассивРасписаний) <> Тип("Массив") Тогда
		Возврат ДеревоРасписаний;
	КонецЕсли;
	
	ПервыйЭлемент = Истина;
	Для Каждого ЭлементМассива Из МассивРасписаний Цикл
		
		Если ПервыйЭлемент Тогда
			ИмяСвойства = "Общее";
		Иначе
			ИмяСвойства = "Детальное";
		КонецЕсли;
		
		Если МассивРасписаний.Количество() > 1 Тогда
			ВеткаРасписания = ДеревоРасписаний.Строки.Добавить();
			ВеткаРасписания.Свойство = ИмяСвойства;
			ВеткаРасписания.Значение = "";
		Иначе
			ВеткаРасписания = ДеревоРасписаний;
		КонецЕсли;
		
		ПервыйЭлемент = Ложь;
		
		Для Каждого СтрокаРасписания Из ЭлементМассива Цикл
			НоваяСтрока = ВеткаРасписания.Строки.Добавить();
			НоваяСтрока.Свойство = СтрокаРасписания.Ключ;
			НоваяСтрока.Значение = СтрокаРасписания.Значение;
		КонецЦикла;
		
	КонецЦикла;
	
	ДеревоРасписаний.Строки.Сортировать("Свойство", Истина);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ДеревоРасписаний);
	
	Возврат ДеревоРасписаний;
	
КонецФункции

// Формирует дерево типов параметров команды.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево типов параметров команды. с колонками:
//     Свойство - Строка   - имя свойства.
//     Значение - Строка   - значение свойства.
//
Функция ПолучитьДеревоТипаПараметраКоманды() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьТипПараметраКоманды";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ДеревоТипаПараметра = Новый ДеревоЗначений;
	ДеревоТипаПараметра.Колонки.Добавить("Значение");
	ДеревоТипаПараметра.Колонки.Добавить("Свойство");
	
	СтруктураТипа = ПолучитьТипПараметраКоманды();
	Если ТипЗнч(СтруктураТипа) <> Тип("Структура") Тогда
		Возврат ДеревоТипаПараметра;
	КонецЕсли;
	
	Для Каждого ЭлементСтруктуры Из СтруктураТипа Цикл
		
		Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("ТаблицаЗначений") Тогда
			Продолжить;
		КонецЕсли;
		
		ВеткаСвойств = ДеревоТипаПараметра.Строки.Добавить();
		ВеткаСвойств.Свойство = ЭлементСтруктуры.Ключ;
		ВеткаСвойств.Значение = ЭлементСтруктуры.Значение;
		ЗаполнитьЗначенияСвойств(ВеткаСвойств, ЭлементСтруктуры);
		
		Если ТипЗнч(ЭлементСтруктуры.Значение) = Тип("Массив")
			И СтрСравнить(ЭлементСтруктуры.Ключ, "Тип") = 0 Тогда
			
			ВеткаСвойств.Значение = "Типы";
			
			Для Каждого ТекущийТип Из ЭлементСтруктуры.Значение Цикл
				НоваяСтрока = ВеткаСвойств.Строки.Добавить();
				НоваяСтрока.Свойство = "Тип";
				НоваяСтрока.Значение = ТекущийТип;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	ДеревоТипаПараметра.Строки.Сортировать("Свойство", Истина);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ДеревоТипаПараметра);
	
	Возврат ДеревоТипаПараметра;
	
КонецФункции

// Получает принадлежность объекта расширения.
//
// Возвращаемое значение:
//   Строка - строка с возможными значениями:
//     "Собственный"    - объект является собственным объектом расширения.
//     "Заимствованный" - объект является заимствованным объектом из конфигурации.
//     ""               - принадлежность объекта расширения получить не удалось.
//
Функция ПолучитьПринадлежностьОбъектаРасширения(ОбъектКонфигурации = Неопределено)
	
	Если НЕ ОбъектПроверкиЭтоРасширение Тогда
		Возврат "";
	КонецЕсли;
	
	ПринадлежностьОбъекта = ПолучитьСвойство("ПринадлежностьОбъекта", ОбъектКонфигурации);
	Если ПринадлежностьОбъекта = Неопределено Тогда
		ПринадлежностьОбъекта = "Собственный";
	КонецЕсли;
	
	Возврат ПринадлежностьОбъекта;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСФормами

// Возвращает дерево значений со сведениями о форме: свойства формы и подчиненных элементов.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   ДеревоЗначений - дерево формы с колонками:
//     Свойство        - Строка   - имя свойства формы.
//     Значение        - ЛюбойТип - значение свойства формы.
//     ЭтоЭлементФормы - Булево   - флаг, является ли это свойство элементом формы.
//
Функция ПолучитьОбъектФормы() Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Форма);
	
КонецФункции

// Возвращает структуру свойств формы (на верхнем уровне).
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Структура - структура свойств формы:
//     Ключ     - Строка   - имя свойства формы.
//     Значение - ЛюбойТип - значение свойства формы.
//
Функция ПолучитьСвойстваФормы()
	
	КлючЗначенияКэша = "Функция_ПолучитьСвойстваФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектФормы = ПолучитьОбъектФормы();
	Если ОбъектФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураСвойств = Новый Структура;
	Для Каждого СтрокаСвойстваФормы Из ОбъектФормы.Строки Цикл
		СтруктураСвойств.Вставить(СтрокаСвойстваФормы.Свойство, СтрокаСвойстваФормы.Значение);
	КонецЦикла;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает массив элементов формы.
//
// Возвращаемое значение:
//   Массив - массив строк дерева формы, являющихся элементами формы. Колонки:
//     Свойство        - Строка - имя элемента формы.
//     Значение        - Строка - тип элемента формы.
//     ЭтоЭлементФормы - Булево - Истина.
//
Функция ПолучитьЭлементыФормы()
	
	КлючЗначенияКэша = "Функция_ПолучитьЭлементыФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектФормы = ПолучитьОбъектФормы();
	
	Если ОбъектФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ОтборЭФ = Новый Структура("ЭтоЭлементФормы", Истина);
	РезультатВыполнения = ОбъектФормы.Строки.НайтиСтроки(ОтборЭФ, Истина);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, РезультатВыполнения);
	
	Возврат РезультатВыполнения;
	
КонецФункции

// Возвращает структуру со свойствами переданного элемента формы.
//
// Параметры:
//   ЭлементФормы - СтрокаДереваЗначений - строка элемента формы из дерева формы.
//
// Возвращаемое значение:
//   Структура - структура свойств элемента формы:
//     Ключ     - Строка   - имя свойства элемента формы.
//     Значение - ЛюбойТип - значение свойства элемента формы.
//
Функция ПолучитьСвойстваЭлементаФормы(ЭлементФормы)
	
	КлючЗначенияКэша = СтрШаблон("Функция_ПолучитьСвойстваЭлементаФормы_%1", ПолучитьПутьЭлементаФормы(ЭлементФормы));
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	СтруктураСвойств = Новый Структура;
	Для Каждого СвойствоЭФ Из ЭлементФормы.Строки Цикл
		Если НЕ СвойствоЭФ.ЭтоЭлементФормы Тогда
			СтруктураСвойств.Вставить(СвойствоЭФ.Свойство, СвойствоЭФ.Значение);
		КонецЕсли;
	КонецЦикла;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает полный путь к элементу формы с учетом всех родительских элементов формы.
//
// Параметры:
//   ЭлементФормы - СтрокаДереваЗначений - строка элемента формы из дерева формы.
//
// Возвращаемое значение:
//   Строка - полный путь к элементу формы с учетом родительских элементов.
//
// Примечание:
//   для управляемых форм родительские элементы "ПодчиненныеЭлементы" и "ЭлементыФормы" из пути вырезаются,
//   чтобы не засорять уточнение.
//
// Пример:
//   ЭлементФормы.Свойство = ОрганизацииНайти;
//   Возврат СвойствоПуть = КоманднаяПанель.ОрганизацииГруппа2.ОрганизацииНайти.
//
Функция ПолучитьПутьЭлементаФормы(ЭлементФормы)
	
	СвойствоПуть = ЭлементФормы.Свойство;
	ЭлементРодитель = ЭлементФормы.Родитель;
	Пока ЗначениеЗаполнено(ЭлементРодитель) Цикл
		Если (ЭлементРодитель.Свойство <> "ПодчиненныеЭлементы") ИЛИ (ЭлементРодитель.Значение <> "ЭлементыФормы") Тогда
			СвойствоПуть = ЭлементРодитель.Свойство + "." + СвойствоПуть;
		КонецЕсли;
		ЭлементРодитель = ЭлементРодитель.Родитель;
	КонецЦикла;
	
	Возврат СвойствоПуть;
	
КонецФункции

// Возвращает значение свойства формы "Состав команд".
//
// Возвращаемое значение:
//   СтрокаДереваЗначений - строка дерева формы со свойством "Состав команд".
//   Значение состава команд хранится в подстроках этой строки дерева значений.
//
Функция ПолучитьСвойствоФормыСоставКоманд()
	
	КлючЗначенияКэша = "Функция_ПолучитьСвойствоФормыСоставКоманд";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектФормы = ПолучитьОбъектФормы();
	Если ОбъектФормы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаСоставКоманд = ОбъектФормы.Строки.Найти("СоставКоманд", "Свойство");
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтрокаСоставКоманд);
	
	Возврат СтрокаСоставКоманд;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСРеквизитамиФорм

// Возвращает дерево значений со сведениями о реквизитах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево реквизитов формы с колонками:
//     Свойство - Строка   - имя реквизита или свойства реквизита формы.
//     Значение - ЛюбойТип - значение свойства реквизита формы.
//
Функция ПолучитьОбъектРеквизитовФормы(ОбъектКонфигурации = Неопределено)
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.РеквизитыФормы, ОбъектКонфигурации);
	
КонецФункции

// Возвращает дерево значений со сведениями о реквизитах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево реквизитов формы с колонками:
//     Свойство - Строка   - имя реквизита или свойства реквизита формы.
//     Значение - ЛюбойТип - значение свойства реквизита формы.
//
Функция ПолучитьРеквизитыФормы(ОбъектКонфигурации = Неопределено) Экспорт
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьРеквизитыФормы";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ОбъектРеквизиты = ПолучитьОбъектРеквизитовФормы(ОбъектКонфигурации);
	Если ОбъектРеквизиты = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектРеквизиты.Скопировать();
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает дерево значений со сведениями о реквизитах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево реквизитов формы с колонками:
//     Свойство - Строка   - имя реквизита или свойства реквизита формы.
//     Значение - ЛюбойТип - значение свойства реквизита формы.
//
Функция ПолучитьСодержаниеРеквизитовФормы()
	
	КлючЗначенияКэша = "Функция_ПолучитьСодержаниеРеквизитовФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектРеквизиты = ПолучитьОбъектРеквизитовФормы();
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ОбъектРеквизиты);
	
	Возврат ОбъектРеквизиты;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСПараметрамиФорм

// Возвращает дерево значений со сведениями о параметрах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево параметров формы с колонками:
//     Свойство - Строка   - имя параметра или свойства параметра формы.
//     Значение - ЛюбойТип - значение свойства параметра формы.
//
Функция ПолучитьОбъектПараметровФормы()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.ПараметрыФормы);
	
КонецФункции

// Возвращает дерево значений со сведениями о параметрах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево параметров формы с колонками:
//     Свойство - Строка   - имя параметра или свойства параметра формы.
//     Значение - ЛюбойТип - значение свойства параметра формы.
//
Функция ПолучитьПараметрыФормы() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьПараметрыФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектПараметры = ПолучитьОбъектПараметровФормы();
	Если ОбъектПараметры = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектПараметры.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСКомандамиФорм

// Возвращает дерево значений со сведениями о командах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево команд формы с колонками:
//     Свойство - Строка   - имя команды или свойства команды формы.
//     Значение - ЛюбойТип - значение свойства команды формы.
//
Функция ПолучитьОбъектКомандФормы()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.КомандыФормы);
	
КонецФункции

// Возвращает дерево значений со сведениями о командах формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево команд формы с колонками:
//     Свойство - Строка   - имя команды или свойства команды формы.
//     Значение - ЛюбойТип - значение свойства команды формы.
//
Функция ПолучитьКомандыФормы() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьКомандыФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектКоманды = ПолучитьОбъектКомандФормы();
	Если ОбъектКоманды = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектКоманды.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСУсловнымОформлениемФормы

// Возвращает дерево значений со сведениями об условном оформлении формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево условного оформления формы с колонками:
//     Свойство - Строка   - имя элемента или свойства элемента условного оформления формы.
//     Значение - ЛюбойТип - значение свойства элемента условного оформления формы.
//
Функция ПолучитьОбъектУсловногоОформления()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.УсловноеОформление);
	
КонецФункции

// Возвращает дерево значений со сведениями об условном оформлении формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево условного оформления формы с колонками:
//     Свойство - Строка   - имя элемента или свойства элемента условного оформления формы.
//     Значение - ЛюбойТип - значение свойства элемента условного оформления формы.
//
Функция ПолучитьУсловноеОформление() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьУсловноеОформление";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектУсловноеОформление = ПолучитьОбъектУсловногоОформления();
	Если ОбъектУсловноеОформление = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектУсловноеОформление.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСКоманднымИнтерфейсомФормы

// Возвращает дерево значений со сведениями о командном интерфейсе формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса формы с колонками:
//     Свойство - Строка   - имя элемента или свойства элемента командного интерфейса формы.
//     Значение - ЛюбойТип - значение свойства элемента командного интерфейса формы.
//
Функция ПолучитьОбъектКомандногоИнтерфейсаФормы()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.КомандныйИнтерфейсФормы);
	
КонецФункции

// Возвращает дерево значений со сведениями о командном интерфейсе формы.
// Если проверяемый объект не является формой, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса формы с колонками:
//     Свойство - Строка   - имя элемента или свойства элемента командного интерфейса формы.
//     Значение - ЛюбойТип - значение свойства элемента командного интерфейса формы.
//
Функция ПолучитьКомандныйИнтерфейсФормы() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьКомандныйИнтерфейсФормы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектКомандногоИнтерфейса = ПолучитьОбъектКомандногоИнтерфейсаФормы();
	Если ОбъектКомандногоИнтерфейса = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектКомандногоИнтерфейса.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСМакетами

// Возвращает дерево значений со сведениями о макете.
// Если проверяемый объект не является макетом, возвращается "Неопределено".
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево свойств макета с колонками:
//     Свойство - Строка   - имя свойства макета.
//     Значение - ЛюбойТип - значение свойства макета.
//
Функция ПолучитьОбъектМакета(ОбъектКонфигурации = Неопределено) Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Макет, ОбъектКонфигурации);
	
КонецФункции

// Возвращает структуру со сведениями о макете.
// Если проверяемый объект не является макетом, возвращается "Неопределено".
//
// Возвращаемое значение:
//   Неопределено, Структура - структура свойств макета:
//     Ключ     - Строка   - имя свойства макета.
//     Значение - ЛюбойТип - значение свойства макета.
//
Функция ПолучитьСвойстваМакета()
	
	КлючЗначенияКэша = "Функция_ПолучитьСвойстваМакета";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектМакета = ПолучитьОбъектМакета();
	
	Если ОбъектМакета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураСвойств = Новый Структура;
	Для Каждого СтрокаСвойстваМакета Из ОбъектМакета.Строки Цикл
		СтруктураСвойств.Вставить(СтрокаСвойстваМакета.Свойство, СтрокаСвойстваМакета.Значение);
	КонецЦикла;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает структуру свойств содержимого макета.
//
// Возвращаемое значение:
//   Структура - структура свойств содержимого макета:
//     Ключ     - Строка   - имя свойства содержимого макета.
//     Значение - ЛюбойТип - значение свойства содержимого макета.
//
Функция ПолучитьСодержимоеМакета()
	
	КлючЗначенияКэша = "Функция_ПолучитьСодержимоеМакета";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	СтруктураСвойств = Новый Структура;
	
	ОбъектМакета = ПолучитьОбъектМакета();
	Если ОбъектМакета = Неопределено Тогда
		Возврат СтруктураСвойств;
	КонецЕсли;
	
	СтрокаСодержимого = ОбъектМакета.Строки.Найти("СодержимоеМакета", "Свойство");
	Если СтрокаСодержимого = Неопределено Тогда
		Возврат СтруктураСвойств;
	КонецЕсли;
	
	Для Каждого ЭлементСодержимого Из СтрокаСодержимого.Строки Цикл
		СтруктураСвойств.Вставить(ЭлементСодержимого.Свойство, ЭлементСодержимого.Значение);
	КонецЦикла;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураСвойств);
	
	Возврат СтруктураСвойств;
	
КонецФункции

// Возвращает строку свойства дерева макета с подчиненными строками.
// Если проверяемый объект не является макетом, возвращается "Неопределено".
//
// Параметры:
//   ИмяСвойства        - Строка                                               - имя свойства макета.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Неопределено, СтрокаДереваЗначений - строка дерева макета запрашиваемого свойства с колонками:
//     Свойство - Строка   - имя запрашиваемого или подчиненного свойства макета.
//     Значение - ЛюбойТип - значение свойства макета.
//
Функция ПолучитьСоставноеСвойствоМакета(ИмяСвойства, ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьСоставноеСвойствоМакета_" + ИмяСвойства;
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ОбъектМакета = ПолучитьОбъектМакета(ОбъектКонфигурации);
	Если ОбъектМакета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтрокаСвойства = ОбъектМакета.Строки.Найти(ИмяСвойства, "Свойство");
	КэшЗначений.Вставить(КлючЗначенияКэша, СтрокаСвойства);
	
	Возврат СтрокаСвойства;
	
КонецФункции

// Получает таблицу всех выражений в настройках макета СКД (ед.ч. и мн.ч. выражений записано как в конфигураторе):
//   1) в полях наборов данных: выражение представления и выражения упорядочивания;
//   2) в вычисляемых полях: выражение, выражение представления и выражения упорядочивания;
//   3) в параметрах: выражение.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица выражений с колонками:
//     Выражение        - Строка - строковое значение выражения.
//     МестоОбнаружения - Строка - путь к месту выражения, например,
//                                 "НаборыДанных.НаборДанных1.Поля.Поле1.ВыражениеПредставления".
//
Функция ПолучитьТаблицуВыраженийМакетаСКД(ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьТаблицуВыраженийМакетаСКД";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеИзКэша <> Неопределено Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТаблицаВыражений = Новый ТаблицаЗначений;
	ТаблицаВыражений.Колонки.Добавить("Выражение");
	ТаблицаВыражений.Колонки.Добавить("МестоОбнаружения");
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаВыражений);
	
	СвойстваОбъекта = ПолучитьСвойства(ОбъектКонфигурации);
	Если НЕ СвойстваОбъекта.Свойство("ТипМакета") Тогда
		Возврат ТаблицаВыражений;
	КонецЕсли;
	
	Если СвойстваОбъекта.ТипМакета <> "СхемаКомпоновкиДанных" Тогда
		Возврат ТаблицаВыражений;
	КонецЕсли;
	
	ДеревоМакета = ПолучитьОбъектМакета(ОбъектКонфигурации);
	Если ДеревоМакета = Неопределено Тогда
		Возврат ТаблицаВыражений;
	КонецЕсли;
	
	ТекстВыражение = "Выражение";
	ТекстВыражениеПредставления = "ВыражениеПредставления";
	ТекстВыраженияУпорядочивания = "ВыраженияУпорядочивания";
	
	// Считываем выражения представления полей в наборах данных СКД.
	СтрокаНаборыДанных = ДеревоМакета.Строки.Найти("НаборыДанных", "Свойство");
	Если СтрокаНаборыДанных <> Неопределено Тогда
		
		МестоОбнаруженияШаблон = "НаборыДанных.%1.Поля.%2.%3";
		
		Для Каждого НаборДанных Из СтрокаНаборыДанных.Строки Цикл
			
			СтрокаПоля = НаборДанных.Строки.Найти("Поля", "Свойство");
			Если СтрокаПоля = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяНабораДанных = НаборДанных.Свойство;
			
			Для Каждого Поле Из СтрокаПоля.Строки Цикл
				
				ИмяПоля = Поле.Свойство;
				
				// Получим выражение представления каждого поля набора данных.
				СтрокаВыражениеПредставления = Поле.Строки.Найти(ТекстВыражениеПредставления, "Свойство");
				Если СтрокаВыражениеПредставления <> Неопределено Тогда
					МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, ИмяНабораДанных, ИмяПоля, ТекстВыражениеПредставления);
					
					НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
					НоваяСтрокаВыражения.Выражение = СтрокаВыражениеПредставления.Значение;
					НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения;
				КонецЕсли;
				
				// Получим выражения упорядочивания каждого поля набора данных.
				СтрокаВыраженияУпорядочивания = Поле.Строки.Найти(ТекстВыраженияУпорядочивания, "Свойство");
				Если СтрокаВыраженияУпорядочивания <> Неопределено Тогда
					
					МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, ИмяНабораДанных, ИмяПоля, ТекстВыраженияУпорядочивания);
					
					НомерВыражения = 0;
					
					Для Каждого ВыражениеУпорядочивания Из СтрокаВыраженияУпорядочивания.Строки Цикл
						НомерВыражения = НомерВыражения + 1;
						
						НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
						НоваяСтрокаВыражения.Выражение = ВыражениеУпорядочивания.Значение;
						НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения + ".Выражение" + НомерВыражения;
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Считываем выражения в вычисляемых полях СКД.
	СтрокаВычисляемыеПоля = ДеревоМакета.Строки.Найти("ВычисляемыеПоля", "Свойство");
	Если СтрокаВычисляемыеПоля <> Неопределено Тогда
		
		МестоОбнаруженияШаблон = "ВычисляемыеПоля.%1.%2";
		
		Для Каждого ВычисляемоеПоле Из СтрокаВычисляемыеПоля.Строки Цикл
			
			ИмяВычисляемогоПоля = ВычисляемоеПоле.Свойство;
			
			// Получим выражение каждого вычисляемого поля.
			СтрокаВыражение = ВычисляемоеПоле.Строки.Найти(ТекстВыражение, "Свойство");
			Если СтрокаВыражение <> Неопределено Тогда
				МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, ИмяВычисляемогоПоля, ТекстВыражение);
				
				НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
				НоваяСтрокаВыражения.Выражение = СтрокаВыражение.Значение;
				НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения;
			КонецЕсли;
			
			// Получим выражение представления каждого вычисляемого поля.
			СтрокаВыражениеПредставления = ВычисляемоеПоле.Строки.Найти(ТекстВыражениеПредставления, "Свойство");
			Если СтрокаВыражениеПредставления <> Неопределено Тогда
				МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, ИмяВычисляемогоПоля, ТекстВыражениеПредставления);
				
				НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
				НоваяСтрокаВыражения.Выражение = СтрокаВыражениеПредставления.Значение;
				НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения;
			КонецЕсли;
			
			// Получим выражения упорядочивания каждого вычисляемого поля.
			СтрокаВыраженияУпорядочивания = ВычисляемоеПоле.Строки.Найти(ТекстВыраженияУпорядочивания, "Свойство");
			Если СтрокаВыраженияУпорядочивания <> Неопределено Тогда
				МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, ИмяВычисляемогоПоля, ТекстВыраженияУпорядочивания);
				
				НомерВыражения = 0;
				
				Для Каждого ВыражениеУпорядочивания Из СтрокаВыраженияУпорядочивания.Строки Цикл
					НомерВыражения = НомерВыражения + 1;
					
					НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
					НоваяСтрокаВыражения.Выражение = ВыражениеУпорядочивания.Значение;
					НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения + ".Выражение" + НомерВыражения;
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Считываем выражения представления полей в параметрах СКД.
	СтрокаПараметры = ДеревоМакета.Строки.Найти("Параметры", "Свойство");
	Если СтрокаПараметры <> Неопределено Тогда
		
		МестоОбнаруженияШаблон = "Параметры.%1.%2";
		
		Для Каждого Параметр Из СтрокаПараметры.Строки Цикл
			
			// Получим выражение каждого параметра.
			СтрокаВыражение = Параметр.Строки.Найти(ТекстВыражение, "Свойство");
			Если СтрокаВыражение <> Неопределено Тогда
				МестоОбнаружения = СтрШаблон(МестоОбнаруженияШаблон, Параметр.Свойство, ТекстВыражение);
				
				НоваяСтрокаВыражения = ТаблицаВыражений.Добавить();
				НоваяСтрокаВыражения.Выражение = СтрокаВыражение.Значение;
				НоваяСтрокаВыражения.МестоОбнаружения = МестоОбнаружения;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаВыражений);
	
	Возврат ТаблицаВыражений;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСМодулями

// Возвращает состав модулей объекта конфигурации.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Массив - массив видов модулей объекта. Элементы массива:
//     ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля объекта.
//
Функция ПолучитьСоставМодулей(ОбъектКонфигурации = Неопределено) Экспорт
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьСоставМодулей";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ЗапросПоМодулям = Новый Запрос;
	ЗапросПоМодулям.Текст = "
	|ВЫБРАТЬ
	|	ЗначенияСоставныхСвойствОбъектов.Имя КАК Имя
	|ИЗ
	|	РегистрСведений.ЗначенияСоставныхСвойствОбъектов КАК ЗначенияСоставныхСвойствОбъектов
	|ГДЕ
	|	ЗначенияСоставныхСвойствОбъектов.Объект = &Объект";
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	ЗапросПоМодулям.УстановитьПараметр("Объект", ОбъектСсылка);
	ВыборкаСоставныхСвойств = ЗапросПоМодулям.Выполнить().Выбрать();
	
	СоставМодулей = Новый Массив;
	
	Пока ВыборкаСоставныхСвойств.Следующий() Цикл
		Если ЭтоМодуль[ВыборкаСоставныхСвойств.Имя] = Истина Тогда
			СоставМодулей.Добавить(ВыборкаСоставныхСвойств.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, СоставМодулей);
	КонецЕсли;
	
	Возврат СоставМодулей;
	
КонецФункции

// Возвращает текст переданного типа модуля объекта конфигурации.
//
// Параметры:
//   ИмяМодуля          - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов  - тип модуля объекта.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается текст модуля текущего проверяемого объекта.
//   УдалитьКомментарииСНачалаСтроки - Булево - флаг удаления комментария с начала каждой строки модуля.
//   УдалитьКомментарииВКонцеСтроки  - Булево - флаг удаления комментария в конце каждой строки модуля
//                                              (комментарий в строке после кода).
//
// Возвращаемое значение:
//   Строка - многострочный текст модуля объекта.
//
Функция ПолучитьТекстМодуля(ИмяМодуля, ОбъектКонфигурации = Неопределено, УдалитьКомментарииСНачалаСтроки = Ложь,
	УдалитьКомментарииВКонцеСтроки = Ложь)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = СтрШаблон("Функция_ПолучитьТекстМодуля_%1_%2_%3", ИмяМодуля,
			УдалитьКомментарииСНачалаСтроки, УдалитьКомментарииВКонцеСтроки);
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТекстМодуля = ПолучитьСоставноеСвойство(ИмяМодуля, ОбъектКонфигурации);
	Если ТекстМодуля = Неопределено Тогда
		ТекстМодуля = "";
	Иначе
		Если УдалитьКомментарииСНачалаСтроки ИЛИ УдалитьКомментарииВКонцеСтроки Тогда
			ТекстМодуля = ПолучитьТекстМодуляБезКомментариев(ТекстМодуля, УдалитьКомментарииСНачалаСтроки,
				УдалитьКомментарииВКонцеСтроки);
		КонецЕсли;
	КонецЕсли;
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ТекстМодуля);
	КонецЕсли;
	
	Возврат ТекстМодуля;
	
КонецФункции

// Возвращает таблицу блоков переданного типа модуля объекта конфигурации.
// Если проверяемый объект не имеет указанного типа модуля, то возвращается "Неопределено".
//
// Параметры:
//   ИмяМодуля          - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов  - тип модуля объекта.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается текст модуля текущего проверяемого объекта.
//
// Возвращаемое значение:
//   Неопределено, ТаблицаЗначений - таблица блоков модуля объекта с колонками:
//     Блок            - ПеречислениеСсылка.ТипыБлоковМодулей - тип блока модуля.
//     НачальнаяСтрока - Число                                - номер строки начала блока.
//     КонечнаяСтрока  - Число                                - номер строки окончания блока.
//     ЕстьКомментарий - Булево                               - флаг наличия комментария в блоке.
//     ЕстьЭкспорт     - Булево                               - флаг наличия экспорта в блоке,
//                                                              актуально для заголовков процедур и функций.
//     Текст           - Строка                               - многострочный текст блока.
//
Функция ПолучитьСтруктуруМодуля(ИмяМодуля, ОбъектКонфигурации = Неопределено) Экспорт
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьСтруктуруМодуля_" + ИмяМодуля;
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша.Скопировать();
		КонецЕсли;
	КонецЕсли;
	
	ИмяСтруктуры = ИмяСтруктурыПоМодулю[ИмяМодуля];
	Если ИмяСтруктуры = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураМодуля = ПолучитьСоставноеСвойство(ИмяСтруктуры, ОбъектКонфигурации);
	Если СтруктураМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтруктураМодуля.Колонки.Найти("Текст") = Неопределено Тогда
		СтруктураМодуля.Колонки.Добавить("Текст");
	КонецЕсли;
	
	ТекстМодуля = ПолучитьТекстМодуля(ИмяМодуля, ОбъектКонфигурации);
	Если ТекстМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	РазборТекста = Новый ТекстовыйДокумент;
	РазборТекста.УстановитьТекст(ТекстМодуля);
	
	// Заполняем структуру модуля текстом.
	Для Каждого СтрокаБлока Из СтруктураМодуля Цикл
		
		ТекстБлока = Новый ТекстовыйДокумент;
		
		Для Счетчик = СтрокаБлока.НачальнаяСтрока По СтрокаБлока.КонечнаяСтрока Цикл
			ТекстБлока.ДобавитьСтроку(РазборТекста.ПолучитьСтроку(Счетчик));
		КонецЦикла;
		
		СтрокаБлока.Текст = ТекстБлока.ПолучитьТекст();
		
	КонецЦикла;
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, СтруктураМодуля);
	КонецЕсли;
	
	Возврат СтруктураМодуля.Скопировать();
	
КонецФункции

// Получает текст процедуры или функции по наименованию.
// Если структура модуля неопределена, или указанного метода не существует в модуле, то возвращается "Неопределено".
//
// Параметры:
//   СтруктураМодуля       - ТаблицаЗначений - результат функции "ПолучитьСтруктуруМодуля".
//   ИмяПроцедурыФункции   - Строка          - имя искомой процедуры или функции.
//   ИскатьТолькоПроцедуру - Булево          - флаг для поиска только процедуры.
//   ИскатьТолькоФункцию   - Булево          - флаг для поиска только функции.
//
// Возвращаемое значение:
//   Неопределено, Строка - многострочный текст запрашиваемой процедуры или функции.
//
Функция ПолучитьТекстПроцедурыФункции(СтруктураМодуля, ИмяПроцедурыФункции, ИскатьТолькоПроцедуру = Ложь,
	ИскатьТолькоФункцию = Ложь)
	
	// При неверной структуре модуля возвращаем "Неопределено".
	Если СтруктураМодуля = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	КлючБлока = СокрЛП(ВРег(ИмяПроцедурыФункции)) + "(";
	
	ВсегоБлоков = СтруктураМодуля.Количество() - 1;
	
	ТекстПроцедурыФункции = Неопределено;
	
	// Проверяем каждый элемент структуры.
	Для Счетчик = 0 По ВсегоБлоков Цикл
		
		Если ИскатьТолькоПроцедуру Тогда
			
			НайденЗаголовок = ((СтруктураМодуля[Счетчик].Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры)
				И (СтрНайти(ВРег(СтруктураМодуля[Счетчик].Текст), КлючБлока) > 0));
			
		ИначеЕсли ИскатьТолькоФункцию Тогда
			
			НайденЗаголовок = ((СтруктураМодуля[Счетчик].Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции)
				И (СтрНайти(ВРег(СтруктураМодуля[Счетчик].Текст), КлючБлока) > 0));
			
		Иначе
			
			НайденЗаголовок = (((СтруктураМодуля[Счетчик].Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры)
				ИЛИ (СтруктураМодуля[Счетчик].Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции))
				И (СтрНайти(ВРег(СтруктураМодуля[Счетчик].Текст), КлючБлока) > 0));
			
		КонецЕсли;
		
		Если НайденЗаголовок Тогда
			
			ТекстПроцедурыФункции = "";
			Если СтруктураМодуля[Счетчик].Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры Тогда
				БлокОкончания = Перечисления.ТипыБлоковМодулей.ОкончаниеПроцедуры;
			Иначе
				БлокОкончания = Перечисления.ТипыБлоковМодулей.ОкончаниеФункции;
			КонецЕсли;
			
			СчетчикСодержания = 1;
			
			Пока (Счетчик + СчетчикСодержания < ВсегоБлоков)
				И (СтруктураМодуля[Счетчик + СчетчикСодержания].Блок <> БлокОкончания) Цикл
				
				ТекстПроцедурыФункции = ТекстПроцедурыФункции + СтруктураМодуля[Счетчик + СчетчикСодержания].Текст;
				СчетчикСодержания = СчетчикСодержания + 1;
				
			КонецЦикла;
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекстПроцедурыФункции;
	
КонецФункции

// Возвращает таблицу методов модуля.
//
// Параметры:
//   ИмяМодуля          - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов  - тип модуля объекта.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается текст модуля текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица методов модуля с колонками:
//     ТипМетода           - Строка - тип метода.
//     ИмяМетода           - Строка - имя метода.
//     ИмяМетодаВРег       - Строка - имя метода в верхнем регистре.
//     ОписаниеМетода      - Строка - текст объявления метода.
//     ТекстМетода         - Строка - текст объявления метода с телом метода.
//     ТелоМетода          - Строка - текст с телом метода.
//     НомерСтрокиНачало   - Число  - номер строки начала метода.
//     НомерСтрокиКонец    - Число  - номер строки конца метода.
//     ЕстьЭкспорт         - Булево - флаг наличия экспорта у метода.
//     МассивПараметров    - Массив - массив параметров метода. Элементы массива:
//       Строка - имя параметра метода, может содержать текст "Знач " и значение параметра по умолчанию.
//     ДирективаКомпиляции - Строка - директива компиляции метода.
//
Функция ПолучитьТаблицуМетодовМодуля(ИмяМодуля, ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьТаблицуМетодовМодуля_" + ИмяМодуля;
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша.Скопировать();
		КонецЕсли;
	КонецЕсли;
	
	// Например, Функция ЭтоКод(Знач СтрокаМодуля) Экспорт
	ТаблицаМетодов = Новый ТаблицаЗначений;
	ТаблицаМетодов.Колонки.Добавить("ТипМетода");			// = "Функция"
	ТаблицаМетодов.Колонки.Добавить("ИмяМетода");			// = "ЭтоКод"
	ТаблицаМетодов.Колонки.Добавить("ИмяМетодаВРег");		// = "ЭТОКОД"
	ТаблицаМетодов.Колонки.Добавить("ОписаниеМетода");		// = "Функция ЭтоКод(Знач СтрокаМодуля) Экспорт"
	ТаблицаМетодов.Колонки.Добавить("ТекстМетода");			// = "Функция ЭтоКод(Знач СтрокаМодуля) Экспорт ... КонецФункции"
	ТаблицаМетодов.Колонки.Добавить("ТелоМетода");			// = " Если ПустаяСтрока(СтрокаМодуля) Тогда ... Возврат ВесКода >= 0; "
	ТаблицаМетодов.Колонки.Добавить("НомерСтрокиНачало");	// = 3769
	ТаблицаМетодов.Колонки.Добавить("НомерСтрокиКонец");	// = 4047
	ТаблицаМетодов.Колонки.Добавить("ЕстьЭкспорт");			// = Истина
	ТаблицаМетодов.Колонки.Добавить("МассивПараметров");	// = Массив; Массив[0] = "Знач СтрокаМодуля"
	ТаблицаМетодов.Колонки.Добавить("ДирективаКомпиляции");	// = "&НаСервере" - пример для метода из управляемой формы
	
	ТаблицаБлоковМодуля = ПолучитьСтруктуруМодуля(ИмяМодуля, ОбъектКонфигурации);
	Если ТаблицаБлоковМодуля = Неопределено Тогда
		Возврат ТаблицаМетодов;
	КонецЕсли;
	
	СтрДлинаПроцедура = СтрДлина("Процедура") + 1;
	СтрДлинаФункция = СтрДлина("Функция") + 1;
	
	МетодНайден = Ложь;
	ТекстМетода = "";
	ТелоМетода = "";
	СтрокаМетода = Неопределено;
	
	Для Каждого БлокМодуля Из ТаблицаБлоковМодуля Цикл
		
		ТекстБлокаМодуля = БлокМодуля.Текст;
		
		Если МетодНайден Тогда
			ТекстМетода = ТекстМетода + ТекстБлокаМодуля;
		КонецЕсли;
		
		Если БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры
		 ИЛИ БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции Тогда
			
			ТекстМетода = ТекстБлокаМодуля;
			
			Если БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры Тогда
				ТипМетода = "Процедура";
				ИмяМетода = Сред(СокрЛ(ТекстМетода), СтрДлинаПроцедура);
			ИначеЕсли БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции Тогда
				ТипМетода = "Функция";
				ИмяМетода = Сред(СокрЛ(ТекстМетода), СтрДлинаФункция);
			Иначе
				ТипМетода = Строка(БлокМодуля.Блок);
				ИмяМетода = "";
			КонецЕсли;
			
			ПозицияСкобки = СтрНайти(ИмяМетода, "(");
			Если ПозицияСкобки = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяМетода = Лев(ИмяМетода, ПозицияСкобки - 1);
			
			ТекстМетодаБезКомментариев = ТекстМетода;
			Если БлокМодуля.ЕстьКомментарий Тогда
				ТекстМетодаБезКомментариев = ПолучитьТекстМодуляБезКомментариев(ТекстМетода, Истина, Истина);
			КонецЕсли;
			
			СтруктураМетода = ПолучитьСтруктуруПараметровМетода(ТекстМетодаБезКомментариев, ИмяМетода);
			Если НЕ СтруктураМетода.МетодНайден Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяМетода = СокрЛП(ИмяМетода);
			
			СтрокаМетода = ТаблицаМетодов.Добавить();
			СтрокаМетода.ТипМетода = ТипМетода;
			СтрокаМетода.ИмяМетода = ИмяМетода;
			СтрокаМетода.ИмяМетодаВРег = ВРег(ИмяМетода);
			СтрокаМетода.ОписаниеМетода = СокрЛП(ТекстМетода);
			СтрокаМетода.НомерСтрокиНачало = БлокМодуля.НачальнаяСтрока;
			СтрокаМетода.ЕстьЭкспорт = БлокМодуля.ЕстьЭкспорт;
			СтрокаМетода.МассивПараметров = СтруктураМетода.МассивПараметров;
			СтрокаМетода.ДирективаКомпиляции = БлокМодуля.ДирективаКомпиляции;
			
			ТелоМетода = "";
			
			МетодНайден = Истина;
			
		ИначеЕсли БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ОкончаниеПроцедуры
			  ИЛИ БлокМодуля.Блок = Перечисления.ТипыБлоковМодулей.ОкончаниеФункции Тогда
			
			МетодНайден = Ложь;
			
			Если СтрокаМетода = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокаМетода.ТекстМетода = ТекстМетода;
			СтрокаМетода.ТелоМетода = ТелоМетода;
			СтрокаМетода.НомерСтрокиКонец = БлокМодуля.КонечнаяСтрока;
			
			ТелоМетода = "";
			
		Иначе
			
			Если МетодНайден Тогда
				ТелоМетода = ТелоМетода + ТекстБлокаМодуля;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаМетодов.Индексы.Добавить("ИмяМетодаВРег");
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаМетодов);
	КонецЕсли;
	
	Возврат ТаблицаМетодов;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСТекстамиМодулей

// Возвращает текст переданного типа модуля объекта конфигурации, строки комментариев заменяются пустыми строками.
//
// Параметры:
//   ТекстМодуля                     - Строка - текст модуля.
//   УдалитьКомментарииСНачалаСтроки - Булево - флаг удаления комментария с начала каждой строки модуля.
//   УдалитьКомментарииВКонцеСтроки  - Булево - флаг удаления комментария в конце каждой строки модуля
//                                              (комментарий в строке после кода).
//
// Возвращаемое значение:
//   Строка - многострочный текст модуля без комментариев.
//
Функция ПолучитьТекстМодуляБезКомментариев(Знач ТекстМодуля, УдалитьКомментарииСНачалаСтроки = Истина,
	УдалитьКомментарииВКонцеСтроки = Ложь)
	
	Если УдалитьКомментарииСНачалаСтроки Тогда
		ШаблонУдаленияКомментариев = "^[ \t]*//.*";
		ТекстМодуля = РегулярныеВыраженияТекстЗаменить(ТекстМодуля, "", ШаблонУдаленияКомментариев,, Истина, Истина);
	КонецЕсли;
	
	Если УдалитьКомментарииВКонцеСтроки Тогда
		
		Если СтрНайти(ТекстМодуля, "//") = 0 Тогда
			Возврат ТекстМодуля;
		КонецЕсли;
		
		РазборТекста = Новый ТекстовыйДокумент;
		РазборТекста.УстановитьТекст(ТекстМодуля);
		
		КоличествоСтрок = РазборТекста.КоличествоСтрок();
		
		Для Счетчик = 1 По КоличествоСтрок Цикл
			СтрокаМодуля = РазборТекста.ПолучитьСтроку(Счетчик);
			СтрокаМодуля = УдалитьКомментарийИзСтроки(СтрокаМодуля);
			РазборТекста.ЗаменитьСтроку(Счетчик, СтрокаМодуля);
		КонецЦикла;
		
		ТекстМодуля = РазборТекста.ПолучитьТекст();
		
	КонецЕсли;
	
	Возврат ТекстМодуля;
	
КонецФункции

// Возвращает текст модуля для проверки орфографии.
// Все незначимые символы (".", ";", "," и т.д.) заменены на пробелы. Длинные пробелы заменены на одинарные.
//
// Параметры:
//   ТекстМодуля - Строка - текст модуля.
//
// Возвращаемое значение:
//   Строка - многострочный текст модуля без специальных (незначимых) символов.
//
Функция ПолучитьТекстМодуляДляПроверкиОрфографии(Знач ТекстМодуля)
	
	// Очистим текст от посторонних символов, останутся только буквы и пробелы.
	ТекстМодуля = РегулярныеВыраженияТекстЗаменить(ТекстМодуля, " ", ШаблонЗаменыДляПроверкиОрфографии, Истина, Истина);
	// Все двойные, тройные и бОльшие пробелы заменим одинарными.
	ТекстМодуля = РегулярныеВыраженияТекстЗаменить(ТекстМодуля, " ", " +", Истина, Истина);
	
	Возврат ТекстМодуля;
	
КонецФункции

// Возвращает комментарий из переданной строки модуля.
//
// Параметры:
//   СтрокаМодуля          - Строка - строка модуля.
//   БезСимволаКомментария - Булево - флаг отсутствия знаков комментария в возвращаемом значении.
//
// Возвращаемое значение:
//   Строка - комментарий из переданной строки модуля.
//
Функция ПолучитьКомментарийИзСтроки(Знач СтрокаМодуля, БезСимволаКомментария = Истина)
	
	// Например, URLСтрока = "http://downloads.v8.1c.ru/tmplts/ITS/KLADR/"; - не проверяем на комментарий.
	СтрокаМодуля = СтрЗаменить(СтрокаМодуля, "://", "<<ВНЕШНЕЕСОЕДИНЕНИЕ>>");
	СтрокаКомментария = "";
	ПозицияКомментария = СтрНайти(СтрокаМодуля, "//");
	
	// Есть комментарий.
	Если ПозицияКомментария = 0 Тогда
		Возврат "";
	КонецЕсли;
		
	ПозицияКавычек = СтрНайти(СтрокаМодуля, """");
	// Проверяем есть ли вначале строки символ "|".
	ПервыйСимвол = Сред(СокрЛП(СтрокаМодуля), 1, 1);
	
	// Нет кавычек, оставляем весь комментарий.
	// Кавычки после комментария, оставляем весь комментарий.
	Если (ПозицияКавычек = 0 ИЛИ ПозицияКавычек > ПозицияКомментария) И ПервыйСимвол <> "|" Тогда
		
		Если БезСимволаКомментария Тогда
			СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария + 2);
		Иначе
			СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария);
		КонецЕсли;
		
	ИначеЕсли ПервыйСимвол = "|" Тогда
		
		КоличествоКавычекДоКомментария = СтрЧислоВхождений(Лев(СтрокаМодуля, ПозицияКомментария), """");
		
		// Строка открывается и закрывается до комментария, оставляем весь комментарий.
		Если КоличествоКавычекДоКомментария % 2 <> 0 Тогда
			Если БезСимволаКомментария Тогда
				СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария + 2);
			Иначе
				СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария);
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		
		КоличествоКавычекДоКомментария = СтрЧислоВхождений(Лев(СтрокаМодуля, ПозицияКомментария), """");
		
		// Строка открывается и закрывается до комментария, оставляем весь комментарий.
		Если КоличествоКавычекДоКомментария % 2 = 0 Тогда
			Если БезСимволаКомментария Тогда
				СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария + 2);
			Иначе
				СтрокаКомментария = Сред(СтрокаМодуля, ПозицияКомментария);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	// Цикл по символам начиная с ПозицияКомментария, искать первый символ <> "/".
	Если СтрНачинаетсяС(СтрокаКомментария, "/") И СтрДлина(СтрокаКомментария) <> 1 И БезСимволаКомментария Тогда
		Для НомерСимвола = 2 По СтрДлина(СтрокаКомментария) Цикл
			Если Сред(СтрокаКомментария, НомерСимвола, 1) <> "/" ИЛИ НомерСимвола = СтрДлина(СтрокаКомментария) Тогда
				СтрокаКомментария = Сред(СтрокаКомментария, НомерСимвола + 1);
				Прервать;
			КонецЕсли
		КонецЦикла;
	КонецЕсли;
	
	СтрокаМодуля = СтрЗаменить(СтрокаКомментария, "<<ВНЕШНЕЕСОЕДИНЕНИЕ>>", "://");
	
	Возврат СтрокаМодуля;
	
КонецФункции

// Возвращает строку модуля без комментария.
//
// Параметры:
//   СтрокаМодуля          - Строка - строка модуля.
//
// Возвращаемое значение:
//   Строка - строка модуля без комментария.
//
Функция УдалитьКомментарийИзСтроки(СтрокаМодуля)
	
	Если ПустаяСтрока(СтрокаМодуля) Тогда
		Возврат СтрокаМодуля;
	КонецЕсли;
	
	ПозицияКомментария = СтрНайти(СтрокаМодуля, "//");
	Если ПозицияКомментария = 0 Тогда
		Возврат СтрокаМодуля;
	КонецЕсли;
	
	// Например, URLСтрока = "http://downloads.v8.1c.ru/tmplts/ITS/KLADR/"; - не проверяем на комментарий.
	СтрокаМодуля = СтрЗаменить(СтрокаМодуля, "://", "<<ВНЕШНЕЕСОЕДИНЕНИЕ>>");
	ПозицияКомментария = СтрНайти(СтрокаМодуля, "//");
	
	// Есть комментарий.
	Если ПозицияКомментария > 0 Тогда
		ПозицияКавычек = СтрНайти(СтрокаМодуля, """");
		СтрокаОткрыта = СтрНачинаетсяС(СокрЛ(СтрокаМодуля), "|");
		
		// Нет кавычек, удаляем комментарий.
		Если ПозицияКавычек = 0 Тогда
			СтрокаМодуля = Лев(СтрокаМодуля, ПозицияКомментария - 1);
			
		// Знак комментария в открытой строке, например:
		// |//////////////////";
		ИначеЕсли СтрокаОткрыта И ПозицияКавычек > 0 Тогда
			ПозицияКомментария = СтрНайти(СтрокаМодуля, "//",, ПозицияКавычек);
			Если ПозицияКомментария > 0 Тогда
				СтрокаМодуля = Лев(СтрокаМодуля, ПозицияКомментария - 1);
			КонецЕсли;
			
		// Строка не открыта, кавычки после комментария, удаляем комментарий.
		ИначеЕсли ПозицияКавычек > ПозицияКомментария Тогда
			СтрокаМодуля = Лев(СтрокаМодуля, ПозицияКомментария - 1);
			
		Иначе
			КоличествоКавычекДоКомментария = СтрЧислоВхождений(Лев(СтрокаМодуля, ПозицияКомментария), """");
			// Строка открывается и закрывается до комментария, удаляем комментарий.
			Если КоличествоКавычекДоКомментария % 2 = 0 Тогда
				СтрокаМодуля = Лев(СтрокаМодуля, ПозицияКомментария - 1);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрЗаменить(СтрокаМодуля, "<<ВНЕШНЕЕСОЕДИНЕНИЕ>>", "://");;
	
КонецФункции

// Возвращает флаг, определяющий, является ли переданная строка закомментированным кодом.
// На вход подается строка модуля без знаков комментария.
//
// Параметры:
//   СтрокаМодуля - Строка - строка модуля без знаков комментария.
//
// Возвращаемое значение:
//   Булево - флаг определения закомментированного кода:
//     Истина - переданная строка является закомментированным кодом,
//     Ложь   - переданная строка является комментарием.
//
Функция ЭтоКод(Знач СтрокаМодуля)
	
	Если ПустаяСтрока(СтрокаМодуля) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрНачинаетсяС(СокрЛ(СтрокаМодуля), "|") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СтрНайти(ВРег(СтрокаМодуля), "НСТР(") > 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	МассивСимволовКода = Новый Массив;
	МассивСимволовКода.Добавить("<");
	МассивСимволовКода.Добавить(">");
	МассивСимволовКода.Добавить("=");
	
	МассивФразКомментария = Новый Массив;
	МассивФразКомментария.Добавить("ПРИМЕР:");
	МассивФразКомментария.Добавить("НАПРИМЕР,");
	МассивФразКомментария.Добавить("СМ.");
	МассивФразКомментария.Добавить("КАВЫЧКИ.");
	МассивФразКомментария.Добавить(": КАВЫЧКИ");
	МассивФразКомментария.Добавить(".<");
	МассивФразКомментария.Добавить(">.");
	МассивФразКомментария.Добавить("->");
	МассивФразКомментария.Добавить("**");
	МассивФразКомментария.Добавить("{HTTP");
	
	РазделителиСлов = ПолучитьРазделителиСлов();
	СтрокаРазделителейОкончанияСлов = ",.;*/%+-><)(";
	
	МассивИсключений = Новый Массив;
	МассивИсключений.Добавить("<xs:");
	МассивИсключений.Добавить("</xs:");
	МассивИсключений.Добавить("<?xml");
	
	ВесКода = 0;
	
	Если СтрНачинаетсяС(СтрокаМодуля, " ") Тогда
		ВесКода = ВесКода - 3;
	ИначеЕсли СтрНачинаетсяС(СтрокаМодуля, Символы.Таб) Тогда
		ВесКода = ВесКода + 3;
	ИначеЕсли СтрНачинаетсяС(СокрЛП(СтрокаМодуля), "-") Тогда
		ВесКода = ВесКода - 3;
	Иначе
		ВесКода = ВесКода + 1;
	КонецЕсли;
	
	СтрокиЗапроса = ПолучитьСтрокиТекстаЗапроса();
	Для Каждого СтрокаЗапроса Из СтрокиЗапроса Цикл
		ПозицияСимволаЗапроса = СтрНайти(СтрокаМодуля, СтрокаЗапроса);
		Если ПозицияСимволаЗапроса = 0 Тогда
			Продолжить;
		ИначеЕсли ПозицияСимволаЗапроса = 1 Тогда
			ВесКода = ВесКода + 5;
		Иначе
			ВесКода = ВесКода + 1;
		КонецЕсли;
	КонецЦикла;
	
	Если СтрЧислоВхождений(СтрокаМодуля, """") % 2 <> 0 Тогда
		ВесКода = ВесКода + 3;
	КонецЕсли;
	
	Строка = СтрЗаменить(СтрокаМодуля, Символы.Таб, " ");
	
	// Удаляем все, что находится в кавычках.
	ПозицияКавычки = СтрНайти(Строка, """");
	Пока ПозицияКавычки > 0 Цикл
		ПозицияЗакрывающейКавычки = СтрНайти(Сред(Строка, ПозицияКавычки + 1), """") + ПозицияКавычки;
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			Прервать;
		КонецЕсли;
		Строка = Лев(Строка, ПозицияКавычки - 1) + "Кавычки" + Сред(Строка, ПозицияЗакрывающейКавычки + 1);
		ПозицияКавычки = СтрНайти(Строка, """");
	КонецЦикла;
	
	МассивСлов = СтрРазделить(Строка, " ", Ложь);
	МассивСловВВерхнем = СтрРазделить(ВРег(Строка), " ", Ложь);
	
	Если МассивСловВВерхнем.Количество() > 1 Тогда
		Если МассивСловВВерхнем[0] = "ДЛЯ" Тогда
			Возврат МассивСловВВерхнем.Найти("ЦИКЛ") <> Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого СимволКода Из МассивИсключений Цикл
		ПозицияИсключения = СтрНайти(ВРег(Строка), ВРег(СимволКода));
		Если ПозицияИсключения > 0 И ПустаяСтрока(Сред(Строка, 1, ПозицияИсключения - 1)) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Для Счетчик = 0 По МассивСлов.Количество() - 2 Цикл
		
		Если РазделителиСлов[МассивСловВВерхнем[Счетчик]] = Неопределено
			И РазделителиСлов[МассивСловВВерхнем[Счетчик + 1]] = Неопределено
			И СтрНайти(СтрокаРазделителейОкончанияСлов, Прав(МассивСловВВерхнем[Счетчик], 1)) = 0 Тогда
			
			ВесКода = ВесКода - 3;
		КонецЕсли;
		
	КонецЦикла;
	
	СтрокаВРег = ВРег(СокрЛП(Строка));
	ТаблицаСлужебныхСлов = ПолучитьТаблицуСлужебныхСлов();
	Для Каждого СтрокаСлужебноеСлово Из ТаблицаСлужебныхСлов Цикл
		СлужебноеСлово = СтрокаСлужебноеСлово.Имя;
		Если СтрокаСлужебноеСлово.Положение = "Начало" Тогда
			Если СтрНачинаетсяС(СтрокаВРег, СлужебноеСлово) Тогда
				ВесКода = ВесКода + 5;
			КонецЕсли;
		ИначеЕсли СтрокаСлужебноеСлово.Положение = "Конец" Тогда
			Если СтрЗаканчиваетсяНа(СтрокаВРег, СлужебноеСлово) Тогда
				ВесКода = ВесКода + 5;
			КонецЕсли;
		ИначеЕсли СтрокаСлужебноеСлово.Положение = "Строка" Тогда
			Если СтрокаВРег = СлужебноеСлово Тогда
				ВесКода = ВесКода + 5;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСлов.Количество() = 1 И ВесКода < 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ВсеСловаСЗаглавнойБуквы = Истина;
	Для Каждого Слово Из МассивСлов Цикл
		
		Слово = СокрЛП(Слово);
		ПервыйСимвол = Лев(Слово, 1);
		
		Если ПервыйСимвол = "&" Тогда
			ВесКода = ВесКода + 1;
		ИначеЕсли (СтрДлина(Слово) = 1) И СтрокаВВерхнемРегистре(Слово) Тогда
			ВесКода = ВесКода + 1;
		ИначеЕсли НЕ (СтрокаВВерхнемРегистре(ПервыйСимвол) И НЕ СтрокаВВерхнемРегистре(Слово))
			И (СловоСодержитТолькоЛатиницу(ПервыйСимвол) ИЛИ СловоСодержитТолькоКириллицу(ПервыйСимвол)) Тогда
			
			ВесКода = ВесКода - 2;
			ВсеСловаСЗаглавнойБуквы = Ложь;
		КонецЕсли;
		
		ПозицияСкобки = СтрНайти(Слово, "(");
		СимволПередСкобкой = Сред(Слово, ПозицияСкобки - 1, 1);
		Если ПозицияСкобки > 0
			И (СловоСодержитТолькоЛатиницу(СимволПередСкобкой)
			ИЛИ СловоСодержитТолькоКириллицу(СимволПередСкобкой)
			ИЛИ ЭтоЧисло(СимволПередСкобкой)) Тогда
			
			ВесКода = ВесКода + 1;
			
		ИначеЕсли ПозицияСкобки > 0 Тогда
			
			ВесКода = ВесКода - 1;
			
		КонецЕсли;
		
		ПозицияТочки = СтрНайти(Слово, ".");
		СимволПослеТочки = Сред(Слово, ПозицияТочки + 1, 1);
		СловоПослеТочки = Сред(Слово, ПозицияТочки + 1);
		СловоДоТочки = Лев(Слово, ПозицияТочки - 1);
		Пока ПозицияТочки > 0 Цикл
			Если (СловоСодержитТолькоЛатиницу(СимволПослеТочки)
				ИЛИ СловоСодержитТолькоКириллицу(СимволПослеТочки)
				ИЛИ ЭтоЧисло(СимволПослеТочки)
				ИЛИ СимволПослеТочки = "_") Тогда
				
				Если ЭтоЧисло(СловоДоТочки) Тогда
					ВесКода = ВесКода - 3;
				Иначе
					ВесКода = ВесКода + 1;
				КонецЕсли;
			Иначе
				ВесКода = ВесКода - 1;
			КонецЕсли;
			
			ПозицияТочки = СтрНайти(СловоПослеТочки, ".");
			СловоПослеТочки = Сред(СловоПослеТочки, ПозицияТочки + 1);
			СимволПослеТочки = Сред(СловоПослеТочки, ПозицияТочки + 1, 1);
		КонецЦикла;
		
		Для Каждого СимволКода Из МассивСимволовКода Цикл
			Если СтрНайти(Слово, СимволКода) > 0 Тогда
				ВесКода = ВесКода + 1;
			КонецЕсли;
		КонецЦикла;
		
		ПозицияДвоеточия = СтрНайти(Слово, ":");
		СимволПередДвоеточием = Сред(Слово, ПозицияДвоеточия - 1, 1);
		Если ПозицияДвоеточия > 0
			И (СловоСодержитТолькоЛатиницу(СимволПередДвоеточием)
			ИЛИ СловоСодержитТолькоКириллицу(СимволПередДвоеточием)
			ИЛИ ЭтоЧисло(СимволПередДвоеточием)) Тогда
			
			ВесКода = ВесКода - 2;
		КонецЕсли;
		
		ПозицияЗвездочка = СтрНайти(Слово, "*");
		ПозицияВыбрать = СтрНайти(ВРег(Слово), "ВЫБРАТЬ");
		Если ПозицияЗвездочка > 0 И ПозицияВыбрать = 0 Тогда
			ВесКода = ВесКода - 2;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого СимволКода Из МассивФразКомментария Цикл
		Если СтрНайти(ВРег(Строка), СимволКода) > 0 Тогда
			ВесКода = ВесКода - 5;
		КонецЕсли;
	КонецЦикла;
	
	Если ВсеСловаСЗаглавнойБуквы И МассивСлов.Количество() > 1 Тогда
		ВесКода = ВесКода + 2;
	КонецЕсли;
	
	Если МассивСлов.Количество() = 1 Тогда
		ВесКода = ВесКода - 2;
	КонецЕсли;
	
	Если СтрЗаканчиваетсяНа(СокрЛП(Строка), ".") Тогда
		ВесКода = ВесКода - 5;
	КонецЕсли;
	
	Если СтрНайти(Строка, "...") > 0 Тогда
		ВесКода = ВесКода - 2;
	КонецЕсли;
	
	Если СтрНачинаетсяС(Строка, "=") Тогда
		ВесКода = ВесКода - 3;
	КонецЕсли;
	
	Если СтрЗаканчиваетсяНа(СтрокаВРег, ";") Тогда
		ВесКода = ВесКода + 1;
	КонецЕсли;
	
	Если СтрЗаканчиваетсяНа(СтрокаВРег, "-") Тогда
		ВесКода = ВесКода - 1;
	КонецЕсли;
	
	Если СтрокаСодержитОписаниеОбласти(СокрЛП(СтрокаМодуля)) Тогда
		ВесКода = ВесКода + 5;
	КонецЕсли;
	
	Если СтрокаМодуля = ВРег(СтрокаМодуля) Тогда
		ВесКода = ВесКода - 3;
	КонецЕсли;
	
	ЕстьСтрелка = (СтрНайти(СтрокаМодуля, "->") > 0);
	ЕстьТире = ЕстьСтрелка ИЛИ (СтрНайти(СтрокаМодуля, "-") > 0);
	ЕстьРавно = (СтрНайти(СтрокаМодуля, "=") > 0);
	ПервыйСимвол = Лев(СтрокаМодуля, 1);
	ПервыйСимволСокрЛ = Лев(СокрЛ(СтрокаМодуля), 1);
	ПоследнийСимвол = Прав(СокрП(СтрокаМодуля), 1);
	Если ЕстьТире И ЕстьРавно И (НЕ ЕстьСтрелка) Тогда
		ВесКода = ВесКода + 10;
	ИначеЕсли (ПервыйСимволСокрЛ = "-") И (ПоследнийСимвол <> ";") Тогда
		ВесКода = ВесКода - 10;
	ИначеЕсли (СтрЧислоВхождений(СтрокаМодуля, "-") >= 2) И (ПоследнийСимвол <> ";") Тогда
		ВесКода = ВесКода - 10;
	ИначеЕсли (СтрНайти(СтрокаМодуля, ", ") > 0)
			И (СтрНайти(СтрокаМодуля, ";") = 0)
			И (СтрНайти(СтрокаМодуля, "(") = 0)
			И (СтрНайти(СтрокаМодуля, ")") = 0)
			И (СтрНайти(СтрокаМодуля, "+") = 0)
			И (СтрНайти(СтрокаМодуля, "=") = 0) Тогда
		
		ВесКода = ВесКода - 10;
	КонецЕсли;
	
	Возврат ВесКода >= 0;
	
КонецФункции

// Возвращает флаг, определяющий, написана ли переданная строка в верхнем регистре.
//
// Параметры:
//   Строка - Строка - строка модуля.
//
// Возвращаемое значение:
//   Булево - флаг верхнего регистра:
//     Истина - переданная строка написана в верхнем регистре,
//     Ложь   - переданная строка написана в нижнем регистре или состоит из одного незначимого символа: """", "{", "(".
//
Функция СтрокаВВерхнемРегистре(Строка)
	
	Если Строка = """" ИЛИ Строка = "{" ИЛИ Строка = "(" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ВРег(Строка) = Строка;
	
КонецФункции

// Возвращает флаг, определяющий, содержит ли переданная строка описание области.
//
// Параметры:
//   Строка - Строка - строка модуля.
//
// Возвращаемое значение:
//   Булево - флаг наличия описания области:
//     Истина - переданная строка содержит описание области,
//     Ложь   - переданная строка не содержит описание области.
//
// Пример:
//   Для строк "СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ", "СтандартныеПодсистемы", "Конец СтандартныеПодсистемы"
//   функция возвращает значение Истина.
//
Функция СтрокаСодержитОписаниеОбласти(Строка)
	
	СокрСтрока = СтрЗаменить(Строка, "	", " ");
	ПозицияФразы = СтрНайти(ВРег(СокрСтрока), "КОНЕЦ ");
	Если ПозицияФразы > 0 И ПустаяСтрока(Сред(СокрСтрока, 1, ПозицияФразы - 1)) Тогда
		СокрСтрока = Сред(СокрСтрока, ПозицияФразы + 5);
	КонецЕсли;
	
	СтрокаБезПробелов = СтрЗаменить(СокрСтрока, " ", "");
	СтрокаБезПробеловИТочек = СтрЗаменить(СтрокаБезПробелов, ".", "");
	Если НЕ СловоСодержитТолькоКириллицу(СтрокаБезПробеловИТочек) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СокрСтрока = СокрЛП(СокрСтрока);
	
	Если СтрНайти(СокрСтрока, " ") = 0 ИЛИ СтрокаВВерхнемРегистре(СокрСтрока) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Создает и возвращает пустую таблицу для хранения устаревших процедур и функций.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица устаревших методов модулей с колонками:
//     ИмяМетода         - Строка - имя устаревшего метода.
//     ИмяМетодаВРег     - Строка - имя устаревшего метода в верхнем регистре.
//     Модуль            - Строка - наименование объекта, в котором найден устаревший метод.
//     ТипМодуля         - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля.
//     Экспорт           - Булево - флаг наличия экспорта у метода.
//     ЭтоФункция        - Булево - флаг, является ли метод функцией.
//     Глобальный        - Булево - флаг, определяющий, является ли объект глобальным общим модулем.
//     ОбъектСсылка      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект с устаревшим методом.
//     КонструкцияПоиска - Строка - строка в верхнем регистре, содержащая пример вызова устаревшего метода
//                                  из модуля другого объекта, например,
//                                  "АВТОНОМНАЯРАБОТАСЛУЖЕБНЫЙ.ЭТООБЪЕКТНАЧАЛЬНОГООБРАЗАУЗЛАРИБ(".
//     НомерСтроки       - Число  - номер строки объявления устаревшего метода.
//     ТекстОпределения  - Строка - текст объявления устаревшего метода.
//
Функция СоздатьТаблицуУстаревшихМетодов()
	
	ТаблицаУстаревшихМетодов = Новый ТаблицаЗначений;
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ИмяМетода");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ИмяМетодаВРег");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("Модуль");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ТипМодуля");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("Экспорт");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ЭтоФункция");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("Глобальный");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ОбъектСсылка");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("КонструкцияПоиска");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("НомерСтроки");
	ТаблицаУстаревшихМетодов.Колонки.Добавить("ТекстОпределения");
	
	Возврат ТаблицаУстаревшихМетодов;
	
КонецФункции

// Возвращает таблицу устаревших процедур и функций по переданной структуре параметров.
// Поиск устаревших процедур и функций осуществляется в области "УстаревшиеПроцедурыИФункции",
// являющейся дочерней для области "ПрограммныйИнтерфейс".
//
// Параметры:
//   СтруктураПараметров - Структура - структура параметров, по которым осуществляется поиск устаревших методов:
//     ОбъектКонфигурации              - СправочникСсылка.СтруктураКонфигурации - ссылка на объект,
//                                       в котором необходимо провести поиск устаревших методов.
//     Глобальный                      - Булево - флаг, определяющий, является ли объект глобальным общим модулем.
//     ТекстМодуля                     - Строка - текст модуля указанного объекта конфигурации.
//     МодульОбъекта                   - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов  - тип модуля объекта.
//     ТаблицаУстаревшихМетодовОбъекта - ТаблицаЗначений - исходная таблица устаревших методов текущего объекта.
//                                       Если не задана, то будет создана пустая таблица с помощью
//                                       функции СоздатьТаблицуУстаревшихМетодов().
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица устаревших методов модуля.
//   Состав колонок указан в комментарии к функции СоздатьТаблицуУстаревшихМетодов().
//
Функция ПолучитьТаблицуУстаревшихМетодовИзОбластиУстаревшиеПроцедурыИФункции(СтруктураПараметров)
	
	ТаблицаУстаревшихМетодовОбъекта = Неопределено;
	СтруктураПараметров.Свойство("ТаблицаУстаревшихМетодовОбъекта", ТаблицаУстаревшихМетодовОбъекта);
	Если ТаблицаУстаревшихМетодовОбъекта = Неопределено Тогда
		ТаблицаУстаревшихМетодовОбъекта = СоздатьТаблицуУстаревшихМетодов();
	КонецЕсли;
	
	ТекстМодуля = СтруктураПараметров.ТекстМодуля;
	Если ПустаяСтрока(ТекстМодуля) Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	ТекстПрограммныйИнтерфейс = ВРег("ПрограммныйИнтерфейс");
	
	ТаблицаОбластейМодуля = ПолучитьТаблицуОбластейМодуля(ТекстМодуля);
	
	// Проверяем область устаревших методов только в области "ПрограммныйИнтерфейс".
	ОбластьПрограммныйИнтерфейс = ТаблицаОбластейМодуля.Найти(ТекстПрограммныйИнтерфейс, "НаименованиеВРег");
	Если ОбластьПрограммныйИнтерфейс = Неопределено Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	ТекстУстаревшиеПроцедурыИФункции = ВРег("УстаревшиеПроцедурыИФункции");
	СтруктураОтбораОбластей = Новый Структура;
	СтруктураОтбораОбластей.Вставить("НаименованиеВРег", ТекстУстаревшиеПроцедурыИФункции);
	
	// Определяем нужную область "УстаревшиеПроцедурыИФункции", которая находится в области "ПрограммныйИнтерфейс".
	ОбластьУстаревшиеПроцедурыИФункции = Неопределено;
	МассивОбластейУстаревшихПроцедурИФункций = ТаблицаОбластейМодуля.НайтиСтроки(СтруктураОтбораОбластей);
	Для Каждого Область Из МассивОбластейУстаревшихПроцедурИФункций Цикл
		
		ОбластьРодитель = Область.Родитель;
		Если ОбластьРодитель = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ОбластьРодитель.НаименованиеВРег = ТекстПрограммныйИнтерфейс Тогда
			ОбластьУстаревшиеПроцедурыИФункции = Область;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если область "УстаревшиеПроцедурыИФункции" не существует, выходим.
	Если ОбластьУстаревшиеПроцедурыИФункции = Неопределено Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	ОбъектКонфигурации = СтруктураПараметров.ОбъектКонфигурации;
	МодульОбъекта = СтруктураПараметров.МодульОбъекта;
	Глобальный = СтруктураПараметров.Глобальный;
	
	// Определяем методы, расположенные в области "УстаревшиеПроцедурыИФункции".
	ТаблицаМетодовМодуля = ПолучитьТаблицуМетодовМодуля(МодульОбъекта, ОбъектКонфигурации);
	Для Каждого СтрокаМетода Из ТаблицаМетодовМодуля Цикл
		
		// Если метод вне области, то пропускаем его.
		Если (СтрокаМетода.НомерСтрокиНачало < ОбластьУстаревшиеПроцедурыИФункции.НомерСтрокиНачало)
		 ИЛИ (СтрокаМетода.НомерСтрокиКонец > ОбластьУстаревшиеПроцедурыИФункции.НомерСтрокиКонец) Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяМетода = СтрокаМетода.ИмяМетода;
		
		ИмяМодуля = ОбъектКонфигурации.Наименование;
		
		// Устанавливаем флаг "Глобальный" и конструкцию поиска.
		КонструкцияПоиска = ?(Глобальный, "", ИмяМодуля + ".");
		КонструкцияПоиска = СтрШаблон("%1%2(", КонструкцияПоиска, ИмяМетода);
		
		УстаревшийМетод = ТаблицаУстаревшихМетодовОбъекта.Добавить();
		УстаревшийМетод.ИмяМетода = ИмяМетода;
		УстаревшийМетод.ИмяМетодаВРег = СтрокаМетода.ИмяМетодаВРег;
		УстаревшийМетод.Модуль = ИмяМодуля;
		УстаревшийМетод.ТипМодуля = МодульОбъекта;
		УстаревшийМетод.Экспорт = СтрокаМетода.ЕстьЭкспорт;
		УстаревшийМетод.ЭтоФункция = (СтрокаМетода.ТипМетода = "Функция");
		УстаревшийМетод.Глобальный = Глобальный;
		УстаревшийМетод.ОбъектСсылка = ОбъектКонфигурации;
		УстаревшийМетод.КонструкцияПоиска = ВРег(КонструкцияПоиска);
		УстаревшийМетод.НомерСтроки = СтрокаМетода.НомерСтрокиНачало;
		УстаревшийМетод.ТекстОпределения = СтрокаМетода.ОписаниеМетода;
		
	КонецЦикла;
	
	Возврат ТаблицаУстаревшихМетодовОбъекта;
	
КонецФункции

// Возвращает таблицу устаревших процедур и функций по переданной структуре параметров.
// Поиск устаревших процедур и функций осуществляется по комментарию "// Устарела." перед методом.
//
// Параметры:
//   СтруктураПараметров - Структура - структура параметров, по которым осуществляется поиск устаревших методов:
//     ОбъектКонфигурации              - СправочникСсылка.СтруктураКонфигурации - ссылка на объект,
//                                       в котором необходимо провести поиск устаревших методов.
//     Глобальный                      - Булево - флаг, определяющий, является ли объект глобальным общим модулем.
//     ТекстМодуля                     - Строка - текст модуля указанного объекта конфигурации.
//     МодульОбъекта                   - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов  - тип модуля объекта.
//     ТаблицаУстаревшихМетодовОбъекта - ТаблицаЗначений - исходная таблица устаревших методов текущего объекта.
//                                       Если не задана, то будет создана пустая таблица с помощью
//                                       функции СоздатьТаблицуУстаревшихМетодов().
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица устаревших методов модуля.
//   Состав колонок указан в комментарии к функции СоздатьТаблицуУстаревшихМетодов().
//
Функция ПолучитьТаблицуУстаревшихМетодовПоКомментариюУстарела(СтруктураПараметров)
	
	ТаблицаУстаревшихМетодовОбъекта = Неопределено;
	СтруктураПараметров.Свойство("ТаблицаУстаревшихМетодовОбъекта", ТаблицаУстаревшихМетодовОбъекта);
	Если ТаблицаУстаревшихМетодовОбъекта = Неопределено Тогда
		ТаблицаУстаревшихМетодовОбъекта = СоздатьТаблицуУстаревшихМетодов();
	КонецЕсли;
	
	ТекстМодуля = СтруктураПараметров.ТекстМодуля;
	Если ПустаяСтрока(ТекстМодуля) Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	ШаблонПоискаКомментарияУстарела = "^[ \t]*//*[ \t]*Устарела\..*";
	МассивРезультатов = РегулярныеВыраженияНайти(ТекстМодуля, ШаблонПоискаКомментарияУстарела,, Истина, Истина);
	Если МассивРезультатов = Ложь Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	Если МассивРезультатов.Count = 0 Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	ОбъектКонфигурации = СтруктураПараметров.ОбъектКонфигурации;
	МодульОбъекта = СтруктураПараметров.МодульОбъекта;
	Глобальный = СтруктураПараметров.Глобальный;
	
	ТаблицаБлоковМодуля = ПолучитьСтруктуруМодуля(МодульОбъекта, ОбъектКонфигурации);
	
	Если ТаблицаБлоковМодуля = Неопределено Тогда
		Возврат ТаблицаУстаревшихМетодовОбъекта;
	КонецЕсли;
	
	Для Каждого ЭлементМассива Из МассивРезультатов Цикл
		
		НомерСтрокиКомментария = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ЭлементМассива.FirstIndex + 1);
		
		// Попробуем поискать по номеру строки блок модуля с комментарием.
		ИндексБлокаКомментария = 0;
		БлокМодуляКомментария = ТаблицаБлоковМодуля.Найти(НомерСтрокиКомментария, "НачальнаяСтрока");
		Если БлокМодуляКомментария <> Неопределено Тогда
			ИндексБлокаКомментария = ТаблицаБлоковМодуля.Индекс(БлокМодуляКомментария);
		КонецЕсли;
		
		БлокМетода = Неопределено;
		КоличествоБлоковМодуля = ТаблицаБлоковМодуля.Количество();
		Для НомерБлока = ИндексБлокаКомментария + 1 По КоличествоБлоковМодуля - 1 Цикл
			
			БлокМодуля = ТаблицаБлоковМодуля[НомерБлока];
			
			Если БлокМодуля.НачальнаяСтрока < НомерСтрокиКомментария Тогда
				Продолжить;
			КонецЕсли;
			
			ТипБлокаМодуля = БлокМодуля.Блок;
			
			Если (ТипБлокаМодуля = Перечисления.ТипыБлоковМодулей.ЗаголовокПроцедуры)
			 ИЛИ (ТипБлокаМодуля = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции) Тогда
				БлокМетода = БлокМодуля;
				Прервать;
			ИначеЕсли (ТипБлокаМодуля = Перечисления.ТипыБлоковМодулей.ОкончаниеПроцедуры)
				  ИЛИ (ТипБлокаМодуля = Перечисления.ТипыБлоковМодулей.ОкончаниеФункции) Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		// Если не нашли начало процедуры или функции, то переходим к следующему комментарию.
		Если БлокМетода = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЭтоФункция = (БлокМетода.Блок = Перечисления.ТипыБлоковМодулей.ЗаголовокФункции);
		ТипМетода = ?(ЭтоФункция, "Функция", "Процедура");
		
		ТекстБлока = СокрЛП(БлокМетода.Текст);
		ИмяМетода = Сред(ТекстБлока, СтрДлина(ТипМетода) + 1);
		ПозицияСкобки = СтрНайти(ИмяМетода, "(");
		Если ПозицияСкобки = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяМетода = СокрЛП(Лев(ИмяМетода, ПозицияСкобки - 1));
		
		// Иначе добавляем устаревший метод в таблицу.
		ИмяМодуля = ОбъектКонфигурации.Наименование;
		
		// Устанавливаем флаг "Глобальный" и конструкцию поиска.
		КонструкцияПоиска = ?(Глобальный, "", ИмяМодуля + ".");
		КонструкцияПоиска = СтрШаблон("%1%2(", КонструкцияПоиска, ИмяМетода);
		
		УстаревшийМетод = ТаблицаУстаревшихМетодовОбъекта.Добавить();
		УстаревшийМетод.ИмяМетода = ИмяМетода;
		УстаревшийМетод.ИмяМетодаВРег = ВРег(ИмяМетода);
		УстаревшийМетод.Модуль = ИмяМодуля;
		УстаревшийМетод.ТипМодуля = МодульОбъекта;
		УстаревшийМетод.Экспорт = БлокМодуля.ЕстьЭкспорт;
		УстаревшийМетод.ЭтоФункция = ЭтоФункция;
		УстаревшийМетод.Глобальный = Глобальный;
		УстаревшийМетод.ОбъектСсылка = ОбъектКонфигурации;
		УстаревшийМетод.КонструкцияПоиска = ВРег(КонструкцияПоиска);
		УстаревшийМетод.НомерСтроки = БлокМодуля.НачальнаяСтрока;
		УстаревшийМетод.ТекстОпределения = ТекстБлока;
		
	КонецЦикла;
	
	Возврат ТаблицаУстаревшихМетодовОбъекта;
	
КонецФункции

// Возвращает таблицу устаревших процедур и функций указанного объекта конфигурации.
// Если объект не указан, то возвращаются устаревшие методы текущего проверяемого объекта.
// Устаревшей считается процедура или функция:
// - в начале комментария к которой написано "// Устарела.";
// - расположенная в области "УстаревшиеПроцедурыИФункции", являющейся дочерней для области "ПрограммныйИнтерфейс".
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект с устаревшими методами.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица устаревших методов объекта.
//   Состав колонок указан в комментарии к функции СоздатьТаблицуУстаревшихМетодов().
//
Функция ПолучитьТаблицуУстаревшихМетодовОбъекта(Знач ОбъектКонфигурации = Неопределено)
	
	Если ОбъектКонфигурации = Неопределено Тогда
		ОбъектКонфигурации = ОбъектПроверкиСсылка;
	КонецЕсли;
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьТаблицуУстаревшихМетодовОбъекта";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТаблицаУстаревшихМетодовОбъекта = СоздатьТаблицуУстаревшихМетодов();
	
	Глобальный = Ложь;
	Если ОбъектКонфигурации.ТипОбъекта = Перечисления.ТипыОбъектов.ОбщийМодуль Тогда
		// Если объект - общий модуль, определяем, является ли он глобальным.
		СтруктураСвойствОбъекта = ПолучитьСвойства(ОбъектКонфигурации);
		Если СтруктураСвойствОбъекта.Свойство("Глобальный") Тогда
			Глобальный = СтруктураСвойствОбъекта.Глобальный;
		КонецЕсли;
	КонецЕсли;
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("ОбъектКонфигурации", ОбъектКонфигурации);
	СтруктураПараметров.Вставить("ТаблицаУстаревшихМетодовОбъекта", ТаблицаУстаревшихМетодовОбъекта);
	СтруктураПараметров.Вставить("Глобальный", Глобальный);
	
	ВсеМодулиОбъекта = ПолучитьСоставМодулей(ОбъектКонфигурации);
	Для Каждого МодульОбъекта Из ВсеМодулиОбъекта Цикл
		
		ТекстМодуля = ПолучитьСоставноеСвойство(МодульОбъекта, ОбъектКонфигурации);
		Если ПустаяСтрока(ТекстМодуля) Тогда
			Продолжить;
		КонецЕсли;
		
		СтруктураПараметров.Вставить("ТекстМодуля", ТекстМодуля);
		СтруктураПараметров.Вставить("МодульОбъекта", МодульОбъекта);
		
		ТаблицаУстаревшихМетодовОбъекта = ПолучитьТаблицуУстаревшихМетодовИзОбластиУстаревшиеПроцедурыИФункции(СтруктураПараметров);
		СтруктураПараметров.Вставить("ТаблицаУстаревшихМетодовОбъекта", ТаблицаУстаревшихМетодовОбъекта);
		
		ТаблицаУстаревшихМетодовОбъекта = ПолучитьТаблицуУстаревшихМетодовПоКомментариюУстарела(СтруктураПараметров);
		
	КонецЦикла;
	
	// Получаем список колонок таблицы устаревших методов.
	МассивКолонок = Новый Массив;
	Для Каждого Колонка Из ТаблицаУстаревшихМетодовОбъекта.Колонки Цикл
		МассивКолонок.Добавить(Колонка.Имя);
	КонецЦикла;
	
	// Устаревшие методы могут дублироваться в таблице, поэтому свернем таблицу по всем колонкам.
	КолонкиГруппировок = СтрСоединить(МассивКолонок, ", ");
	ТаблицаУстаревшихМетодовОбъекта.Свернуть(КолонкиГруппировок);
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаУстаревшихМетодовОбъекта);
	КонецЕсли;
	
	Возврат ТаблицаУстаревшихМетодовОбъекта;
	
КонецФункции

// Возвращает таблицу устаревших процедур и функций из модулей всех объектов конфигурации.
// Устаревшей считается процедура или функция:
// - в начале комментария к которой написано "// Устарела.";
// - расположенная в области "УстаревшиеПроцедурыИФункции", являющейся дочерней для области "ПрограммныйИнтерфейс".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица устаревших методов модулей всех объектов конфигурации.
//   Состав колонок указан в комментарии к функции СоздатьТаблицуУстаревшихМетодов().
//
Функция ПолучитьТаблицуУстаревшихМетодов()
	
	КлючКонтекста = "ТаблицаУстаревшихМетодов";
	ТаблицаУстаревшихМетодов = Контекст[КлючКонтекста];
	Если ТаблицаУстаревшихМетодов <> Неопределено Тогда
		Возврат ТаблицаУстаревшихМетодов;
	КонецЕсли;
	
	ТаблицаУстаревшихМетодов = СоздатьТаблицуУстаревшихМетодов();
	
	ТаблицаОбъектов = ПолучитьТаблицуОбъектовКонфигурацииСМодулями();
	Для Каждого СтрокаОбъекта Из ТаблицаОбъектов Цикл
		
		ОбъектСсылка = СтрокаОбъекта.Ссылка;
		
		ТаблицаУстаревшихМетодовОбъекта = ПолучитьТаблицуУстаревшихМетодовОбъекта(ОбъектСсылка);
		
		// Добавляем каждый найденный устаревший метод объекта в общую таблицу устаревших методов конфигурации.
		Для Каждого УстаревшийМетодОбъекта Из ТаблицаУстаревшихМетодовОбъекта Цикл
			НовыйУстаревшийМетод = ТаблицаУстаревшихМетодов.Добавить();
			ЗаполнитьЗначенияСвойств(НовыйУстаревшийМетод, УстаревшийМетодОбъекта);
		КонецЦикла;
		
	КонецЦикла;
	
	ТаблицаУстаревшихМетодов.Индексы.Добавить("ОбъектСсылка");
	ТаблицаУстаревшихМетодов.Индексы.Добавить("ОбъектСсылка, ТипМодуля");
	ТаблицаУстаревшихМетодов.Индексы.Добавить("ОбъектСсылка, ИмяМетодаВРег");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаУстаревшихМетодов);
	
	Возврат ТаблицаУстаревшихМетодов;
	
КонецФункции

// Возвращает структуру параметров вызова искомого метода в тексте модуле.
//
// Параметры:
//   ТекстМодуля         - Строка - многострочный текст модуля, в котором будет происходить поиск.
//   ИскомыйМетод        - Строка - имя искомого метода.
//   ПозицияНачалаПоиска - Число  - номер символа текста модуля, с которого начнется поиск.
//
// Возвращаемое значение:
//   Структура - структура параметров метода с ключами:
//     МетодНайден      - Булево - флаг результата поиска метода.
//     МассивПараметров - Массив - массив параметров, элемент: Строка - текст параметра при вызове метода.
//     ПозицияНачала    - Число  - номер символа начала вызова метода в переданном тексте модуля.
//     ПозицияОкончания - Число  - номер символа окончания вызова метода в переданном тексте модуля.
//     ТекстВызова      - Строка - текст вызова метода (с параметрами).
//     ТекстПараметров  - Строка - текст параметров вызова метода.
//     НомерСтроки      - Число  - номер строки начала вызова метода в тексте модуля.
//
Функция ПолучитьСтруктуруПараметровМетода(Знач ТекстМодуля, Знач ИскомыйМетод, Знач ПозицияНачалаПоиска = 1)
	
	МассивПараметров = Новый Массив;
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("МетодНайден", Ложь);
	СтруктураПараметров.Вставить("МассивПараметров", МассивПараметров);
	СтруктураПараметров.Вставить("ПозицияНачала", 0);
	СтруктураПараметров.Вставить("ПозицияОкончания", 0);
	СтруктураПараметров.Вставить("ТекстВызова", "");
	СтруктураПараметров.Вставить("ТекстПараметров", "");
	СтруктураПараметров.Вставить("НомерСтроки", 0);
	
	Если ПустаяСтрока(ТекстМодуля) ИЛИ ПустаяСтрока(ИскомыйМетод) Тогда
		Возврат СтруктураПараметров;
	КонецЕсли;
	
	ПозицияВызоваМетода = СтрНайти(ТекстМодуля, ИскомыйМетод,, ПозицияНачалаПоиска);
	Если ПозицияВызоваМетода = 0 Тогда
		Возврат СтруктураПараметров;
	КонецЕсли;
	
	СтруктураПараметров.МетодНайден = Истина;
	СтруктураПараметров.ПозицияНачала = ПозицияВызоваМетода;
	ТекстДоМетода = Лев(ТекстМодуля, ПозицияВызоваМетода);
	СтруктураПараметров.НомерСтроки = СтрЧислоСтрок(ТекстДоМетода);
	
	ПозицияОткрывающейсяСкобки = СтрНайти(ТекстМодуля, "(",, ПозицияВызоваМетода + СтрДлина(ИскомыйМетод) - 2);
	Если ПозицияОткрывающейсяСкобки = 0 Тогда
		СтруктураПараметров.ПозицияОкончания = ПозицияВызоваМетода + СтрДлина(ИскомыйМетод);
		Возврат СтруктураПараметров;
	КонецЕсли;
	
	КоличествоОткрывающихсяСкобок = 1;
	
	СтрокаОткрыта = Ложь;
	
	ПозицияНачалаПараметров = ПозицияОткрывающейсяСкобки + 1;
	ПозицияПараметра = ПозицияНачалаПараметров;
	
	ДлинаМодуля = СтрДлина(ТекстМодуля);
	
	Для НомерСимвола = ПозицияНачалаПараметров По ДлинаМодуля Цикл
		
		Символ = Сред(ТекстМодуля, НомерСимвола, 1);
		
		// Если кавычка, то открыть строку.
		Если Символ = """" Тогда
			СтрокаОткрыта = НЕ СтрокаОткрыта;
		КонецЕсли;
		
		// Все символы в кавычках считаем не функциональными.
		Если СтрокаОткрыта Тогда
			Продолжить;
		КонецЕсли;
		
		// Если открывающаяся скобка, то начинается, например, вызов другой функции в качестве параметра.
		Если Символ = "(" Тогда
			
			КоличествоОткрывающихсяСкобок = КоличествоОткрывающихсяСкобок + 1;
			
		// Если закрывающаяся скобка, то вызов другой функции закончился или закончились параметры искомой функции.
		ИначеЕсли Символ = ")" Тогда
			
			КоличествоОткрывающихсяСкобок = КоличествоОткрывающихсяСкобок - 1;
			
		// Если запятая, то закончился параметр.
		ИначеЕсли Символ = "," Тогда
			
			// Добавим параметр в массив, если это параметр искомой функции,
			// а не функции, вызываемой в качестве параметра.
			// Например, Функция1(Функция2(Параметр1, Параметр2), Параметр3) -
			// будет 2 параметра: "Функция2(Параметр1, Параметр2)" и "Параметр3",
			// Параметр1 и Параметр2 у Функция2 отдельно добавлять не нужно.
			Если КоличествоОткрывающихсяСкобок = 1 Тогда
				Параметр = Сред(ТекстМодуля, ПозицияПараметра, НомерСимвола - ПозицияПараметра);
				МассивПараметров.Добавить(СокрЛП(Параметр));
				ПозицияПараметра = НомерСимвола + 1;
			КонецЕсли;
			
		Иначе
			
			Продолжить;
			
		КонецЕсли;
		
		// Если количество открывающихся и закрывающихся скобок совпало,
		// то закончились параметры искомой функции, выходим из цикла.
		Если КоличествоОткрывающихсяСкобок = 0 Тогда
			
			// Добавим последний параметр.
			Параметр = Сред(ТекстМодуля, ПозицияПараметра, НомерСимвола - ПозицияПараметра);
			Если (МассивПараметров.Количество() > 0) ИЛИ (НЕ ПустаяСтрока(Параметр)) Тогда
				// Функция1() - без параметров, не нужно добавлять пустой параметр.
				// Функция2(,) - функция с двумя пустыми параметрами,
				// нужно добавить 2-й пустой параметр в массив параметров.
				
				МассивПараметров.Добавить(СокрЛП(Параметр));
			КонецЕсли;
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПозицияПереносаСтроки = СтрНайти(ТекстДоМетода, Символы.ПС, НаправлениеПоиска.СКонца) + 1;
	ТекстВызова = СокрЛП(Сред(ТекстМодуля, ПозицияПереносаСтроки, НомерСимвола - ПозицияПереносаСтроки + 2));
	ТекстПараметров = СокрЛП(Сред(ТекстМодуля, ПозицияНачалаПараметров, НомерСимвола - ПозицияНачалаПараметров));
	
	СтруктураПараметров.МассивПараметров = МассивПараметров;
	СтруктураПараметров.ПозицияОкончания = НомерСимвола;
	СтруктураПараметров.ТекстВызова = ТекстВызова;
	СтруктураПараметров.ТекстПараметров = ТекстПараметров;
	
	Возврат СтруктураПараметров;
	
КонецФункции

// Возвращает номер строки в переданном тексте модуля по номеру символа.
//
// Параметры:
//   ТекстМодуля  - Строка - многострочный текст модуля.
//   НомерСимвола - Число  - номер символа в тексте модуля.
//
// Возвращаемое значение:
//   Число - номер строки текста модуля.
//
Функция ПолучитьНомерСтрокиМодуля(ТекстМодуля, НомерСимвола)
	
	ТекстДоСимвола = Лев(ТекстМодуля, НомерСимвола);
	НомерСтроки = СтрЧислоСтрок(ТекстДоСимвола);
	
	Возврат НомерСтроки;
	
КонецФункции

// Возвращает наименование области из переданной строки модуля.
// Убирает из строки слово "#Область", пробелы и табуляцию по краям, удаляет комментарий из строки.
//
// Параметры:
//   СтрокаМодуля - Строка - строка модуля, содержащая раздел объявления области.
//
// Возвращаемое значение:
//   Строка - наименование области из строки модуля.
//
Функция ПолучитьНаименованиеОбласти(СтрокаМодуля)
	
	НаименованиеОбласти = СокрЛ(СтрокаМодуля);
	НаименованиеОбласти = Сред(НаименованиеОбласти, СтрДлина("#Область") + 1);
	
	ПозицияКомментария = СтрНайти(НаименованиеОбласти, "//");
	Если ПозицияКомментария > 0 Тогда
		НаименованиеОбласти = Лев(НаименованиеОбласти, ПозицияКомментария - 1);
	КонецЕсли;
	
	Возврат СокрЛП(НаименованиеОбласти);
	
КонецФункции

// Возвращает таблицу областей модуля по переданному тексту модуля.
// Проверяет наличие конструкции "#КонецОбласти" в тексте модуля.
// Если найден, то вызывает функцию ПолучитьТаблицуОбластейМодуля83(ТекстМодуля),
// иначе вызывает ПолучитьТаблицуОбластейМодуля82(ТекстМодуля).
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица областей модуля с колонками:
//     Наименование      - Строка                - наименование области.
//     НаименованиеВРег  - Строка                - наименование области в верхнем регистре.
//     ТекстОпределения  - Строка                - текст определения области.
//     НомерСтрокиНачало - Число                 - номер строки начала области.
//     НомерСтрокиКонец  - Число                 - номер строки окончания области.
//     Родитель          - Неопределено          - если области определялись в формате "1С:Предприятие 8.2".
//                         СтрокаТаблицыЗначений - ссылка на строку этой таблицы значений,
//                                                 которая является родительской областью.
//
Функция ПолучитьТаблицуОбластейМодуля(Знач ТекстМодуля)
	
	Если СтрНайти(ТекстМодуля, "#КонецОбласти") = 0 Тогда
		ТаблицаОбластей = ПолучитьТаблицуОбластейМодуля82(ТекстМодуля);
	Иначе
		ТаблицаОбластей = ПолучитьТаблицуОбластейМодуля83(ТекстМодуля);
	КонецЕсли;
	
	Возврат ТаблицаОбластей;
	
КонецФункции

// Возвращает таблицу областей модуля по переданному тексту модуля, оформленных в формате "1С:Предприятие 8.2".
// Начало каждой области оформляется комментарием из 80-ти знаков "/".
// Начало следующей области считается концом предыдущей.
// Вложение областей при этом не учитывается, т.к. считается, что каждая область находится на верхнем уровне.
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица областей модуля с колонками:
//     Наименование      - Строка       - наименование области.
//     НаименованиеВРег  - Строка       - наименование области в верхнем регистре.
//     ТекстОпределения  - Строка       - текст определения области.
//     НомерСтрокиНачало - Число        - номер строки начала области.
//     НомерСтрокиКонец  - Число        - номер строки окончания области.
//     Родитель          - Неопределено - т.к. вложенных областей нет.
//
Функция ПолучитьТаблицуОбластейМодуля82(Знач ТекстМодуля)
	
	ТаблицаОбластей = Новый ТаблицаЗначений();
	ТаблицаОбластей.Колонки.Добавить("Наименование");
	ТаблицаОбластей.Колонки.Добавить("НаименованиеВРег");
	ТаблицаОбластей.Колонки.Добавить("ТекстОпределения");
	ТаблицаОбластей.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаОбластей.Колонки.Добавить("НомерСтрокиКонец");
	ТаблицаОбластей.Колонки.Добавить("Родитель");
	
	ТекстНачалаОбласти = "///////////////////////////////////////////////////////////////////////////////";
	ДлинаТекстаНачалаОбласти = СтрДлина(ТекстНачалаОбласти);
	ПозицияПоиска = 1;
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстМодуля);
	
	НоваяОбласть = Неопределено;
	
	Пока Истина Цикл
		
		ПозицияНачалаОбласти = СтрНайти(ТекстМодуля, ТекстНачалаОбласти,, ПозицияПоиска);
		Если ПозицияНачалаОбласти = 0 Тогда
			Прервать;
		КонецЕсли;
		
		ПозицияПоиска = ПозицияНачалаОбласти + ДлинаТекстаНачалаОбласти;
		
		// Наименование области записано в следующей строке.
		НомерСтроки = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ПозицияНачалаОбласти);
		СтрокаМодуля = ТекстовыйДокумент.ПолучитьСтроку(НомерСтроки + 1);
		СтрокаМодуля = СокрЛП(СтрокаМодуля);
		
		// Если строка начинается не с комментария, то это не начало области.
		Если НЕ СтрНачинаетсяС(СтрокаМодуля, "//") Тогда
			Продолжить;
		КонецЕсли;
		
		// Если строка пустая, то это не начало области.
		СтрокаМодуля = СтрЗаменить(СтрокаМодуля, "/", "");
		Если ПустаяСтрока(СтрокаМодуля) Тогда
			Продолжить;
		КонецЕсли;
		
		// Считаем областью только строку, записанную большими буквами.
		Если НЕ СтрокаВВерхнемРегистре(СтрокаМодуля) Тогда
			Продолжить;
		КонецЕсли;
		
		// Закроем предыдущую область.
		Если НоваяОбласть <> Неопределено Тогда
			НоваяОбласть.НомерСтрокиКонец = НомерСтроки;
		КонецЕсли;
		
		НаименованиеОбласти = ТРег(СтрокаМодуля);
		НаименованиеОбласти = СтрЗаменить(НаименованиеОбласти, Символы.Таб, "");
		НаименованиеОбласти = СтрЗаменить(НаименованиеОбласти, " ", "");
		
		НоваяОбласть = ТаблицаОбластей.Добавить();
		НоваяОбласть.Наименование = НаименованиеОбласти;
		НоваяОбласть.НаименованиеВРег = ВРег(НаименованиеОбласти);
		НоваяОбласть.ТекстОпределения = "#Область " + НаименованиеОбласти;
		НоваяОбласть.НомерСтрокиНачало = НомерСтроки + 1;
		
	КонецЦикла;
	
	// Закроем последнюю область.
	Если НоваяОбласть <> Неопределено Тогда
		НоваяОбласть.НомерСтрокиКонец = ТекстовыйДокумент.КоличествоСтрок();
	КонецЕсли;
	
	Возврат ТаблицаОбластей;
	
КонецФункции

// Возвращает таблицу областей модуля по переданному тексту модуля.
// Начало каждой области оформляется конструкцией "#Область", конец - "#КонецОбласти".
// Вложение областей учитывается.
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица областей модуля с колонками:
//     Наименование      - Строка                - наименование области.
//     НаименованиеВРег  - Строка                - наименование области в верхнем регистре.
//     ТекстОпределения  - Строка                - текст определения области.
//     НомерСтрокиНачало - Число                 - номер строки начала области.
//     НомерСтрокиКонец  - Число                 - номер строки окончания области.
//     Родитель          - СтрокаТаблицыЗначений - ссылка на строку этой таблицы значений,
//                                                 которая является родительской областью.
//
Функция ПолучитьТаблицуОбластейМодуля83(Знач ТекстМодуля)
	
	ТаблицаОбластей = Новый ТаблицаЗначений();
	ТаблицаОбластей.Колонки.Добавить("Наименование");
	ТаблицаОбластей.Колонки.Добавить("НаименованиеВРег");
	ТаблицаОбластей.Колонки.Добавить("ТекстОпределения");
	ТаблицаОбластей.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаОбластей.Колонки.Добавить("НомерСтрокиКонец");
	
	ДеревоОбластей = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаОбластей.Колонки Цикл
		ДеревоОбластей.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	ДеревоОбластей.Колонки.Добавить("ЭтоОбласть");
	ТаблицаОбластей.Колонки.Добавить("Родитель");
	
	ШаблонПоиска = "^[ \t]*#[ \t]*(?:Область|КонецОбласти).*";
	
	МассивРезультатов = РегулярныеВыраженияНайти(ТекстМодуля, ШаблонПоиска,, Истина, Истина);
	Если МассивРезультатов = Ложь Тогда
		Возврат ТаблицаОбластей;
	КонецЕсли;
	
	ТекущаяОбласть = ДеревоОбластей.Строки.Добавить();
	ТекущаяОбласть.Наименование = "Области";
	ТекущаяОбласть.ЭтоОбласть = Ложь;
	
	Для Каждого ЭлементМассива Из МассивРезультатов Цикл
		
		ТекстОбласти = СокрЛП(ЭлементМассива.Value);
		ТекстОбластиБезПробелов = ТекстОбласти;
		ТекстОбластиБезПробелов = СтрЗаменить(ТекстОбластиБезПробелов, " ", "");
		ТекстОбластиБезПробелов = СтрЗаменить(ТекстОбластиБезПробелов, Символы.Таб, "");
		ТекстОбластиВРег = ВРег(ТекстОбластиБезПробелов);
		
		Если СтрНачинаетсяС(ТекстОбластиВРег, ВРег("#Область")) Тогда
			
			НаименованиеОбласти = ПолучитьНаименованиеОбласти(ТекстОбластиБезПробелов);
			
			НоваяОбласть = ТекущаяОбласть.Строки.Добавить();
			НоваяОбласть.Наименование = НаименованиеОбласти;
			НоваяОбласть.НаименованиеВРег = ВРег(НаименованиеОбласти);
			НоваяОбласть.ТекстОпределения = ТекстОбласти;
			НоваяОбласть.НомерСтрокиНачало = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ЭлементМассива.FirstIndex + 1);
			НоваяОбласть.ЭтоОбласть = Истина;
			
			ТекущаяОбласть = НоваяОбласть;
			
		ИначеЕсли СтрНачинаетсяС(ТекстОбластиВРег, ВРег("#КонецОбласти")) Тогда
			
			ТекущаяОбласть.НомерСтрокиКонец = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ЭлементМассива.FirstIndex + 1);
			
			ТекущаяОбласть = ТекущаяОбласть.Родитель;
			Если ТекущаяОбласть = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПараметрыОтбора = Новый Структура("ЭтоОбласть", Истина);
	МассивСтрокОбластей = ДеревоОбластей.Строки.НайтиСтроки(ПараметрыОтбора, Истина);
	
	Для Каждого СтрокаОбласти Из МассивСтрокОбластей Цикл
		НоваяОбласть = ТаблицаОбластей.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяОбласть, СтрокаОбласти);
	КонецЦикла;
	
	Возврат ТаблицаОбластей;
	
КонецФункции

// Возвращает таблицу инструкций препроцессора по переданному тексту модуля.
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица инструкций препроцессора с колонками:
//     ТекстОпределения  - Строка - текст определения инструкции.
//     НомерСтрокиНачало - Число  - номер строки начала инструкции.
//     НомерСтрокиКонец  - Число  - номер строки окончания инструкции.
//
Функция ПолучитьТаблицуИнструкцийПрепроцессора(Знач ТекстМодуля)
	
	ТаблицаИнструкций = Новый ТаблицаЗначений();
	ТаблицаИнструкций.Колонки.Добавить("ТекстОпределения");
	ТаблицаИнструкций.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаИнструкций.Колонки.Добавить("НомерСтрокиКонец");
	
	ДеревоИнструкций = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаИнструкций.Колонки Цикл
		ДеревоИнструкций.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	ДеревоИнструкций.Колонки.Добавить("ЭтоИнструкция");
	
	ШаблонПоиска = "^[ \t]*#[ \t]*(?:Если|КонецЕсли).*";
	
	МассивРезультатов = РегулярныеВыраженияНайти(ТекстМодуля, ШаблонПоиска,, Истина, Истина);
	Если МассивРезультатов = Ложь Тогда
		Возврат ТаблицаИнструкций;
	КонецЕсли;
	
	ТекущаяИнструкция = ДеревоИнструкций.Строки.Добавить();
	ТекущаяИнструкция.ЭтоИнструкция = Ложь;
	
	Для Каждого ЭлементМассива Из МассивРезультатов Цикл
		
		ТекстИнструкции = СокрЛП(ЭлементМассива.Value);
		ТекстИнструкцииВРег = ВРег(ТекстИнструкции);
		ТекстИнструкцииВРег = СтрЗаменить(ТекстИнструкцииВРег, " ", "");
		ТекстИнструкцииВРег = СтрЗаменить(ТекстИнструкцииВРег, Символы.Таб, "");
		
		Если СтрНачинаетсяС(ТекстИнструкцииВРег, ВРег("#Если")) Тогда
			
			НоваяИнструкция = ТекущаяИнструкция.Строки.Добавить();
			НоваяИнструкция.ТекстОпределения = ТекстИнструкции;
			НоваяИнструкция.НомерСтрокиНачало = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ЭлементМассива.FirstIndex + 1);
			НоваяИнструкция.ЭтоИнструкция = Истина;
			
			ТекущаяИнструкция = НоваяИнструкция;
			
		ИначеЕсли СтрНачинаетсяС(ТекстИнструкцииВРег, ВРег("#КонецЕсли")) Тогда
			
			ТекущаяИнструкция.НомерСтрокиКонец = ПолучитьНомерСтрокиМодуля(ТекстМодуля, ЭлементМассива.FirstIndex + 1);
			
			ТекущаяИнструкция = ТекущаяИнструкция.Родитель;
			Если ТекущаяИнструкция = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПараметрыОтбора = Новый Структура("ЭтоИнструкция", Истина);
	МассивСтрокИнструкций = ДеревоИнструкций.Строки.НайтиСтроки(ПараметрыОтбора, Истина);
	
	Для Каждого СтрокаИнструкции Из МассивСтрокИнструкций Цикл
		
		НоваяИнструкция = ТаблицаИнструкций.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяИнструкция, СтрокаИнструкции);
		
	КонецЦикла;
	
	Возврат ТаблицаИнструкций;
	
КонецФункции

// Возвращает таблицу методов из модулей всех объектов конфигурации,
// которые используются в конструкторе "Новый ОписаниеОповещения()" 1-м или 4-м параметром.
//
// Функция вызывается в правилах проверки:
//  - "Не следует размещать экспортные процедуры и функции в модулях форм";
//  - "Не следует размещать экспортные процедуры и функции в модулях команд и общих команд";
//  - "Проверка использования серверных процедур в качестве обработчиков оповещения".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица методов из конструктора "ОписаниеОповещения" с колонками:
//     Объект            - СправочникСсылка.СтруктураКонфигурации - ссылка на объект, в котором вызывается конструктор.
//     Метод             - Строка                                 - имя процедуры в верхнем регистре.
//     ТипОбъекта        - ПеречислениеСсылка.ТипыОбъектов        - тип объекта из колонки "Объект".
//     Модуль            - Строка                                 - значение 2-го или 5-го параметра
//                                                                  конструктора "ОписаниеОповещения".
//     МодульСсылка      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект, указанный в качестве
//                                                                  2-го или 5-го параметра конструктора "ОписаниеОповещения".
//     НомерСтрокиНачало - Число                                  - номер строки начала конструктора "ОписаниеОповещения".
//     НомерСтрокиКонец  - Число                                  - номер строки конца конструктора "ОписаниеОповещения".
//
Функция ПолучитьТаблицуМетодовИзОписанияОповещения()
	
	КлючКонтекста = "ТаблицаМетодовИзОписанияОповещения";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТекстОписаниеОповещения = ВРег("НовыйОписаниеОповещения(");
	ТекстЭтотОбъект = ВРег("ЭтотОбъект");
	
	// Номера параметров описания оповещения, под которыми могут находиться экспортные процедуры (см. справку).
	МассивНомеровПараметров = Новый Массив;
	МассивНомеровПараметров.Добавить(0);
	МассивНомеровПараметров.Добавить(3);
	
	ТаблицаМетодовИзОписанияОповещения = Новый ТаблицаЗначений;
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("Объект");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("Метод");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("ТипОбъекта");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("Модуль");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("МодульСсылка");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаМетодовИзОписанияОповещения.Колонки.Добавить("НомерСтрокиКонец");
	
	ТаблицаОбъектовОбщиеМодули = ПолучитьОбъектыКонфигурацииОбщиеМодули();
	
	// Составим массив типов объектов, в которых может вызываться конструктор "ОписаниеОповещение".
	МассивТиповОбъектов = Новый Массив;
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.ОбщийМодуль);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.ОбщаяУправляемаяФорма);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.УправляемаяФорма);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.ОбщаяФорма);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.Форма);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.Команда);
	МассивТиповОбъектов.Добавить(Перечисления.ТипыОбъектов.ОбщаяКоманда);
	
	Для Каждого ТипОбъектов Из МассивТиповОбъектов Цикл
		
		Если ТипОбъектов = Перечисления.ТипыОбъектов.ОбщийМодуль Тогда
			ТаблицаОбъектов = ПолучитьОбъектыКонфигурацииОбщиеМодули(Истина);
		Иначе
			ТаблицаОбъектов = ПолучитьОбъектыКонфигурации(ТипОбъектов);
		КонецЕсли;
		
		Для Каждого СтрокаТаблицы Из ТаблицаОбъектов Цикл
			
			ОбъектСсылка = СтрокаТаблицы.Ссылка;
			ТипОбъекта = СтрокаТаблицы.ТипОбъекта;
			
			СоставМодулей = ПолучитьСоставМодулей(ОбъектСсылка);
			Для Каждого МодульОбъекта Из СоставМодулей Цикл
				
				ТекстМодуля = ПолучитьТекстМодуля(МодульОбъекта, ОбъектСсылка, Истина);
				Если ПустаяСтрока(ТекстМодуля) Тогда
					Продолжить;
				КонецЕсли;
				
				ТекстМодуля = СтрЗаменить(ТекстМодуля, " ", "");
				ТекстМодуля = СтрЗаменить(ТекстМодуля, Символы.Таб, "");
				ТекстМодуля = ВРег(ТекстМодуля);
				
				ПозицияОповещения = 0;
				Пока Истина Цикл
					
					// Ищем ОписаниеОповещения во всем тексте модуля.
					ПозицияОповещения = СтрНайти(ТекстМодуля, ТекстОписаниеОповещения,, ПозицияОповещения + 1);
					Если ПозицияОповещения = 0 Тогда
						Прервать;
					КонецЕсли;
					
					// Нашли ОписаниеОповещения, считываем параметры.
					СтруктураМетода = ПолучитьСтруктуруПараметровМетода(ТекстМодуля, ТекстОписаниеОповещения, ПозицияОповещения);
					МассивПараметров = СтруктураМетода.МассивПараметров;
					
					Для Каждого НомерПараметра Из МассивНомеровПараметров Цикл
						// Проверяем, что параметр под номером НомерПараметра указан в описании оповещения.
						Если НомерПараметра > МассивПараметров.ВГраница() Тогда
							Прервать;
						КонецЕсли;
						
						// Получаем модуль, из которого вызывается обработчик оповещения - <Модуль> или <МодульОбработкиОшибки>.
						ИмяМодуля = "";
						МодульСсылка = Справочники.СтруктураКонфигурации.ПустаяСсылка();
						Если НомерПараметра + 1 <= МассивПараметров.ВГраница() Тогда
							ИмяМодуля = МассивПараметров[НомерПараметра + 1];
							
							// Определяем ссылку на модуль в структуре конфигурации.
							Если ИмяМодуля = ТекстЭтотОбъект Тогда
								// Если в имени модуля написано "ЭтотОбъект", то берем текущий объект.
								МодульСсылка = ОбъектСсылка;
							Иначе
								ИмяМодуляДляПоиска = ИмяМодуля;
								Если СтрНайти(ИмяМодуляДляПоиска, "." + ТекстЭтотОбъект) > 0 Тогда
									// Если в имени модуля содержится фраза "ЭтотОбъект", тогда убираем ее.
									ИмяМодуляДляПоиска = СтрЗаменить(ИмяМодуляДляПоиска, "." + ТекстЭтотОбъект, "");
								КонецЕсли;
								
								// Ищем модуль в таблице общих модулей.
								СтрокаОбщегоМодуля = ТаблицаОбъектовОбщиеМодули.Найти(ИмяМодуляДляПоиска, "НаименованиеВРег");
								Если СтрокаОбщегоМодуля <> Неопределено Тогда
									МодульСсылка = СтрокаОбщегоМодуля.Ссылка;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
						
						// Считываем параметр у ОписаниеОповещения - <ИмяПроцедуры> или <ИмяПроцедурыОбработкиОшибки>.
						ИмяПараметра = МассивПараметров[НомерПараметра];
						// Если в параметре есть кавычки, то это строковое имя процедуры.
						Если СтрНайти(ИмяПараметра, """") > 0 Тогда
							ИмяПроцедуры = СтрЗаменить(ИмяПараметра, """", "");
							
							// Записываем процедуру в таблицу методов.
							НовыйМетод = ТаблицаМетодовИзОписанияОповещения.Добавить();
							НовыйМетод.Объект = ОбъектСсылка;
							НовыйМетод.Метод = ИмяПроцедуры;
							НовыйМетод.ТипОбъекта = ТипОбъекта;
							НовыйМетод.Модуль = ИмяМодуля;
							НовыйМетод.МодульСсылка = МодульСсылка;
							НовыйМетод.НомерСтрокиНачало = СтруктураМетода.НомерСтроки;
							НовыйМетод.НомерСтрокиКонец = ПолучитьНомерСтрокиМодуля(ТекстМодуля, СтруктураМетода.ПозицияОкончания);
							
							Продолжить;
						КонецЕсли;
						
						// Если кавычек нет, то это переменная. Ищем инициализацию переменной строковой константой.
						// Их может быть несколько, поэтому в цикле.
						ИмяПеременной = ИмяПараметра + "=""";
						ДлинаПеременной = СтрДлина(ИмяПеременной);
						ПозицияПеременной = ПозицияОповещения;
						Пока Истина Цикл
							
							// Ищем инициализацию переменной до вызова описания оповещения.
							ПозицияПеременной = СтрНайти(ТекстМодуля, ИмяПеременной, НаправлениеПоиска.СКонца, ПозицияПеременной - 1);
							Если ПозицияПеременной = 0 Тогда
								Прервать;
							КонецЕсли;
							
							ПозицияНачалаИнициализации = ПозицияПеременной + ДлинаПеременной;
							
							// Ищем окончание инициализации переменной.
							ПозицияКонцаИнициализации = СтрНайти(ТекстМодуля, """",, ПозицияНачалаИнициализации);
							Если ПозицияКонцаИнициализации = 0 Тогда
								Прервать;
							КонецЕсли;
							
							ИмяПроцедуры = Сред(ТекстМодуля, ПозицияНачалаИнициализации, ПозицияКонцаИнициализации - ПозицияНачалаИнициализации);
							
							// Записываем процедуру в таблицу методов.
							НовыйМетод = ТаблицаМетодовИзОписанияОповещения.Добавить();
							НовыйМетод.Объект = ОбъектСсылка;
							НовыйМетод.Метод = ИмяПроцедуры;
							НовыйМетод.ТипОбъекта = ТипОбъекта;
							НовыйМетод.Модуль = ИмяМодуля;
							НовыйМетод.МодульСсылка = МодульСсылка;
							НовыйМетод.НомерСтрокиНачало = СтруктураМетода.НомерСтроки;
							НовыйМетод.НомерСтрокиКонец = ПолучитьНомерСтрокиМодуля(ТекстМодуля, СтруктураМетода.ПозицияОкончания);
							
						КонецЦикла;
						
					КонецЦикла;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТаблицаМетодовИзОписанияОповещения.Индексы.Добавить("Метод");
	ТаблицаМетодовИзОписанияОповещения.Индексы.Добавить("Объект");
	ТаблицаМетодовИзОписанияОповещения.Индексы.Добавить("МодульСсылка");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаМетодовИзОписанияОповещения);
	
	Возврат ТаблицаМетодовИзОписанияОповещения;
	
КонецФункции

// Возвращает таблицу экспортных методов общих модулей и модулей менеджеров объектов конфигурации.
// В общую таблицу по умолчанию не включаются методы (эта установка вынесена в параметры):
//   - методы из области "ПрограммныйИнтерфейс",
//   - методы объектов, входящих хотя бы в 1 подсистему, включенную в командный интерфейс.
//
// Параметры:
//   ДобавитьМетодыИзОбластиПрограммныйИнтерфейс                  - Булево - флаг добавления методов,
//                                                                  описанных в области "ПрограммныйИнтерфейс".
//   ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс - Булево - флаг добавления методов объектов, входящих
//                                                                  хотя бы в 1 подсистему, включенную в командный интерфейс.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица экспортных методов с колонками:
//     Объект                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект с экспортным методом.
//     ИмяМодуля                   - Строка - наименование объекта в верхнем регистре.
//     Подсистемы                  - Массив - массив подсистем, в которые входит объект. Элементы массива:
//       СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему.
//     ПодсистемыВерхнегоУровня    - Массив - массив подсистем верхнего уровня, в которые входит объект. Элементы массива:
//       СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему верхнего уровня.
//     ВключатьВКомандныйИнтерфейс - Булево - флаг вхождения объекта в состав подсистемы, включенной в КИ.
//     ИмяМетода                   - Строка - имя экспортного метода в верхнем регистре.
//     Область                     - Строка - имя области в верхнем регистре.
//     ШаблоныПоиска               - ТаблицаЗначений - таблица шаблонов поиска метода с колонками:
//       Шаблон        - Строка - текст шаблона поиска метода: "ИмяМодуля.ИмяМетода(" или ""ИмяМодуля.ИмяМетода"".
//       ПозицияНачала - Число  - номер символа начала поиска шаблона.
//       ПозицияКонца  - Число  - номер символа конца поиска шаблона.
//
Функция ПолучитьТаблицуЭкспортныхМетодовОбщихМодулейИМодулейМенеджеров(
	ДобавитьМетодыИзОбластиПрограммныйИнтерфейс = Ложь,
	ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс = Ложь)
	
	КлючКонтекста = СтрШаблон("ТаблицаЭкспортныхМетодовОбщихМодулейИМодулейМенеджеров_%1_%2",
		ДобавитьМетодыИзОбластиПрограммныйИнтерфейс, ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс);
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТаблицаПодсистем = ПолучитьОбъектыКонфигурацииПодсистемы();
	
	ТекстВключатьВКомандныйИнтерфейс = "ВключатьВКомандныйИнтерфейс";
	ТекстПрограммныйИнтерфейс = "ПрограммныйИнтерфейс";
	
	ШаблоныПоискаПоУмолчанию = Новый ТаблицаЗначений;
	ШаблоныПоискаПоУмолчанию.Колонки.Добавить("Шаблон");
	ШаблоныПоискаПоУмолчанию.Колонки.Добавить("ПозицияНачала");
	ШаблоныПоискаПоУмолчанию.Колонки.Добавить("ПозицияКонца");
	ШаблоныПоискаПоУмолчанию.Добавить().Шаблон = "%1.%2(";
	ШаблоныПоискаПоУмолчанию.Добавить().Шаблон = """%1.%2""";
	ШаблоныПоискаПоУмолчанию.ЗаполнитьЗначения(Неопределено, "ПозицияНачала");
	ШаблоныПоискаПоУмолчанию.ЗаполнитьЗначения(Неопределено, "ПозицияКонца");
	
	// Создадим таблицу для хранения всех экспортных методов общих модулей и модулей менеджеров.
	ТаблицаЭкспортныхМетодов = Новый ТаблицаЗначений;
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("Объект");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("ИмяМодуля");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("Подсистемы");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("ПодсистемыВерхнегоУровня");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить(ТекстВключатьВКомандныйИнтерфейс);
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("ИмяМетода");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("ОписаниеМетода");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("Область");
	ТаблицаЭкспортныхМетодов.Колонки.Добавить("ШаблоныПоиска");
	
	ТекстЭкспорт = ВРег("Экспорт");
	
	СтруктураОтбораЭкспорт = Новый Структура;
	СтруктураОтбораЭкспорт.Вставить("ЕстьЭкспорт", Истина);
	
	МассивТиповМодулей = Новый Массив;
	МассивТиповМодулей.Добавить(Перечисления.ИдентификаторыСодержанияОбъектов.Модуль);
	МассивТиповМодулей.Добавить(Перечисления.ИдентификаторыСодержанияОбъектов.МодульМенеджера);
	
	ТаблицаОбщиеМодулиИМодулиМенеджеров = ПолучитьТаблицуОбъектовОбщиеМодулиИМодулиМенеджера();
	Для Каждого ОбъектКонфигурации Из ТаблицаОбщиеМодулиИМодулиМенеджеров Цикл
		
		ОбъектСсылка = ОбъектКонфигурации.Объект;
		
		ИмяМодуля = ВРег(ОбъектКонфигурации.Имя);
		Если ОбъектКонфигурации.ТипОбъекта <> Перечисления.ТипыОбъектов.ОбщийМодуль Тогда
			// Добавим тип объекта в наименование модуля.
			ИмяМодуля = ВРег(ОбъектКонфигурации.ИмяРодителя) + "." + ИмяМодуля;
		КонецЕсли;
		
		СоставМодулей = ПолучитьСоставМодулей(ОбъектСсылка);
		Если НЕ ЗначениеЗаполнено(СоставМодулей) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипМодуля Из СоставМодулей Цикл
			
			// Проверяем только общие модули и модули менеджера.
			Если МассивТиповМодулей.Найти(ТипМодуля) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Проверим, что в модуле есть экспортные методы.
			ТаблицаЭкспортныхМетодовМодуля = ПолучитьТаблицуМетодовМодуля(ТипМодуля, ОбъектСсылка);
			МассивЭкспортныхМетодовМодуля = ТаблицаЭкспортныхМетодовМодуля.НайтиСтроки(СтруктураОтбораЭкспорт);
			Если МассивЭкспортныхМетодовМодуля.Количество() = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			// Получим информацию о подсистемах объекта.
			МассивПодсистем = ОбъектСсылка.Подсистемы.ВыгрузитьКолонку("Подсистема");
			МассивПодсистемВерхнегоУровня = Новый Массив;
			// Флаг "ВключатьВКомандныйИнтерфейс" определяем среди всех подсистем, в которые входит объект.
			// Если есть хоть одна подсистема с установленным флагом, тогда определяем флаг как Истина.
			ВключатьВКомандныйИнтерфейс = Ложь;
			Для Каждого ПодсистемаОбъекта Из МассивПодсистем Цикл
				// Ищем подсистему в таблице подсистем.
				СтрокаПодсистемы = ТаблицаПодсистем.Найти(ПодсистемаОбъекта, "Ссылка");
				Если СтрокаПодсистемы = Неопределено Тогда
					// Не нашли во всей таблице подсистем, пропускаем.
					Продолжить;
				КонецЕсли;
				
				Если НЕ ВключатьВКомандныйИнтерфейс Тогда
					ВключатьВКомандныйИнтерфейс = СтрокаПодсистемы[ТекстВключатьВКомандныйИнтерфейс];
				КонецЕсли;
				
				ПодсистемаВерхнегоУровня = СтрокаПодсистемы.ПодсистемаВерхнегоУровня;
				Если МассивПодсистемВерхнегоУровня.Найти(ПодсистемаВерхнегоУровня) = Неопределено Тогда
					МассивПодсистемВерхнегоУровня.Добавить(ПодсистемаВерхнегоУровня);
				КонецЕсли;
			КонецЦикла;
			
			// Если вызываемый объект принадлежит подсистеме, включенной в командный интерфейс,
			// то его методы можно вызывать из любого места.
			// Пропускаем эти объекты, если в параметрах не указано, что надо добавлять такие методы.
			Если (НЕ ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс) И ВключатьВКомандныйИнтерфейс Тогда
				Продолжить;
			КонецЕсли;
			
			ТекстМодуля = ПолучитьТекстМодуля(ТипМодуля, ОбъектСсылка);
			
			// Заполним таблицу областей только верхнего уровня.
			ТаблицаОбластейМодуля = ПолучитьТаблицуОбластейМодуля(ТекстМодуля);
			ТаблицаОбластейВерхнегоУровня = ТаблицаОбластейМодуля.СкопироватьКолонки();
			Для Каждого СтрокаОбласти Из ТаблицаОбластейМодуля Цикл
				// В таблице определена колонка "Родитель", которая не заполнена (области 8.2)
				// или заполнена (области 8.3) корнем дерева значений для всех областей верхнего уровня.
				ОбластьРодитель = СтрокаОбласти.Родитель;
				Если (ОбластьРодитель = Неопределено) ИЛИ (ОбластьРодитель.Родитель = Неопределено) Тогда
					ЗаполнитьЗначенияСвойств(ТаблицаОбластейВерхнегоУровня.Добавить(), СтрокаОбласти);
				КонецЕсли;
			КонецЦикла;
			
			Для Каждого СтрокаЭкспортногоМетодаМодуля Из МассивЭкспортныхМетодовМодуля Цикл
				
				ИмяОбласти = "";
				
				Для Каждого СтрокаОбласти Из ТаблицаОбластейВерхнегоУровня Цикл
					// Если метод принадлежит этой области, запоминаем ее и прерываемся.
					Если СтрокаОбласти.НомерСтрокиНачало < СтрокаЭкспортногоМетодаМодуля.НомерСтрокиНачало
					   И СтрокаОбласти.НомерСтрокиКонец > СтрокаЭкспортногоМетодаМодуля.НомерСтрокиКонец Тогда
						ИмяОбласти = СтрокаОбласти.НаименованиеВРег;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				// Методы из области "ПрограммныйИнтерфейс" можно вызывать всегда,
				// поэтому, если не установлен параметр, то пропускаем их.
				Если (НЕ ДобавитьМетодыИзОбластиПрограммныйИнтерфейс) И (СтрСравнить(ИмяОбласти, ТекстПрограммныйИнтерфейс) = 0) Тогда
					Продолжить;
				КонецЕсли;
				
				ИмяМетода = СтрокаЭкспортногоМетодаМодуля.ИмяМетодаВРег;
				
				ШаблоныПоиска = ШаблоныПоискаПоУмолчанию.Скопировать();
				Для Каждого СтрокаШаблона Из ШаблоныПоиска Цикл
					СтрокаШаблона.Шаблон = СтрШаблон(СтрокаШаблона.Шаблон, ИмяМодуля, ИмяМетода);
				КонецЦикла;
				
				ЭкспортныйМетод = ТаблицаЭкспортныхМетодов.Добавить();
				ЭкспортныйМетод.Объект = ОбъектСсылка;
				ЭкспортныйМетод.ИмяМодуля = ИмяМодуля;
				ЭкспортныйМетод.Подсистемы = МассивПодсистем;
				ЭкспортныйМетод.ПодсистемыВерхнегоУровня = МассивПодсистемВерхнегоУровня;
				ЭкспортныйМетод[ТекстВключатьВКомандныйИнтерфейс] = ВключатьВКомандныйИнтерфейс;
				ЭкспортныйМетод.ИмяМетода = ИмяМетода;
				ЭкспортныйМетод.ОписаниеМетода = СтрокаЭкспортногоМетодаМодуля.ОписаниеМетода;
				ЭкспортныйМетод.НомерСтрокиНачало = СтрокаЭкспортногоМетодаМодуля.НомерСтрокиНачало;
				ЭкспортныйМетод.Область = ИмяОбласти;
				ЭкспортныйМетод.ШаблоныПоиска = ШаблоныПоиска;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТаблицаЭкспортныхМетодов.Индексы.Добавить("Объект");
	ТаблицаЭкспортныхМетодов.Индексы.Добавить("ИмяМодуля");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаЭкспортныхМетодов);
	
	Возврат ТаблицаЭкспортныхМетодов;
	
КонецФункции

// Возвращает таблицу объектов, содержащих экспортные методы,
// полученные функцией ПолучитьТаблицуЭкспортныхМетодовОбщихМодулейИМодулейМенеджеров().
//
// Параметры:
//   ДобавитьМетодыИзОбластиПрограммныйИнтерфейс                  - Булево - флаг добавления методов,
//                                                                  описанных в области "ПрограммныйИнтерфейс".
//   ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс - Булево - флаг добавления методов объектов, входящих
//                                                                  хотя бы в 1 подсистему, включенную в командный интерфейс.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица объектов экспортных методов с колонками:
//     Объект                      - СправочникСсылка.СтруктураКонфигурации - ссылка на объект с экспортным методом.
//     ИмяМодуля                   - Строка - наименование объекта в верхнем регистре.
//     Подсистемы                  - Массив - массив подсистем, в которые входит объект. Элементы массива:
//       СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему.
//     ПодсистемыВерхнегоУровня    - Массив - массив подсистем верхнего уровня, в которые входит объект. Элементы массива:
//       СправочникСсылка.СтруктураКонфигурации - ссылка на подсистему верхнего уровня.
//
Функция ПолучитьТаблицуОбъектовЭкспортныхМетодов(
	ДобавитьМетодыИзОбластиПрограммныйИнтерфейс = Ложь,
	ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс = Ложь)
	
	КлючКонтекста = СтрШаблон("ТаблицаОбъектовЭкспортныхМетодов_%1_%2",
		ДобавитьМетодыИзОбластиПрограммныйИнтерфейс, ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс);
	
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТаблицаЭкспортныхМетодов = ПолучитьТаблицуЭкспортныхМетодовОбщихМодулейИМодулейМенеджеров(
		ДобавитьМетодыИзОбластиПрограммныйИнтерфейс, ДобавитьМетодыОбъектовПодсистемВключенныхВКомандныйИнтерфейс);
	
	ТаблицаОбъектовЭкспортныхМетодов = ТаблицаЭкспортныхМетодов.Скопировать(, "Объект, ИмяМодуля, Подсистемы, ПодсистемыВерхнегоУровня");
	ТаблицаОбъектовЭкспортныхМетодов.Свернуть("Объект, ИмяМодуля, Подсистемы, ПодсистемыВерхнегоУровня");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОбъектовЭкспортныхМетодов);
	
	Возврат ТаблицаОбъектовЭкспортныхМетодов;
	
КонецФункции

// Возвращает таблицу условий "Если ... КонецЕсли" по переданному тексту модуля.
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица условий с колонками:
//     ТекстУсловия     - Строка - текст условия от "Если" до "Тогда".
//     ПозицияЕсли      - Число  - номер символа начала слова "Если".
//     ПозицияТогда     - Число  - номер символа начала слова "Тогда".
//     ПозицияИначеЕсли - Строка - строка номеров символов условия "ИначеЕсли" через запятую.
//     ПозицияИначе     - Число  - номер символа начала слова "Иначе".
//     ПозицияКонецЕсли - Число  - номер символа начала слова "КонецЕсли".
//
Функция ПолучитьТаблицуУсловийЕслиКонецЕсли(ТекстМодуля)
	
	ТаблицаУсловий = Новый ТаблицаЗначений();
	ТаблицаУсловий.Колонки.Добавить("ТекстУсловия");
	ТаблицаУсловий.Колонки.Добавить("ПозицияЕсли");
	ТаблицаУсловий.Колонки.Добавить("ПозицияТогда");
	ТаблицаУсловий.Колонки.Добавить("ПозицияИначеЕсли");
	ТаблицаУсловий.Колонки.Добавить("ПозицияИначе");
	ТаблицаУсловий.Колонки.Добавить("ПозицияКонецЕсли");
	
	ДеревоУсловий = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаУсловий.Колонки Цикл
		ДеревоУсловий.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	ДеревоУсловий.Колонки.Добавить("ЭтоУсловие");
	
	ШаблонПоиска = "^[ \t]*(?:Если|Иначе|КонецЕсли).*";
	
	МассивРезультатов = РегулярныеВыраженияНайти(ТекстМодуля, ШаблонПоиска,, Истина, Истина);
	Если МассивРезультатов = Ложь Тогда
		Возврат ТаблицаУсловий;
	КонецЕсли;
	
	ТекстЕсли = ВРег("Если");
	ТекстТогда = ВРег("Тогда");
	ТекстИначеЕсли = ВРег("ИначеЕсли");
	ТекстИначе = ВРег("Иначе");
	ТекстКонецЕсли = ВРег("КонецЕсли");
	
	ТекстМодуляВРег = ВРег(ТекстМодуля);
	
	ТекущееУсловие = ДеревоУсловий.Строки.Добавить();
	ТекущееУсловие.ЭтоУсловие = Ложь;
	
	Для Каждого ЭлементМассива Из МассивРезультатов Цикл
		
		ПозицияЭлемента = ЭлементМассива.FirstIndex + 1;
		
		ТекстУсловия = СокрЛП(ЭлементМассива.Value);
		ТекстУсловияВРег = ВРег(ТекстУсловия);
		
		Если СтрНачинаетсяС(ТекстУсловияВРег, ТекстЕсли) Тогда
			
			ПозицияЕсли = СтрНайти(ТекстМодуляВРег, ТекстЕсли,, ПозицияЭлемента);
			Если ПозицияЕсли = 0 Тогда
				ПозицияЕсли = ПозицияЭлемента;
			КонецЕсли;
			
			ПозицияУсловия = ПозицияЕсли + СтрДлина(ТекстЕсли);
			
			ПозицияТогда = СтрНайти(ТекстМодуляВРег, ТекстТогда,, ПозицияЕсли);
			Если ПозицияТогда = 0 Тогда
				ПозицияТогда = ПозицияУсловия + ЭлементМассива.Length;
			Иначе
				ТекстУсловия = Сред(ТекстМодуля, ПозицияУсловия, ПозицияТогда - ПозицияУсловия);
			КонецЕсли;
			
			НовоеУсловие = ТекущееУсловие.Строки.Добавить();
			НовоеУсловие.ТекстУсловия = СокрЛП(ТекстУсловия);
			НовоеУсловие.ПозицияЕсли = ПозицияЕсли;
			НовоеУсловие.ПозицияТогда = ПозицияТогда;
			НовоеУсловие.ЭтоУсловие = Истина;
			
			ТекущееУсловие = НовоеУсловие;
			
		ИначеЕсли СтрНачинаетсяС(ТекстУсловияВРег, ТекстИначеЕсли) Тогда
			
			ПозицияИначеЕсли = СтрНайти(ТекстМодуляВРег, ТекстИначеЕсли,, ПозицияЭлемента);
			Если ПозицияИначеЕсли = 0 Тогда
				ПозицияИначеЕсли = ПозицияЭлемента;
			КонецЕсли;
			
			СтрокаПозицийИначеЕсли = ТекущееУсловие.ПозицияИначеЕсли;
			Если СтрокаПозицийИначеЕсли = Неопределено Тогда
				СтрокаПозицийИначеЕсли = Строка(ПозицияИначеЕсли);
			Иначе
				МассивПозицийИначеЕсли = СтрРазделить(СтрокаПозицийИначеЕсли, ",");
				МассивПозицийИначеЕсли.Добавить(ПозицияИначеЕсли);
				СтрокаПозицийИначеЕсли = СтрСоединить(МассивПозицийИначеЕсли, ",");
			КонецЕсли;
			
			ТекущееУсловие.ПозицияИначеЕсли = ПозицияИначеЕсли;
			
		ИначеЕсли СтрНачинаетсяС(ТекстУсловияВРег, ТекстИначе) Тогда
			
			ПозицияИначе = СтрНайти(ТекстМодуляВРег, ТекстИначе,, ПозицияЭлемента);
			Если ПозицияИначе = 0 Тогда
				ПозицияИначе = ПозицияЭлемента;
			КонецЕсли;
			
			ТекущееУсловие.ПозицияИначе = ПозицияИначе;
			
		ИначеЕсли СтрНачинаетсяС(ТекстУсловияВРег, ТекстКонецЕсли) Тогда
			
			ПозицияКонецЕсли = СтрНайти(ТекстМодуляВРег, ТекстКонецЕсли,, ПозицияЭлемента);
			Если ПозицияКонецЕсли = 0 Тогда
				ПозицияКонецЕсли = ПозицияЭлемента;
			КонецЕсли;
			
			ТекущееУсловие.ПозицияКонецЕсли = ПозицияКонецЕсли;
			
			ТекущееУсловие = ТекущееУсловие.Родитель;
			Если ТекущееУсловие = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПараметрыОтбора = Новый Структура("ЭтоУсловие", Истина);
	МассивСтрокУсловий = ДеревоУсловий.Строки.НайтиСтроки(ПараметрыОтбора, Истина);
	
	Для Каждого СтрокаУсловия Из МассивСтрокУсловий Цикл
		
		НовоеУсловие = ТаблицаУсловий.Добавить();
		ЗаполнитьЗначенияСвойств(НовоеУсловие, СтрокаУсловия);
		
	КонецЦикла;
	
	Возврат ТаблицаУсловий;
	
КонецФункции

// Возвращает таблицу циклов "Для ... КонецЦикла" или "Пока ... КонецЦикла" по переданному тексту модуля.
//
// Параметры:
//   ТекстМодуля - Строка - многострочный текст модуля.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица циклов с колонками:
//     ТекстУсловияЦикла  - Строка - текст условия цикла.
//     ПозицияНачалаЦикла - Число  - номер символа начала слова "Для" или "Пока".
//     ПозицияКонцаЦикла  - Число  - номер символа начала слова "КонецЦикла".
//
Функция ПолучитьТаблицуЦиклов(ТекстМодуля)
	
	ТаблицаЦиклов = Новый ТаблицаЗначений();
	ТаблицаЦиклов.Колонки.Добавить("ТекстУсловияЦикла");
	ТаблицаЦиклов.Колонки.Добавить("ПозицияНачалаЦикла");
	ТаблицаЦиклов.Колонки.Добавить("ПозицияКонцаЦикла");
	
	ДеревоЦиклов = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаЦиклов.Колонки Цикл
		ДеревоЦиклов.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	ДеревоЦиклов.Колонки.Добавить("ЭтоЦикл");
	
	ШаблонПоиска = "^[ \t]*(?:Для|Пока|КонецЦикла).*";
	
	МассивРезультатов = РегулярныеВыраженияНайти(ТекстМодуля, ШаблонПоиска,, Истина, Истина);
	Если МассивРезультатов = Ложь Тогда
		Возврат ТаблицаЦиклов;
	КонецЕсли;
	
	ТекстДля = ВРег("Для");
	ТекстПока = ВРег("Пока");
	ТекстЦикл = ВРег("Цикл");
	ТекстКонецЦикла = ВРег("КонецЦикла");
	
	ТекстМодуляВРег = ВРег(ТекстМодуля);
	
	ТекущийЦикл = ДеревоЦиклов.Строки.Добавить();
	ТекущийЦикл.ЭтоЦикл = Ложь;
	
	Для Каждого ЭлементМассива Из МассивРезультатов Цикл
		
		ПозицияЭлемента = ЭлементМассива.FirstIndex + 1;
		
		ТекстЭлемента = СокрЛП(ЭлементМассива.Value);
		ТекстЭлементаВРег = ВРег(ТекстЭлемента);
		
		Если СтрНачинаетсяС(ТекстЭлементаВРег, ТекстДля)
		 ИЛИ СтрНачинаетсяС(ТекстЭлементаВРег, ТекстПока) Тогда
			
			ТекстНачалаЦикла = ?(СтрНачинаетсяС(ТекстЭлементаВРег, ТекстДля), ТекстДля, ТекстПока);
			
			// Ищем повторно, т.к. шаблон РВ предполагает наличие пробелов и символов таб в начале строки.
			ПозицияНачалаЦикла = СтрНайти(ТекстМодуляВРег, ТекстНачалаЦикла,, ПозицияЭлемента);
			Если ПозицияНачалаЦикла = 0 Тогда
				ПозицияНачалаЦикла = ПозицияЭлемента;
			КонецЕсли;
			
			ТекстУсловияЦикла = СокрЛП(ТекстЭлемента);
			
			НовыйЦикл = ТекущийЦикл.Строки.Добавить();
			НовыйЦикл.ТекстУсловияЦикла = ТекстУсловияЦикла;
			НовыйЦикл.ПозицияНачалаЦикла = ПозицияНачалаЦикла;
			НовыйЦикл.ЭтоЦикл = Истина;
			
			ТекущийЦикл = НовыйЦикл;
			
		ИначеЕсли СтрНачинаетсяС(ТекстЭлементаВРег, ТекстКонецЦикла) Тогда
			
			ПозицияКонцаЦикла = СтрНайти(ТекстМодуляВРег, ТекстКонецЦикла,, ПозицияЭлемента);
			Если ПозицияКонцаЦикла = 0 Тогда
				ПозицияКонцаЦикла = ПозицияЭлемента;
			КонецЕсли;
			
			ТекущийЦикл.ПозицияКонцаЦикла = ПозицияКонцаЦикла;
			
			ТекущийЦикл = ТекущийЦикл.Родитель;
			Если ТекущийЦикл = Неопределено Тогда
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПараметрыОтбора = Новый Структура("ЭтоЦикл", Истина);
	МассивСтрокЦикла = ДеревоЦиклов.Строки.НайтиСтроки(ПараметрыОтбора, Истина);
	
	Для Каждого СтрокаЦикла Из МассивСтрокЦикла Цикл
		
		НовыйЦикл = ТаблицаЦиклов.Добавить();
		ЗаполнитьЗначенияСвойств(НовыйЦикл, СтрокаЦикла);
		
	КонецЦикла;
	
	Возврат ТаблицаЦиклов;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСоСправкой

// Возвращает текст справочной информации объекта конфигурации.
// Если объект не имеет справки, то возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, Строка - текст справочной информации.
//
Функция ПолучитьТекстСправочнойИнформации() Экспорт
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.СправочнаяИнформация);
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСРолями

// Возвращает назначение ролей.
//
// Параметры:
//   КореньКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект корня конфигурации.
//                        Если не параметр заполнен, то корень конфигурации будет получен внутри самой функции.
//
// Возвращаемое значение:
//   Структура - структура, хранящая назначение ролей. Ключи:
//     ТолькоДляАдминистраторовСистемы                - Массив - массив имен ролей, предназначенных только
//                                                               для администраторов системы.
//     ТолькоДляПользователейСистемы                  - Массив - массив имен ролей, предназначенных только
//                                                               для пользователей системы.
//     ТолькоДляВнешнихПользователей                  - Массив - массив имен ролей, предназначенных только
//                                                               для внешних пользователей.
//     СовместноДляПользователейИВнешнихПользователей - Массив - массив имен ролей, предназначенных совместно
//                                                               для пользователей и внешних пользователей системы.
//     БазаСкопированаУспешно                         - Булево - флаг, показывающий удалось ли скопировать проверяемую
//                                                               ИБ перед получением назначения ролей.
//     УстановленоCOMСоединение                       - Булево - флаг, показывающий удалось ли установить COM-соединение
//                                                               с проверяемой ИБ перед получением назначения ролей.
//     ВерсияБСП                                      - Строка - версия библиотеки стандартных подсистем.
//     ТекстОшибки                                    - Строка - текст ошибки, если не удалось получить назначение ролей.
//
Функция ПолучитьНазначениеРолей(КореньКонфигурации = Неопределено)
	
	Если КореньКонфигурации = Неопределено Тогда
		КореньКонфигурации = ПолучитьКореньКонфигурации();
	КонецЕсли;
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.НазначениеРолей, КореньКонфигурации);
	
КонецФункции

// Возвращает соответствие стандартных ролей.
// Роль является стандартной, если входит в состав подсистемы "БазоваяФункциональность".
//
// Возвращаемое значение:
//   Соответствие - соответствие стандартных ролей:
//     Ключ     - СправочникСсылка.СтруктураКонфигурации - ссылка на стандартную роль.
//     Значение - Булево                                 - Истина.
//
Функция ПолучитьСтандартныеРоли()
	
	КлючКонтекста = "СтандартныеРоли";
	СтандартныеРоли = Контекст[КлючКонтекста];
	Если СтандартныеРоли <> Неопределено Тогда
		Возврат СтандартныеРоли;
	КонецЕсли;
	
	СтандартныеРоли = Новый Соответствие;
	
	ПодсистемаСсылка = ПолучитьПодсистемуБазоваяФункциональность();
	Если НЕ ПодсистемаСсылка.Пустая() Тогда
		
		ЗапросПоРолям = Новый Запрос;
		ЗапросПоРолям.Текст = "
		|ВЫБРАТЬ
		|	СтруктураКонфигурации.Ссылка
		|ИЗ
		|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
		|ГДЕ
		|	СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
		|	И СтруктураКонфигурации.Подсистемы.Подсистема = &Подсистема
		|	И СтруктураКонфигурации.Расширение = &Расширение";
		
		ЗапросПоРолям.УстановитьПараметр("ТипОбъекта", Перечисления.ТипыОбъектов.Роль);
		ЗапросПоРолям.УстановитьПараметр("Подсистема", ПодсистемаСсылка);
		ЗапросПоРолям.УстановитьПараметр("Расширение", Расширение);
		
		Выборка = ЗапросПоРолям.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			СтандартныеРоли.Вставить(Выборка.Ссылка, Истина);
		КонецЦикла;
		
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, СтандартныеРоли);
	
	Возврат СтандартныеРоли;
	
КонецФункции

// Возвращает флаг, является ли переданная роль стандартной.
// Роль является стандартной, если входит в состав подсистемы "БазоваяФункциональность".
//
// Параметры:
//   ОбъектСсылка - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на роль.
//                  Если не заполнен, то возвращается значение для текущей проверяемой роли.
//
// Возвращаемое значение:
//   Булево - флаг, является ли роль стандартной:
//     Истина - роль является стандартной.
//     Ложь   - роль не является стандартной.
//
Функция ЭтоСтандартнаяРоль(Знач ОбъектСсылка = Неопределено)
	
	ПодсистемаСсылка = ПолучитьПодсистемуБазоваяФункциональность();
	Если ПодсистемаСсылка.Пустая() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ОбъектСсылка = Неопределено Тогда
		ОбъектСсылка = ОбъектПроверкиСсылка;
	КонецЕсли;
	
	СтандартныеРоли = ПолучитьСтандартныеРоли();
	
	Возврат (СтандартныеРоли[ОбъектСсылка] <> Неопределено);
	
КонецФункции

// Возвращает количество ролей в проверяемой конфигурации.
//
// Возвращаемое значение:
//   Число - количество ролей в конфигурации.
//
Функция ПолучитьКоличествоРолей()
	
	КлючКонтекста = "КоличествоРолей";
	КоличествоРолей = Контекст[КлючКонтекста];
	Если КоличествоРолей <> Неопределено Тогда
		Возврат КоличествоРолей;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(СтруктураКонфигурации.Ссылка) КАК КоличествоРолей
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Версия
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|	И СтруктураКонфигурации.ТипОбъекта = &ТипОбъекта
	|	И СтруктураКонфигурации.Расширение = &Расширение";
	
	Запрос.УстановитьПараметр("Версия", Версия);
	Запрос.УстановитьПараметр("ТипОбъекта", Перечисления.ТипыОбъектов.Роль);
	Запрос.УстановитьПараметр("Расширение", Расширение);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	КоличествоРолей = Выборка.КоличествоРолей;
	
	Контекст.Вставить(КлючКонтекста, КоличествоРолей);
	
	Возврат КоличествоРолей;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСПравамиРолей

// Заполняет соответствие прав ролей в переменную общего доступа "СписокПолномочийПоТипу".
//
Процедура ЗаполнитьСписокПолномочий()
	
	СписокПолномочийПоТипу = Новый Соответствие;
	СписокПолномочий = Новый Массив;
	Типы = Перечисления.ТипыОбъектов;
	
	// По следующим типам объектов права не устанавливаются.
	СписокПолномочийПоТипу.Вставить(Типы.Корень, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ВеткаМетаданных, 				СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Подсистема, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОбщийМодуль, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Роль, 							СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОбщийРеквизит, 				СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ПодпискаНаСобытия, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.РегламентноеЗадание, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОпределяемыйТип, 				СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Форма, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.УправляемаяФорма, 				СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Макет, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Картинка, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ПакетXDTO, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.WebСервис, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.HTTPСервис, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.WSСсылка, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Стиль, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ЭлементСтиля, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Язык, 							СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Перечисление, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Реквизит, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.СтандартныйРеквизит, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ТабличнаяЧасть, 				СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.СтандартнаяТабличнаяЧасть, 	СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Графа, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Измерение, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Ресурс, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Значение, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОбщийМакет, 					СписокПолномочий);
	
	СписокПолномочийПоТипу.Вставить(Типы.ФункциональнаяОпция, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ХранилищеНастроек, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Команда, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ГруппаКоманд, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ПараметрФункциональнойОпции, 	СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ПредопределенныйЭлемент, 		СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Параметр, 						СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ШаблонURL, 					СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Просмотр");
	
	СписокПолномочийПоТипу.Вставить(Типы.ОбщаяКоманда, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОбщаяФорма, 					СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.ОбщаяУправляемаяФорма, 		СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Получение");
	СписокПолномочий.Добавить("Установка");
	
	СписокПолномочийПоТипу.Вставить(Типы.ПараметрСеанса, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	
	СписокПолномочийПоТипу.Вставить(Типы.ПланОбмена, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Просмотр");
	
	СписокПолномочийПоТипу.Вставить(Типы.КритерийОтбора, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Использование");
	
	СписокПолномочийПоТипу.Вставить(Типы.Интерфейс, 		СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.Операция, 			СписокПолномочий);
	СписокПолномочийПоТипу.Вставить(Типы.МетодШаблонаURL, 	СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Проведение");
	СписокПолномочий.Добавить("ОтменаПроведения");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ИнтерактивноеПроведение");
	СписокПолномочий.Добавить("ИнтерактивноеПроведениеНеОперативное");
	СписокПолномочий.Добавить("ИнтерактивнаяОтменаПроведения");
	СписокПолномочий.Добавить("ИнтерактивноеИзменениеПроведенных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	
	СписокПолномочийПоТипу.Вставить(Типы.Документ, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Просмотр");
	
	СписокПолномочийПоТипу.Вставить(Типы.ЖурналДокументов, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Использование");
	
	СписокПолномочийПоТипу.Вставить(Типы.Отчет, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Использование");
	
	СписокПолномочийПоТипу.Вставить(Типы.Обработка, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	
	СписокПолномочийПоТипу.Вставить(Типы.ПланВидовХарактеристик, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	СписокПолномочий.Добавить("ИнтерактивнаяАктивация");
	СписокПолномочий.Добавить("Выполнение");
	СписокПолномочий.Добавить("ИнтерактивноеВыполнение");
	
	СписокПолномочийПоТипу.Вставить(Типы.Задача, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	
	СписокПолномочийПоТипу.Вставить(Типы.ПланСчетов, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	
	СписокПолномочийПоТипу.Вставить(Типы.ПланВидовРасчета, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("УправлениеИтогами");
	
	СписокПолномочийПоТипу.Вставить(Типы.РегистрСведений, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("УправлениеИтогами");
	
	СписокПолномочийПоТипу.Вставить(Типы.РегистрНакопления, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("УправлениеИтогами");
	
	СписокПолномочийПоТипу.Вставить(Типы.РегистрБухгалтерии, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Редактирование");
	
	СписокПолномочийПоТипу.Вставить(Типы.РегистрРасчета, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	СписокПолномочий.Добавить("ИнтерактивнаяАктивация");
	СписокПолномочий.Добавить("Старт");
	СписокПолномочий.Добавить("ИнтерактивныйСтарт");
	
	СписокПолномочийПоТипу.Вставить(Типы.БизнесПроцесс, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("Редактирование");
	
	СписокПолномочийПоТипу.Вставить(Типы.Константа, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Чтение");
	СписокПолномочий.Добавить("Добавление");
	СписокПолномочий.Добавить("Изменение");
	СписокПолномочий.Добавить("Удаление");
	СписокПолномочий.Добавить("Просмотр");
	СписокПолномочий.Добавить("ИнтерактивноеДобавление");
	СписокПолномочий.Добавить("Редактирование");
	СписокПолномочий.Добавить("ИнтерактивноеУдаление");
	СписокПолномочий.Добавить("ИнтерактивнаяПометкаУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	СписокПолномочий.Добавить("ИнтерактивноеУдалениеПомеченных");
	СписокПолномочий.Добавить("ВводПоСтроке");
	
	СписокПолномочийПоТипу.Вставить(Типы.Справочник, СписокПолномочий);
	
	
	СписокПолномочий = Новый Массив;
	СписокПолномочий.Добавить("Администрирование");
	СписокПолномочий.Добавить("АдминистрированиеДанных");
	СписокПолномочий.Добавить("ОбновлениеКонфигурацииБазыДанных");
	СписокПолномочий.Добавить("МонопольныйРежим");
	СписокПолномочий.Добавить("АктивныеПользователи");
	СписокПолномочий.Добавить("ЖурналРегистрации");
	СписокПолномочий.Добавить("ТонкийКлиент");
	СписокПолномочий.Добавить("ВебКлиент");
	СписокПолномочий.Добавить("ТолстыйКлиент");
	СписокПолномочий.Добавить("ВнешнееСоединение");
	СписокПолномочий.Добавить("Automation");
	СписокПолномочий.Добавить("РежимВсеФункции");
	СписокПолномочий.Добавить("СохранениеДанныхПользователя");
	СписокПолномочий.Добавить("АдминистрированиеРасширенийКонфигурации");
	СписокПолномочий.Добавить("ИнтерактивноеОткрытиеВнешнихОбработок");
	СписокПолномочий.Добавить("ИнтерактивноеОткрытиеВнешнихОтчетов");
	СписокПолномочий.Добавить("Вывод");
	
	СписокПолномочийПоТипу.Вставить(Типы.Конфигурация, СписокПолномочий);
	
КонецПроцедуры

// Возвращает список полномочий для переданного объекта.
//
// Параметры:
//   ТипОбъекта - ПеречисленияСсылка.ТипыОбъектов - тип объекта, для которого необходимо получить права.
//
// Возвращаемое значение:
//   Массив - список прав для типа объекта.
//
Функция ПолучитьСписокПолномочий(ТипОбъекта)
	
	Возврат СписокПолномочийПоТипу[ТипОбъекта];
	
КонецФункции

// Возвращает права роли, которой является текущий объект конфигурации.
//
// Параметры:
//   ОбъектКонфигурации          - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                                 Если не заполнен, то возвращаются свойства текущего проверяемого объекта.
//   ТолькоОбъектыВерхнегоУровня - Булево - флаг, указывающий, права на какие объекты необходимо получить.
//                                 Если "Истина", то в таблице будут права только на объекты верхнего уровня:
//                                 справочники, документы, регистры и т.д.
//                                 Если "Ложь", то на все объекты, включая подчиненные: реквизиты, ТЧ, команды и т.д.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица прав текущей роли с колонками:
//     Объект  - СправочникСсылка.СтруктураКонфигурации - текущая роль.
//     <Право> - Булево                                 - флаг разрешения конкретного права роли.
//
//  Полный список прав не перечислен, т.к. он может пополняться.
//
Функция ПолучитьПрава(ОбъектКонфигурации = Неопределено, ТолькоОбъектыВерхнегоУровня = Ложь)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = СтрШаблон("Функция_ПолучитьПрава_%1", ТолькоОбъектыВерхнегоУровня);
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТаблицаПрав = ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.Права, ОбъектКонфигурации);
	Если ТаблицаПрав = Неопределено Тогда
		Возврат ТаблицаПрав;
	КонецЕсли;
	
	Если ТолькоОбъектыВерхнегоУровня Тогда
		
		// Получаем массив типов объектов верхнего уровня.
		ТипыОбъектовВерхнегоУровня = ПолучитьТипыОбъектовКонфигурацииВерхнегоУровня();
		
		// Оставляем в таблице прав только права на объекты верхнего уровня.
		Запрос = Новый Запрос;
		Запрос.Текст = "
		|ВЫБРАТЬ
		|	*
		|ПОМЕСТИТЬ вт_ТаблицаПрав
		|ИЗ
		|	&ТаблицаПрав КАК ТаблицаПрав
		|;
		|ВЫБРАТЬ
		|	*
		|ИЗ
		|	вт_ТаблицаПрав
		|ГДЕ
		|	вт_ТаблицаПрав.Объект.ТипОбъекта В (&МассивТипов)";
		
		Запрос.УстановитьПараметр("ТаблицаПрав", ТаблицаПрав);
		Запрос.УстановитьПараметр("МассивТипов", ТипыОбъектовВерхнегоУровня);
		
		ТаблицаПрав = Запрос.Выполнить().Выгрузить();
		
		ТаблицаПрав.Индексы.Добавить("Объект");
		
	КонецЕсли;
	
	ТаблицаПрав.Индексы.Добавить("Чтение");
	ТаблицаПрав.Индексы.Добавить("Удаление");
	
	КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаПрав);
	
	Возврат ТаблицаПрав;
	
КонецФункции

// Выполняет поиск строки с полномочиями объекта и возвращает ее.
// Если строка не найдена, то возвращается структура с пустыми полномочиями.
//
// Параметры:
//   ПраваРоли      - ТаблицаЗначений                        - права роли, полученные функцией ПолучитьПрава().
//   СсылкаНаОбъект - СправочникСсылка.СтруктураКонфигурации - ссылка на роль, права которой необходимо получить.
//
// Возвращаемое значение:
//   СтрокаТаблицыЗначений, Структура - коллекция прав запрашиваемой роли.
//
Функция ПолучитьПраваОбъекта(ПраваРоли, СсылкаНаОбъект)
	
	СтрокаОбъекта = ПраваРоли.Найти(СсылкаНаОбъект, "Объект");
	Если СтрокаОбъекта <> Неопределено Тогда
		Возврат СтрокаОбъекта;
	КонецЕсли;
	
	СтрокаОбъекта = Новый Структура;
	СтрокаОбъекта.Вставить("Объект", СсылкаНаОбъект);
	СтрокаОбъекта.Вставить("Чтение", Ложь);
	СтрокаОбъекта.Вставить("Добавление", Ложь);
	СтрокаОбъекта.Вставить("Изменение", Ложь);
	СтрокаОбъекта.Вставить("Удаление", Ложь);
	СтрокаОбъекта.Вставить("Проведение", Ложь);
	СтрокаОбъекта.Вставить("ОтменаПроведения", Ложь);
	СтрокаОбъекта.Вставить("Просмотр", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеДобавление", Ложь);
	СтрокаОбъекта.Вставить("Редактирование", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивнаяПометкаУдаления", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеСнятиеПометкиУдаления", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеУдалениеПомеченных", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеПроведение", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеПроведениеНеОперативное", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивнаяОтменаПроведения", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеИзменениеПроведенных", Ложь);
	СтрокаОбъекта.Вставить("ВводПоСтроке", Ложь);
	СтрокаОбъекта.Вставить("УправлениеИтогами", Ложь);
	СтрокаОбъекта.Вставить("Использование", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеУдаление", Ложь);
	СтрокаОбъекта.Вставить("Администрирование", Ложь);
	СтрокаОбъекта.Вставить("МонопольныйРежим", Ложь);
	СтрокаОбъекта.Вставить("АктивныеПользователи", Ложь);
	СтрокаОбъекта.Вставить("ЖурналРегистрации", Ложь);
	СтрокаОбъекта.Вставить("ВнешнееСоединение", Ложь);
	СтрокаОбъекта.Вставить("Automation", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеОткрытиеВнешнихОтчетов", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеОткрытиеВнешнихОбработок", Ложь);
	СтрокаОбъекта.Вставить("Получение", Ложь);
	СтрокаОбъекта.Вставить("Установка", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивнаяАктивация", Ложь);
	СтрокаОбъекта.Вставить("Старт", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивныйСтарт", Ложь);
	СтрокаОбъекта.Вставить("Выполнение", Ложь);
	СтрокаОбъекта.Вставить("ИнтерактивноеВыполнение", Ложь);
	СтрокаОбъекта.Вставить("Вывод", Ложь);
	СтрокаОбъекта.Вставить("ОбновлениеКонфигурацииБазыДанных", Ложь);
	
	Возврат СтрокаОбъекта;
	
КонецФункции

// Добавляет право в переданную таблицу прав.
//
// Параметры:
//   ТаблицаПолномочий - ТаблицаЗначений - таблица прав.
//   Полномочие        - Строка - право роли.
//
Процедура ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, Полномочие)
	
	СтрокаПолномочия = ТаблицаПолномочий.Добавить();
	СтрокаПолномочия.Полномочие = Полномочие;
	
КонецПроцедуры

// Возвращает соответствие полномочий ролей.
//
// Возвращаемое значение:
//   Соответствие - соответствие полномочий ролей:
//     Ключ     - Строка   - наименование полномочия роли.
//     Значение - ЛюбойТип - значение полномочия роли.
//
Функция ПолучитьСоответствиеПолномочийРолей()
	
	КлючКонтекста = "СоответствиеПолномочийРолей";
	СоответствиеПолномочийРолей = Контекст[КлючКонтекста];
	Если СоответствиеПолномочийРолей <> Неопределено Тогда
		Возврат СоответствиеПолномочийРолей;
	КонецЕсли;
	
	СоответствиеПолномочийРолей = Новый Соответствие;
	
	ТипыОбъектов = Перечисления.ТипыОбъектов;
	
	СоответствиеТипов = Новый Соответствие;
	СоответствиеТипов.Вставить(ТипыОбъектов.ПланОбмена, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.Справочник, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.Документ, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.ПланВидовХарактеристик, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.ПланСчетов, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.ПланВидовРасчета, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.РегистрСведений, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.РегистрНакопления, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.РегистрБухгалтерии, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.РегистрРасчета, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.БизнесПроцесс, Истина);
	СоответствиеТипов.Вставить(ТипыОбъектов.Задача, Истина);
	СоответствиеПолномочийРолей["СоответствиеТипов"] = СоответствиеТипов;
	
	
	ТаблицаРазрешенныхПолномочий = Новый ТаблицаЗначений;
	ТаблицаРазрешенныхПолномочий.Колонки.Добавить("Полномочие");
	
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Просмотр");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ВводПоСтроке");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Добавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Изменение");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеДобавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Редактирование");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивнаяПометкаУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеСнятиеПометкиУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Проведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеПроведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивнаяОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивнаяАктивация");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Старт");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивныйСтарт");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "Выполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеВыполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "УправлениеИтогами");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеПроведениеНеОперативное");
	ДобавитьПолномочиеВТаблицу(ТаблицаРазрешенныхПолномочий, "ИнтерактивноеИзменениеПроведенных");
	
	ТаблицаРазрешенныхПолномочий.Индексы.Добавить("Полномочие");
	
	СоответствиеПолномочийРолей["ТаблицаРазрешенныхПолномочий"] = ТаблицаРазрешенныхПолномочий;
	
	
	ТаблицаЗапрещенныхПолномочий = Новый ТаблицаЗначений;
	ТаблицаЗапрещенныхПолномочий.Колонки.Добавить("Полномочие");
	
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Добавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Изменение");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеДобавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Редактирование");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивнаяПометкаУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеСнятиеПометкиУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеУдалениеПомеченных");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеУдалениеПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Проведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеПроведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивнаяОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивнаяАктивация");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Старт");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивныйСтарт");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "Выполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеВыполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "УправлениеИтогами");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеПроведениеНеОперативное");
	ДобавитьПолномочиеВТаблицу(ТаблицаЗапрещенныхПолномочий, "ИнтерактивноеИзменениеПроведенных");

	ТаблицаЗапрещенныхПолномочий.Индексы.Добавить("Полномочие");
	
	СоответствиеПолномочийРолей["ТаблицаЗапрещенныхПолномочий"] = ТаблицаЗапрещенныхПолномочий;
	
	
	ТаблицаПолномочий = Новый ТаблицаЗначений;
	ТаблицаПолномочий.Колонки.Добавить("Полномочие");
	
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Добавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Изменение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеДобавление");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Редактирование");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивнаяПометкаУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеСнятиеПометкиУдаления");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеУдалениеПомеченных");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеУдалениеПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Проведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеПроведение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивнаяОтменаПроведения");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивнаяАктивация");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Старт");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивныйСтарт");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Выполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеВыполнение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "УправлениеИтогами");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеПроведениеНеОперативное");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "ИнтерактивноеИзменениеПроведенных");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Чтение");
	ДобавитьПолномочиеВТаблицу(ТаблицаПолномочий, "Удаление");
	
	ТаблицаПолномочий.Индексы.Добавить("Полномочие");
	
	СоответствиеПолномочийРолей["ТаблицаПолномочий"] = ТаблицаПолномочий;
	
	
	СоответствиеПолномочийРолей["ПолномочияСсылочногоТипа"] = Новый Структура("ВводПоСтроке");
	СоответствиеПолномочийРолей["ПолномочиеПросмотра"] = Новый Структура("Просмотр");
	
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияПланаОбмена"] = Новый Структура("Добавление, Изменение, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ИнтерактивноеУдалениеПомеченных");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияДокумента"] = Новый Структура("Добавление, Изменение, Проведение, ОтменаПроведения, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ИнтерактивноеУдалениеПомеченных, ИнтерактивноеПроведение, ИнтерактивноеПроведениеНеОперативное, ИнтерактивнаяОтменаПроведения, ИнтерактивноеИзменениеПроведенных");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияСправочникаИПланов"] = Новый Структура("Добавление, Изменение, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ИнтерактивноеУдалениеПомеченных, ИнтерактивноеУдалениеПредопределенныхДанных, ИнтерактивнаяПометкаУдаленияПредопределенныхДанных, ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных, ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияБизнесПроцесса"] = Новый Структура("Добавление, Изменение, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ИнтерактивноеУдалениеПомеченных, ИнтерактивнаяАктивация, Старт, ИнтерактивныйСтарт");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияЗадач"] = Новый Структура("Добавление, Изменение, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ИнтерактивноеУдалениеПомеченных, ИнтерактивнаяАктивация, Выполнение, ИнтерактивноеВыполнение");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияРегистров"] = Новый Структура("Изменение, Редактирование, УправлениеИтогами");
	СоответствиеПолномочийРолей["ЗапрещенныеПолномочияРегистраРасчета"] = Новый Структура("Изменение, Редактирование");
	СоответствиеПолномочийРолей["ЗапрещенныеИнтерактивныеПолномочияСправочникаИПланов"] = Новый Структура("ИнтерактивноеУдалениеПомеченных, ИнтерактивноеУдалениеПредопределенныхДанных, ИнтерактивнаяПометкаУдаленияПредопределенныхДанных, ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных, ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	СоответствиеПолномочийРолей["ЗапрещенныеИнтерактивныеПолномочияДокументаБизнесПроцессаЗадачи"] = Новый Структура("ИнтерактивноеУдалениеПомеченных");
	
	СоответствиеПолномочийРолей["РазрешенныеПолномочияСправочникаИПланов"] = Новый Структура("Добавление, Изменение, Просмотр, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ВводПоСтроке");
	СоответствиеПолномочийРолей["РазрешенныеПолномочияДокумента"] = Новый Структура("Добавление, Изменение, Проведение, ОтменаПроведения, Просмотр, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ВводПоСтроке, ИнтерактивноеПроведение, ИнтерактивнаяОтменаПроведения, ИнтерактивноеПроведениеНеОперативное, ИнтерактивноеИзменениеПроведенных");
	СоответствиеПолномочийРолей["РазрешенныеПолномочияБизнесПроцесса"] = Новый Структура("Добавление, Изменение, Просмотр, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ВводПоСтроке, ИнтерактивнаяАктивация, Старт, ИнтерактивныйСтарт");
	СоответствиеПолномочийРолей["РазрешенныеПолномочияЗадач"] = Новый Структура("Просмотр, Добавление, Изменение, Просмотр, ИнтерактивноеДобавление, Редактирование, ИнтерактивнаяПометкаУдаления, ИнтерактивноеСнятиеПометкиУдаления, ВводПоСтроке, ИнтерактивнаяАктивация, Выполнение, ИнтерактивноеВыполнение");
	СоответствиеПолномочийРолей["РазрешенныеПолномочияРегистров"] = Новый Структура("Изменение, Просмотр, Редактирование, УправлениеИтогами");
	СоответствиеПолномочийРолей["РазрешенныеПолномочияРегистраРасчета"] = Новый Структура("Изменение, Просмотр, Редактирование");
	
	Контекст.Вставить(КлючКонтекста, СоответствиеПолномочийРолей);
	
	Возврат СоответствиеПолномочийРолей;
	
КонецФункции

// Возвращает таблицу ограничений доступа (RLS) текущей роли ко всем объектам.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается значение свойства текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ограничений доступа текущей роли. Колонки:
//     Объект      - СправочникСсылка.СтруктураКонфигурации - объект метаданных, на который наложено ограничение доступа.
//     Ограничение - Строка                                 - код ограничения доступа.
//     Поле        - Строка                                 - поле объекта, на которое наложено ограничение доступа.
//     Право       - Строка                                 - право роли, на которое наложено ограничение доступа.
//
Функция ПолучитьОграниченияДоступа(ОбъектКонфигурации = Неопределено)
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.ОграниченияДоступа, ОбъектКонфигурации);
	
КонецФункции

// Возвращает таблицу ролей и обработок, на которые роли дают права.
// Функция используется в правиле проверки "Проверка прав ролей на обработки".
// При вызове функции из правила проверки для роли, данные накапливаются в таблице.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица прав ролей. Колонки:
//     РольИмя      - Строка                                 - имя роли.
//     РольСсылка   - СправочникСсылка.СтруктураКонфигурации - ссылка на роль.
//     ОбъектСсылка - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//
Функция ПолучитьТаблицуПравРолейНаОбработки()
	
	КлючКонтекста = "ТаблицаПравРолейНаОбработки";
	ТаблицаПравРолейНаОбработки = Контекст[КлючКонтекста];
	Если ТаблицаПравРолейНаОбработки <> Неопределено Тогда
		Возврат ТаблицаПравРолейНаОбработки;
	КонецЕсли;
	
	ТаблицаПравРолейНаОбработки = Новый ТаблицаЗначений;
	ТаблицаПравРолейНаОбработки.Колонки.Добавить("РольИмя");
	ТаблицаПравРолейНаОбработки.Колонки.Добавить("РольСсылка");
	ТаблицаПравРолейНаОбработки.Колонки.Добавить("ОбъектСсылка");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаПравРолейНаОбработки);
	
	Возврат ТаблицаПравРолейНаОбработки;
	
КонецФункции

// Устанавливает таблицу прав ролей в контекст проверки.
//
Процедура УстановитьТаблицуПравРолейНаОбработки(ТаблицаПравРолейНаОбработки)
	
	КлючКонтекста = "ТаблицаПравРолейНаОбработки";
	Контекст.Вставить(КлючКонтекста, ТаблицаПравРолейНаОбработки);
	
КонецПроцедуры

// Возвращает таблицу ролей, команд и их родительских объектов, на которые роли дают права.
// Функция используется в правиле проверки "Проверка прав ролей на команды".
// При вызове функции из правила проверки для роли, данные накапливаются в таблице.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица прав ролей. Колонки:
//     Роль                - СправочникСсылка.СтруктураКонфигурации - ссылка на роль.
//     Команда             - СправочникСсылка.СтруктураКонфигурации - ссылка на команду.
//     ПраваКоманды        - Массив                                 - массив прав на команду.
//     ОбъектКоманды       - СправочникСсылка.СтруктураКонфигурации - ссылка на родительский объект команды.
//     ПраваОбъектаКоманды - Массив                                 - массив прав на родительский объект команды.
//
Функция ПолучитьТаблицуПравРолейНаКоманды()
	
	КлючКонтекста = "ТаблицаПравРолейНаКоманды";
	ТаблицаПравРолейНаКоманды = Контекст[КлючКонтекста];
	Если ТаблицаПравРолейНаКоманды <> Неопределено Тогда
		Возврат ТаблицаПравРолейНаКоманды;
	КонецЕсли;
	
	ТаблицаПравРолейНаКоманды = Новый ТаблицаЗначений;
	ТаблицаПравРолейНаКоманды.Колонки.Добавить("Роль");
	ТаблицаПравРолейНаКоманды.Колонки.Добавить("Команда");
	ТаблицаПравРолейНаКоманды.Колонки.Добавить("ПраваКоманды");
	ТаблицаПравРолейНаКоманды.Колонки.Добавить("ОбъектКоманды");
	ТаблицаПравРолейНаКоманды.Колонки.Добавить("ПраваОбъектаКоманды");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаПравРолейНаКоманды);
	
	Возврат ТаблицаПравРолейНаКоманды;
	
КонецФункции

// Устанавливает таблицу прав ролей в контекст проверки.
//
Процедура УстановитьТаблицуПравРолейНаКоманды(ТаблицаПравРолейНаКоманды)
	
	КлючКонтекста = "ТаблицаПравРолейНаКоманды";
	Контекст.Вставить(КлючКонтекста, ТаблицаПравРолейНаКоманды);
	
КонецПроцедуры

// Возвращает флаг, дает ли роль права хотя бы на один объект конфигурации.
//
// Параметры:
//   ОбъектКонфигурации          - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                                 Если не заполнен, то проверяются права текущей роли.
//   ТолькоОбъектыВерхнегоУровня - Булево - флаг, указывающий, права на какие объекты необходимо проверить.
//                                 Если "Истина", то в таблице будут проверяться права только на объекты верхнего уровня:
//                                 справочники, документы, регистры и т.д.
//                                 Если "Ложь", то на все объекты, включая подчиненные: реквизиты, ТЧ, команды и т.д.
//
// Возвращаемое значение:
//   Булево - флаг, дает ли роль права хотя бы на один объект конфигурации.
//
Функция РольДаетПраваНаОбъектыМетаданных(ОбъектКонфигурации = Неопределено, ТолькоОбъектыВерхнегоУровня = Истина)
	
	НаименованиеОбъекта = ?(ОбъектКонфигурации = Неопределено, ОбъектПроверкиНаименование, Строка(ОбъектКонфигурации));
	
	КлючКонтекста = СтрШаблон("РольДаетПраваНаОбъектыМетаданных_%1_%2", НаименованиеОбъекта, ТолькоОбъектыВерхнегоУровня);
	Результат = Контекст[КлючКонтекста];
	Если Результат <> Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТаблицаПрав = ПолучитьПрава(ОбъектКонфигурации, ТолькоОбъектыВерхнегоУровня);
	Если ТаблицаПрав = Неопределено Тогда
		ТаблицаПрав = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Результат = (ТаблицаПрав.Найти(Истина) <> Неопределено);
	
	Контекст.Вставить(КлючКонтекста, Результат);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПроверкиОрфографии

// Очищает все ошибки, обнаруженные при проверке орфографии.
//
Процедура ОчиститьОшибкиОрфографии()
	
	ТаблицаОшибокОрфографии.Очистить();
	
КонецПроцедуры

// Проверяет переданный текст на орфографические ошибки.
// Совместно с текстом могут быть переданы дополнительные реквизиты, характеризующие место обнаруженной ошибки.
// Орфографические ошибки будут записаны в переменную Ядра "ТаблицаОшибокОрфографии".
//
// Параметры:
//   ТекстДляПроверки - Строка               - многострочный текст.
//   МестоПроверки    - Строка, Неопределено - место обнаружения ошибки.
//   Дополнительно    - Строка, Неопределено - дополнительное место обнаружения ошибки.
//
Процедура ПроверитьОрфографию(Знач ТекстДляПроверки, МестоПроверки = Неопределено, Дополнительно = Неопределено)
	
	Если ПустаяСтрока(ТекстДляПроверки) Тогда
		Возврат;
	КонецЕсли;
	
	СоответствиеСлов = ?(РазбиватьСвязныеСлова, СоответствиеСвязныхСлов, СоответствиеОтдельныхСлов);
	
	ТекстДляПроверки = ПолучитьТекстМодуляДляПроверкиОрфографии(ТекстДляПроверки);
	
	Проверка.ПроверитьПравописание(ТекстДляПроверки, ТаблицаОшибокОрфографии, ВерныеСлова, СоответствиеСлов,
		МестоПроверки, Дополнительно, РазбиватьСвязныеСлова);
	
КонецПроцедуры

// Возвращает таблицу с обнаруженными ошибками орфографии с момента последней очистки ошибок орфографии.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица орфографических ошибок с колонками:
//     Текст         - Строка               - слово, содержащее орфографическую ошибку.
//     НомерСтроки   - Число                - номер строки с ошибкой в многострочном тексте.
//     МестоПроверки - Строка, Неопределено - место обнаружения ошибки.
//     Дополнительно - Строка, Неопределено - дополнительное место обнаружения ошибки.
//
Функция ПолучитьОшибкиОрфографии()
	
	Возврат ТаблицаОшибокОрфографии.Скопировать();
	
КонецФункции

// Выполняет начальную инициализацию переменных для проверки орфографии.
//
Процедура ИнициализироватьПроверкуОрфографии()
	
	ТаблицаОшибокОрфографии = Новый ТаблицаЗначений;
	ТаблицаОшибокОрфографии.Колонки.Добавить("Текст");
	ТаблицаОшибокОрфографии.Колонки.Добавить("НомерСтроки");
	ТаблицаОшибокОрфографии.Колонки.Добавить("МестоПроверки");
	ТаблицаОшибокОрфографии.Колонки.Добавить("Дополнительно");
	
	РазбиватьСвязныеСлова = Ложь;
	ВерныеСлова = Неопределено;
	СоответствиеСвязныхСлов = Новый Соответствие;
	СоответствиеОтдельныхСлов = Новый Соответствие;
	
	ШаблонЗаменыДляПроверкиОрфографии = "[\t0-9.,;:?!\-+*/\\%=<>[\](){}""'|~@#$^&_«»—№―`‒∑−�”®„““”•–±… ☺≤≥☼¦]";
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСДополнениями

// Заполняет соответствие ТипыОбъектовМетаданных, устанавливая Истина для тех типов объектов,
// которые отображают типы объектов метаданных.
//
Процедура ЗаполнитьТипыОбъектовМетаданных()
	
	Если ЗначениеЗаполнено(ТипыОбъектовМетаданных) Тогда
		Возврат;
	КонецЕсли;
	
	ТипыОбъектовМетаданных = Новый Соответствие;
	Типы = Перечисления.ТипыОбъектов;
	
	ТипыОбъектовМетаданных.Вставить(Типы.HTTPСервис,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.WebСервис,              Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.WSСсылка,               Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.БизнесПроцесс,          Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ВеткаМетаданных,        Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Документ,               Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ЖурналДокументов,       Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Задача,                 Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Интерфейс,              Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Картинка,               Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Константа,              Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Конфигурация,           Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.КритерийОтбора,         Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Обработка,              Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ОбщаяФорма,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ОбщийМакет,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ОбщийМодуль,            Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ОбщийРеквизит,          Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ОпределяемыйТип,        Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Отчет,                  Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПакетXDTO,              Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПараметрСеанса,         Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Перечисление,           Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПланВидовРасчета,       Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПланВидовХарактеристик, Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПланОбмена,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПланСчетов,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ПодпискаНаСобытия,      Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Подсистема,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.РегистрБухгалтерии,     Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.РегистрНакопления,      Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.РегистрРасчета,         Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.РегистрСведений,        Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.РегламентноеЗадание,    Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Роль,                   Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Справочник,             Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Стиль,                  Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.ЭлементСтиля,           Истина);
	ТипыОбъектовМетаданных.Вставить(Типы.Язык,                   Истина);
	
КонецПроцедуры

// Запускает проверку с помощью дополнения и записывает ошибки в таблицу "НайденныеОшибки".
//
Процедура ЗапуститьДополнение() Экспорт
	
	ЗаполнитьТипыОбъектовМетаданных();
	
	// Определим ТекущийОбъектМетаданных.
	ТекущийОбъектМетаданных = ОбъектПроверкиСсылка;
	Пока Истина Цикл
		ТекущийОбъектТип = ТекущийОбъектМетаданных.ТипОбъекта;
		Если ТипыОбъектовМетаданных[ТекущийОбъектТип] = Истина Тогда
			Прервать;
		КонецЕсли;
		
		ТекущийОбъектРодитель = ТекущийОбъектМетаданных.Родитель;
		Если ТекущийОбъектРодитель.Пустая() Тогда
			Прервать;
		КонецЕсли;
		
		ТекущийОбъектМетаданных = ТекущийОбъектРодитель;
	КонецЦикла;
	
	// Определим ТекущийОтветственный.
	ОбъектРодитель = ПолучитьОбъектПоНаследству(ОбъектПроверкиСсылка);
	ТекущийОтветственный = ОбъектРодитель.Ответственный;
	
	Соединитель = Обработки.СоединительСДополнением.Создать();
	
	// Устанавливаем контекст проверки.
	Соединитель.Версия = Версия;
	Соединитель.Конфигурация = Версия.Владелец;
	Соединитель.МинимальнаяКритичность = 0;
	Соединитель.ПравилоДляПроверки = ТекущееПравило;
	Соединитель.ОтветственныйЗаОбъект = ТекущийОтветственный;
	Соединитель.ОбъектМетаданныхОбъекта = ТекущийОбъектМетаданных;
	Соединитель.Ядро = ЭтотОбъект;
	
	// Выполняем проверку дополнением.
	Соединитель.ВыполнитьПроверку(ОбъектПроверкиСсылка, ТекущееПравило.Дополнение);
	Для Каждого Недочет Из Соединитель.ЖурналПроверкиДополнением Цикл
		
		Если РегистрироватьВТаблице = Истина Тогда
			НоваяЗаписьРегистрации = НайденныеОшибки.Добавить();
			НоваяЗаписьРегистрации.Ключ = Строка(НомерПроверки);
		Иначе
			НоваяЗаписьРегистрации = ОшибкиВОбъекте.Добавить();
		КонецЕсли;
		
		НоваяЗаписьРегистрации.Объект           = ОбъектПроверкиСсылка;
		НоваяЗаписьРегистрации.Правило          = ТекущееПравило;
		НоваяЗаписьРегистрации.Номер            = НомерПроверки;
		НоваяЗаписьРегистрации.Ответственный    = Недочет.Ответственный;
		НоваяЗаписьРегистрации.МестоОбнаружения = Строка(Недочет.ОбъектМетаданных);
		// Максимальная длина реквизита "Уточнение" РС "НайденныеОшибки" - 999 символов.
		НоваяЗаписьРегистрации.Уточнение        = Лев(Недочет.Комментарий, 999);
		
		НомерПроверки = НомерПроверки + 1;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСКоманднымИнтерфейсом

// Возвращает дерево значений со сведениями о командном интерфейсе.
// Свойство "КомандныйИнтерфейс" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса с колонками:
//     Свойство - Строка   - наименование свойства командного интерфейса.
//     Значение - ЛюбойТип - значение свойства командного интерфейса.
//
Функция ПолучитьОбъектКомандногоИнтерфейса()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.КомандныйИнтерфейс);
	
КонецФункции

// Возвращает дерево значений со сведениями о командном интерфейсе.
// Свойство "КомандныйИнтерфейс" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса с колонками:
//     Свойство - Строка   - наименование свойства командного интерфейса.
//     Значение - ЛюбойТип - значение свойства командного интерфейса.
//
Функция ПолучитьКомандныйИнтерфейс() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьКомандныйИнтерфейс";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектКомандногоИнтерфейса = ПолучитьОбъектКомандногоИнтерфейса();
	Если ОбъектКомандногоИнтерфейса = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектКомандногоИнтерфейса.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив подсистем, для которых настроена видимость в командном интерфейсе.
//
// Возвращаемое значение:
//   Массив - массив подсистем. Элементы массива:
//     СтрокаДереваЗначений - строка дерева командного интерфейса, возвращаемого функцией ПолучитьКомандныйИнтерфейс().
//
Функция ПолучитьВидимостьПодсистемКомандногоИнтерфейса()
	
	КлючЗначенияКэша = "Функция_ПолучитьВидимостьПодсистемКомандногоИнтерфейса";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	МассивПодсистем = Новый Массив;
	
	КомандныйИнтерфейс = ПолучитьКомандныйИнтерфейс();
	Если КомандныйИнтерфейс = Неопределено Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, МассивПодсистем);
		Возврат МассивПодсистем;
	КонецЕсли;
	
	СтрокаВидимостиПодсистем = КомандныйИнтерфейс.Строки.Найти("ВидимостьПодсистем");
	Если СтрокаВидимостиПодсистем = Неопределено Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, МассивПодсистем);
		Возврат МассивПодсистем;
	КонецЕсли;
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Значение", "Подсистема");
	
	МассивПодсистем = СтрокаВидимостиПодсистем.Строки.НайтиСтроки(СтруктураОтбора);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, МассивПодсистем);
	
	Возврат МассивПодсистем;
	
КонецФункции

// Возвращает дерево значений со сведениями о командном интерфейсе основного раздела.
// Свойство "КомандныйИнтерфейсОсновногоРаздела" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса основного раздела с колонками:
//     Свойство - Строка   - наименование свойства командного интерфейса основного раздела.
//     Значение - ЛюбойТип - значение свойства командного интерфейса основного раздела.
//
Функция ПолучитьОбъектКомандногоИнтерфейсаОсновногоРаздела()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.КомандныйИнтерфейсОсновногоРаздела);
	
КонецФункции

// Возвращает дерево значений со сведениями о командном интерфейсе основного раздела.
// Свойство "КомандныйИнтерфейсОсновногоРаздела" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево командного интерфейса основного раздела с колонками:
//     Свойство - Строка   - наименование свойства командного интерфейса основного раздела.
//     Значение - ЛюбойТип - значение свойства командного интерфейса основного раздела.
//
Функция ПолучитьКомандныйИнтерфейсОсновногоРаздела() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьКомандныйИнтерфейсОсновногоРаздела";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектКомандногоИнтерфейсаОсновногоРаздела = ПолучитьОбъектКомандногоИнтерфейсаОсновногоРаздела();
	Если ОбъектКомандногоИнтерфейсаОсновногоРаздела = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектКомандногоИнтерфейсаОсновногоРаздела.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив команд, для которых настроена видимость в командном интерфейсе основного раздела.
//
// Возвращаемое значение:
//   Массив - массив команд. Элементы массива:
//     СтрокаДереваЗначений - строка дерева командного интерфейса основного раздела,
//                            возвращаемого функцией ПолучитьКомандныйИнтерфейсОсновногоРаздела().
//
Функция ПолучитьВидимостьКомандКомандногоИнтерфейсаОсновногоРаздела()
	
	КлючЗначенияКэша = "Функция_ПолучитьВидимостьКомандКомандногоИнтерфейсаОсновногоРаздела";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	МассивКоманд = Новый Массив;
	
	КомандныйИнтерфейсОсновногоРаздела = ПолучитьКомандныйИнтерфейсОсновногоРаздела();
	Если КомандныйИнтерфейсОсновногоРаздела = Неопределено Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, МассивКоманд);
		Возврат МассивКоманд;
	КонецЕсли;
	
	СтрокаВидимостиКоманд = КомандныйИнтерфейсОсновногоРаздела.Строки.Найти("ВидимостьКоманд");
	Если СтрокаВидимостиКоманд = Неопределено Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, МассивКоманд);
		Возврат МассивКоманд;
	КонецЕсли;
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Значение", "Команда");
	
	МассивКоманд = СтрокаВидимостиКоманд.Строки.НайтиСтроки(СтруктураОтбора);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, МассивКоманд);
	
	Возврат МассивКоманд;
	
КонецФункции

// Возвращает дерево значений со сведениями о рабочей области начальной страницы.
// Свойство "РабочаяОбластьНачальнойСтраницы" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево рабочей области начальной страницы с колонками:
//     Свойство - Строка   - наименование свойства рабочей области начальной страницы.
//     Значение - ЛюбойТип - значение свойства рабочей области начальной страницы.
//
Функция ПолучитьОбъектРабочейОбластиНачальнойСтраницы()
	
	Возврат ПолучитьСоставноеСвойство(ИдентификаторыСодержанияОбъектов.РабочаяОбластьНачальнойСтраницы);
	
КонецФункции

// Возвращает дерево значений со сведениями о рабочей области начальной страницы.
// Свойство "РабочаяОбластьНачальнойСтраницы" есть только у объекта (корня) конфигурации с типом "Конфигурация".
// Для остальных объектов возвращается Неопределено.
//
// Возвращаемое значение:
//   Неопределено, ДеревоЗначений - дерево рабочей области начальной страницы с колонками:
//     Свойство - Строка   - наименование свойства рабочей области начальной страницы.
//     Значение - ЛюбойТип - значение свойства рабочей области начальной страницы.
//
Функция ПолучитьРабочуюОбластьНачальнойСтраницы() Экспорт
	
	КлючЗначенияКэша = "Функция_ПолучитьРабочуюОбластьНачальнойСтраницы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	ОбъектРабочейОбластиНачальнойСтраницы = ПолучитьОбъектРабочейОбластиНачальнойСтраницы();
	Если ОбъектРабочейОбластиНачальнойСтраницы = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = ОбъектРабочейОбластиНачальнойСтраницы.Скопировать();
	КэшЗначений.Вставить(КлючЗначенияКэша, Результат);
	
	Возврат Результат;
	
КонецФункции

// Возвращает массив форм, для которых настроена видимость в рабочей области начальной страницы.
//
// Возвращаемое значение:
//   Массив - массив форм. Элементы массива:
//     СтрокаДереваЗначений - строка дерева рабочей области начальной страницы,
//                            возвращаемого функцией ПолучитьРабочуюОбластьНачальнойСтраницы().
//
Функция ПолучитьВидимостьФормРабочейОбластиНачальнойСтраницы()
	
	КлючЗначенияКэша = "Функция_ПолучитьВидимостьФормРабочейОбластиНачальнойСтраницы";
	ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
	Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;
	
	МассивФорм = Новый Массив;
	
	РабочаяОбластьНачальнойСтраницы = ПолучитьРабочуюОбластьНачальнойСтраницы();
	Если РабочаяОбластьНачальнойСтраницы = Неопределено Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, МассивФорм);
		Возврат МассивФорм;
	КонецЕсли;
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Значение", "Форма");
	
	МассивФорм = РабочаяОбластьНачальнойСтраницы.Строки.НайтиСтроки(СтруктураОтбора, Истина);
	
	КэшЗначений.Вставить(КлючЗначенияКэша, МассивФорм);
	
	Возврат МассивФорм;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаКПроверке

Процедура УстановитьКонтекстРасширения(РасширениеДляПроверки) Экспорт
	
	Расширение = РасширениеДляПроверки;
	ОбъектПроверкиЭтоРасширение = ЗначениеЗаполнено(Расширение);
	
КонецПроцедуры

// Устанавливает необходимое окружение для проверки версии.
//
// Параметры:
//   ВерсияПроверки - СправочникСсылка.Версии - версия проверяемой конфигурации.
//
Процедура УстановитьКонтекстВерсии(ВерсияПроверки) Экспорт
	
	// Устанавливаем версию.
	Версия = ВерсияПроверки;
	
	// Заполняем уточнения правил проверки.
	ЗапросПоУточнениям = Новый Запрос;
	ЗапросПоУточнениям.Текст = "
	|ВЫБРАТЬ
	|	УточнениеПроверок.СписокОбъектовДляПроверки КАК Список,
	|	УточнениеПроверок.Правило КАК Правило
	|ИЗ
	|	РегистрСведений.УточнениеПроверок КАК УточнениеПроверок
	|ГДЕ
	|	УточнениеПроверок.Конфигурация = &Конфигурация";
	
	ЗапросПоУточнениям.УстановитьПараметр("Конфигурация", Версия.Владелец);
	
	ВыборкаУточнений = ЗапросПоУточнениям.Выполнить().Выбрать();
	УточненияПроверок = Новый Соответствие;
	
	Пока ВыборкаУточнений.Следующий() Цикл
		СписокУточнений = ВыборкаУточнений.Список.Получить();
		Если СписокУточнений = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если СписокУточнений.Количество() = 0 Тогда
			Уточнения = Неопределено;
		Иначе
			Уточнения = Новый Соответствие;
			Для Каждого Уточнение Из СписокУточнений Цикл
				Уточнения.Вставить(Уточнение.Значение, Истина);
			КонецЦикла;
		КонецЕсли;
		
		УточненияПроверок.Вставить(ВыборкаУточнений.Правило, Уточнения);
	КонецЦикла;
	
	Контекст = Новый Соответствие;
	
КонецПроцедуры

// Устанавливает необходимое окружение для проверки объекта.
//
// Параметры:
//   ВыборкаОбъекта        - ВыборкаИзРезультатаЗапроса - выборка из запроса с полями:
//     Ссылка             - СправочникСсылка.СтруктураКонфигурации - ссылка на проверяемый объект.
//     Код                - Число                                  - код объекта в справочнике.
//     Наименование       - Строка                                 - наименование объекта.
//     ТипОбъекта         - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//     Путь               - Строка                                 - полный путь к объекту.
//     Родитель           - СправочникСсылка.СтруктураКонфигурации - ссылка на родителя проверяемого объекта.
//     РодительТипОбъекта - ПеречислениеСсылка.ТипыОбъектов        - тип объекта родителя проверяемого объекта.
//
Процедура УстановитьКонтекстОбъекта(ВыборкаОбъекта) Экспорт
	
	ОбъектСсылка = ВыборкаОбъекта.Ссылка;
	Если ОбъектПроверкиСсылка = ОбъектСсылка Тогда
		Возврат;
	КонецЕсли;
	
	КэшЗначений = Новый Соответствие;
	
	Объект											 = ОбъектСсылка;
	ОбъектПроверкиСсылка							 = ОбъектСсылка;
	ОбъектПроверкиКод								 = ВыборкаОбъекта.Код;
	ОбъектПроверкиНаименование						 = ВыборкаОбъекта.Наименование;
	ОбъектПроверкиТипОбъекта						 = ВыборкаОбъекта.ТипОбъекта;
	ОбъектПроверкиПуть								 = ВыборкаОбъекта.Путь;
	ОбъектПроверкиРодитель							 = ВыборкаОбъекта.Родитель;
	ОбъектПроверкиРодительТипОбъекта				 = ВыборкаОбъекта.РодительТипОбъекта;
	ОбъектПроверкиПринадлежностьОбъекта				 = ПолучитьПринадлежностьОбъектаРасширения();
	ОбъектПроверкиЭтоЗаимствованныйОбъектРасширения	 = (ОбъектПроверкиПринадлежностьОбъекта = "Заимствованный");
	
КонецПроцедуры

// Устанавливает режим регистрации недочетов в журнале проверки.
//
Процедура УстановитьРегистрациюВЖурнал() Экспорт
	
	РегистрироватьВТаблице = Ложь;
	
КонецПроцедуры

// Устанавливает режим регистрации недочетов во внутренней таблице.
// Такой режим используется при проверке работы правил.
//
Процедура УстановитьРегистрациюВТаблицу() Экспорт
	
	РегистрироватьВТаблице = Истина;
	
	НайденныеОшибки = Новый ТаблицаЗначений;
	НайденныеОшибки.Колонки.Добавить("Объект");
	НайденныеОшибки.Колонки.Добавить("Правило");
	НайденныеОшибки.Колонки.Добавить("Ошибка");
	НайденныеОшибки.Колонки.Добавить("Уточнение");
	НайденныеОшибки.Колонки.Добавить("МестоОбнаружения");
	НайденныеОшибки.Колонки.Добавить("Ответственный");
	НайденныеОшибки.Колонки.Добавить("Состояние");
	НайденныеОшибки.Колонки.Добавить("Ключ");
	НайденныеОшибки.Колонки.Добавить("Номер"); // Для совместимости
	
КонецПроцедуры

// Устанавливает максимальное количество ошибок, которое можно зарегистрировать для одного вида ошибки.
//
// Параметры
//     МаксимальноеКоличество - Число - максимальное количество ошибок одного вида.
//
Процедура УстановитьМаксимальноеКоличествоОшибокОдногоВида(МаксимальноеКоличество) Экспорт
	
	МаксимальноеКоличествоОшибокОдногоВида = МаксимальноеКоличество;
	
КонецПроцедуры

// Создает таблицу исключений из проверки объектов конфигурации и части кода модулей.
//
Процедура СоздатьТаблицуИсключенийИзПроверки()
	
	ТаблицаИсключенийИзПроверки = Новый ТаблицаЗначений;
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("Объект");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("ТипОбъекта");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("ТипМодуля");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("Ошибка");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("МестоИсключения");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("НомерСтроки");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("НомерСтрокиНачало");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("НомерСтрокиКонец");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("КоличествоСтрок");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("Активно");
	ТаблицаИсключенийИзПроверки.Колонки.Добавить("НайденВклИлиВыкл");
	
КонецПроцедуры

// Заполняет таблицу исключений из проверки объектов конфигурации и части кода модулей по структуре исключения.
//
// Параметры:
//   ОбъектСсылка        - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации с исключением.
//   СтруктураИсключения - Структура                              - структура исключения:
//     КоличествоСтрок   - Число  - количество строк в модуле.
//     Комментарий       - Строка - текст комментария, из которого надо получить исключение.
//     НомерСтроки       - Число  - номер строки с исключением.
//     ТекстВкл          - Строка - текст окончания исключения:
//                                  для конфигурации на русском языке - "-вкл",
//                                  для конфигурации на английском языке - "-on".
//     ТекстВыкл         - Строка - текст начала исключения:
//                                  для конфигурации на русском языке - "-выкл",
//                                  для конфигурации на английском языке - "-off".
//     ТекстИсключения   - Строка - текст для поиска исключения:
//                                  для конфигурации на русском языке - "АПК:",
//                                  для конфигурации на английском языке - "ACC:".
//     МестоИсключения   - Строка - место нахождения исключения: "Комментарий" или "ТекстМодуля".
//     ТипМодуля         - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля объекта.
//
Процедура ЗаполнитьТаблицуИсключенийИзПроверкиИзКомментария(ОбъектСсылка, СтруктураИсключения)
	
	Комментарий = СтруктураИсключения.Комментарий;
	Если ПустаяСтрока(Комментарий) Тогда
		Возврат;
	КонецЕсли;
	
	ТекстИсключения = СтруктураИсключения.ТекстИсключения;
	Если СтрНайти(Комментарий, ТекстИсключения) = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТекстЦифры = "0123456789";
	
	Комментарий = СтрЗаменить(Комментарий, "/", "");
	Комментарий = СокрЛП(Комментарий);
	МассивИсключений = СтрРазделитьПоСтроке(Комментарий, ТекстИсключения);
	Для Каждого СтрокаИсключения Из МассивИсключений Цикл
		
		КодОшибки = "";
		
		КоличествоСимволов = СтрДлина(СтрокаИсключения);
		Для НомерСимвола = 1 По КоличествоСимволов Цикл
			
			СимволКомментария = Сред(СтрокаИсключения, НомерСимвола, 1);
			Если СтрНайти(ТекстЦифры, СимволКомментария) = 0 Тогда
				Прервать;
			КонецЕсли;
			
			КодОшибки = КодОшибки + СимволКомментария;
			
		КонецЦикла;
		
		Если ПустаяСтрока(КодОшибки) Тогда
			Продолжить;
		КонецЕсли;
		
		Ошибка = Справочники.ОбнаруживаемыеОшибки.НайтиПоКоду(КодОшибки);
		Если Ошибка = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаИсключения = Сред(СтрокаИсключения, НомерСимвола);
		СтрокаИсключения = СокрЛ(СтрокаИсключения);
		
		НайденВклИлиВыкл = Ложь;
		ИсключениеАктивно = Истина;
		Если СтрНачинаетсяС(СтрокаИсключения, "-") Тогда
			
			НайденВклИлиВыкл = Истина;
			
			СтрокаИсключения = ВРег(СтрокаИсключения);
			Если СтрНачинаетсяС(СтрокаИсключения, СтруктураИсключения.ТекстВкл) Тогда
				ИсключениеАктивно = Ложь;
			ИначеЕсли СтрНачинаетсяС(СтрокаИсключения, СтруктураИсключения.ТекстВыкл) Тогда
				ИсключениеАктивно = Истина;
			Иначе
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		НовоеИсключение = ТаблицаИсключенийИзПроверки.Добавить();
		НовоеИсключение.Объект = ОбъектСсылка;
		НовоеИсключение.ТипОбъекта = ПолучитьРеквизитОбъекта(ОбъектСсылка, "ТипОбъекта");
		НовоеИсключение.ТипМодуля = СтруктураИсключения.ТипМодуля;
		НовоеИсключение.Ошибка = Ошибка;
		НовоеИсключение.МестоИсключения = СтруктураИсключения.МестоИсключения;
		НовоеИсключение.НомерСтроки = СтруктураИсключения.НомерСтроки;
		НовоеИсключение.КоличествоСтрок = СтруктураИсключения.КоличествоСтрок;
		НовоеИсключение.Активно = ИсключениеАктивно;
		НовоеИсключение.НайденВклИлиВыкл = НайденВклИлиВыкл;
		
	КонецЦикла;
	
КонецПроцедуры

// Заполняет таблицу исключений из проверки объектов конфигурации и части кода модулей.
//
Процедура ЗаполнитьТаблицуИсключенийИзПроверки() Экспорт
	
	Если ТаблицаИсключенийИзПроверки = Неопределено Тогда
		СоздатьТаблицуИсключенийИзПроверки();
	КонецЕсли;
	
	СтруктураИсключения = Новый Структура;
	
	КореньКонфигурации = ПолучитьКореньКонфигурации();
	ОсновнойЯзык = ПолучитьСвойство("ОсновнойЯзык", КореньКонфигурации);
	Если ПустаяСтрока(ОсновнойЯзык) ИЛИ (ОсновнойЯзык = "Русский") Тогда
		СтруктураИсключения.Вставить("ТекстИсключения", "АПК:");
		СтруктураИсключения.Вставить("ТекстВкл", ВРег("-вкл"));
		СтруктураИсключения.Вставить("ТекстВыкл", ВРег("-выкл"));
	ИначеЕсли ОсновнойЯзык = "Английский" Тогда
		СтруктураИсключения.Вставить("ТекстИсключения", "ACC:");
		СтруктураИсключения.Вставить("ТекстВкл", ВРег("-on"));
		СтруктураИсключения.Вставить("ТекстВыкл", ВРег("-off"));
	Иначе
		Возврат;
	КонецЕсли;
	
	ТекстИсключения = СтруктураИсключения.ТекстИсключения;
	
	ТипыОбъектовИмеющиеМодули = ПолучитьТипыОбъектовИмеющихМодули();
	
	СтруктураОтбораЕстьКомментарий = Новый Структура;
	СтруктураОтбораЕстьКомментарий.Вставить("ЕстьКомментарий", Истина);
	
	ТекстСостоянияШаблон = НСтр("ru='Выполняется сбор исключений из проверки объектов конфигурации: №%1 из %2 - %3'");
	
	ТаблицаОбъектов = ПолучитьОбъектыКонфигурации();
	КоличествоОбъектов = ТаблицаОбъектов.Количество();
	
	Счетчик = 0;
	
	Для Каждого СтрокаОбъекта Из ТаблицаОбъектов Цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		
		Счетчик = Счетчик + 1;
		ТекстСостояния = СтрШаблон(ТекстСостоянияШаблон, Счетчик, КоличествоОбъектов, СтрокаОбъекта.Путь);
		Состояние(ТекстСостояния);
		#КонецЕсли
		
		ОбъектСсылка = СтрокаОбъекта.Ссылка;
		
		СтруктураИсключения.Вставить("ТипМодуля", Неопределено);
		СтруктураИсключения.Вставить("НомерСтроки", Неопределено);
		СтруктураИсключения.Вставить("КоличествоСтрок", Неопределено);
		
		Комментарий = ПолучитьСвойство("Комментарий", ОбъектСсылка);
		Если НЕ ПустаяСтрока(Комментарий) Тогда
			СтруктураИсключения.Вставить("Комментарий", Комментарий);
			СтруктураИсключения.Вставить("МестоИсключения", "Комментарий");
			
			ЗаполнитьТаблицуИсключенийИзПроверкиИзКомментария(ОбъектСсылка, СтруктураИсключения);
		КонецЕсли;
		
		Если ТипыОбъектовИмеющиеМодули.Найти(СтрокаОбъекта.ТипОбъекта) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ВсеМодулиОбъекта = ПолучитьСоставМодулей(ОбъектСсылка);
		Для Каждого МодульОбъекта Из ВсеМодулиОбъекта Цикл
			
			ТекстМодуля = ПолучитьТекстМодуля(МодульОбъекта, ОбъектСсылка);
			Если ПустаяСтрока(ТекстМодуля) Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтрНайти(ТекстМодуля, СтруктураИсключения.ТекстИсключения) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			СтруктураИсключения.Вставить("ТипМодуля", МодульОбъекта);
			
			ТаблицаБлоковМодуля = ПолучитьСтруктуруМодуля(МодульОбъекта, ОбъектСсылка);
			Если ТаблицаБлоковМодуля = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			КоличествоБлоков = ТаблицаБлоковМодуля.Количество();
			Если КоличествоБлоков = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			КоличествоСтрок = ТаблицаБлоковМодуля[КоличествоБлоков - 1].КонечнаяСтрока;
			
			ТаблицаБлоковМодуляКомментарии = ТаблицаБлоковМодуля.Скопировать(СтруктураОтбораЕстьКомментарий);
			Для Каждого СтрокаКомментария Из ТаблицаБлоковМодуляКомментарии Цикл
				
				ТекстКомментария = СтрокаКомментария.Текст;
				Если СтрНайти(ТекстКомментария, ТекстИсключения) = 0 Тогда
					Продолжить;
				КонецЕсли;
				
				НомерСтрокиНачало = СтрокаКомментария.НачальнаяСтрока;
				НомерСтрокиКонец = СтрокаКомментария.КонечнаяСтрока;
				
				Для НомерСтроки = НомерСтрокиНачало По НомерСтрокиКонец Цикл
					
					ТекстСтрокиКомментария = СтрПолучитьСтроку(ТекстКомментария, НомерСтроки - НомерСтрокиНачало + 1);
					Если ПустаяСтрока(ТекстСтрокиКомментария) Тогда
						Продолжить;
					КонецЕсли;
					
					Комментарий = ПолучитьКомментарийИзСтроки(ТекстСтрокиКомментария);
					
					СтруктураИсключения.Вставить("Комментарий", СокрЛП(Комментарий));
					СтруктураИсключения.Вставить("МестоИсключения", "ТекстМодуля");
					СтруктураИсключения.Вставить("НомерСтроки", НомерСтроки);
					СтруктураИсключения.Вставить("КоличествоСтрок", КоличествоСтрок);
					ЗаполнитьТаблицуИсключенийИзПроверкиИзКомментария(ОбъектСсылка, СтруктураИсключения);
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТаблицаИсключенийИзПроверки.Индексы.Добавить("МестоИсключения, Активно, НайденВклИлиВыкл");
	ТаблицаИсключенийИзПроверки.Индексы.Добавить("Объект, Ошибка, ТипМодуля, МестоИсключения, Активно, НайденВклИлиВыкл");
	
	ТаблицаИсключенийИзПроверки.Сортировать("Объект, Ошибка, НомерСтроки");
	
	СтруктураОтбораАктивноЛожь = Новый Структура;
	СтруктураОтбораАктивноЛожь.Вставить("МестоИсключения", "ТекстМодуля");
	СтруктураОтбораАктивноЛожь.Вставить("Активно", Ложь);
	СтруктураОтбораАктивноЛожь.Вставить("НайденВклИлиВыкл", Истина);
	
	СтруктураОтбораАктивноИстина = Новый Структура;
	СтруктураОтбораАктивноИстина.Вставить("Объект");
	СтруктураОтбораАктивноИстина.Вставить("Ошибка");
	СтруктураОтбораАктивноИстина.Вставить("ТипМодуля");
	СтруктураОтбораАктивноИстина.Вставить("МестоИсключения", "ТекстМодуля");
	СтруктураОтбораАктивноИстина.Вставить("Активно", Истина);
	СтруктураОтбораАктивноИстина.Вставить("НайденВклИлиВыкл", Истина);
	
	// Ищем строки с окончанием исключений "-вкл".
	МассивИсключенийАктивноЛожь = ТаблицаИсключенийИзПроверки.НайтиСтроки(СтруктураОтбораАктивноЛожь);
	Для Каждого СтрокаИсключенияАктивноЛожь Из МассивИсключенийАктивноЛожь Цикл
		
		НомерСтрокиКонцаИсключения = СтрокаИсключенияАктивноЛожь.НомерСтроки;
		
		// Ищем строки с началом исключений "-выкл", подходящие по ошибке и объекту.
		СтруктураОтбораАктивноИстина.Объект = СтрокаИсключенияАктивноЛожь.Объект;
		СтруктураОтбораАктивноИстина.Ошибка = СтрокаИсключенияАктивноЛожь.Ошибка;
		СтруктураОтбораАктивноИстина.ТипМодуля = СтрокаИсключенияАктивноЛожь.ТипМодуля;
		МассивИсключенийАктивноИстина = ТаблицаИсключенийИзПроверки.НайтиСтроки(СтруктураОтбораАктивноИстина);
		Если МассивИсключенийАктивноИстина.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого СтрокаИсключенияАктивноИстина Из МассивИсключенийАктивноИстина Цикл
			
			НомерСтрокиНачалаИсключения = СтрокаИсключенияАктивноИстина.НомерСтроки;
			
			// Если номер строки не заполнен, то пропускаем.
			Если НомерСтрокиНачалаИсключения = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Если номер строки окончания исключения уже заполнен, то пропускаем.
			Если СтрокаИсключенияАктивноИстина.НомерСтрокиКонец <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			// Если окончание исключения находится до его начала, то пропускаем.
			Если НомерСтрокиКонцаИсключения < НомерСтрокиНачалаИсключения Тогда
				Продолжить;
			КонецЕсли;
			
			// Устанавливаем номера строк начала и окончания исключения.
			СтрокаИсключенияАктивноИстина.НомерСтрокиНачало = НомерСтрокиНачалаИсключения;
			СтрокаИсключенияАктивноИстина.НомерСтрокиКонец = НомерСтрокиКонцаИсключения;
			СтрокаИсключенияАктивноИстина.НомерСтроки = Неопределено;
			
			Прервать;
			
		КонецЦикла;
		
		ТаблицаИсключенийИзПроверки.Удалить(СтрокаИсключенияАктивноЛожь);
		
	КонецЦикла;
	
	СтруктураОтбораАктивноИстина.Удалить("Ошибка");
	СтруктураОтбораАктивноИстина.Удалить("Объект");
	СтруктураОтбораАктивноИстина.Удалить("ТипМодуля");
	
	// Ищем строки модулей, у которых есть начало исключения, но не заполнено окончание.
	СтруктураОтбораАктивноИстина.Вставить("НомерСтрокиКонец", Неопределено);
	
	ТаблицаИсключенийИзПроверки.Индексы.Очистить();
	ТаблицаИсключенийИзПроверки.Индексы.Добавить("МестоИсключения, Активно, НайденВклИлиВыкл, НомерСтрокиКонец");
	
	МассивИсключенийАктивноИстина = ТаблицаИсключенийИзПроверки.НайтиСтроки(СтруктураОтбораАктивноИстина);
	Для Каждого СтрокаИсключенияАктивноИстина Из МассивИсключенийАктивноИстина Цикл
		
		СтрокаИсключенияАктивноИстина.НомерСтрокиКонец = СтрокаИсключенияАктивноИстина.КоличествоСтрок;
		
		Если СтрокаИсключенияАктивноИстина.НомерСтрокиНачало = Неопределено Тогда
			СтрокаИсключенияАктивноИстина.НомерСтрокиНачало = СтрокаИсключенияАктивноИстина.НомерСтроки;
			СтрокаИсключенияАктивноИстина.НомерСтроки = Неопределено;
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаИсключенийИзПроверки.Индексы.Очистить();
	ТаблицаИсключенийИзПроверки.Индексы.Добавить("Ошибка");
	
	ТаблицаИсключенийИзПроверки.Колонки.Удалить("КоличествоСтрок");
	ТаблицаИсключенийИзПроверки.Колонки.Удалить("НайденВклИлиВыкл");
	
КонецПроцедуры

#КонецОбласти

#Область Проверка

// Регистрирует найденный недочет в таблице ошибок.
//
// Параметры:
//   НомерОшибки        - Число  - порядковый номер ошибки.
//   Уточнение          - Строка - уточнение ошибки.
//   МестоОшибки        - Строка - место обнаружения ошибки.
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то ошибка записывается для  текущего проверяемого объекта.
//   СтруктураОшибки    - Структура - структура ошибки:
//     НомерСтроки      - Число                                               - номер строки.
//     ТипМодуля        - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля объекта.
//
Процедура ЗаписатьОшибку(НомерОшибки, Уточнение = "", МестоОшибки = "", ОбъектКонфигурации = Неопределено)
	
	// Ошибки могут регистрироваться не на проверяемый объект, перезапишем переменные.
	Если ОбъектКонфигурации = Неопределено Тогда
		ОшибкаОбъект = ОбъектПроверкиСсылка;
		ОшибкаКодОбъекта = ОбъектПроверкиКод;
	Иначе
		
		ОшибкаОбъект = ОбъектКонфигурации;
		ОшибкаКодОбъекта = ОбъектКонфигурации.Код;
		
		// Если ошибка регистрируется не на проверяемый объект, то смотрим, собраны ли о нем сведения.
		СобраныСведения = ПолучитьРеквизитОбъекта(ОбъектКонфигурации, "СобраныСведения");
		Если (СобраныСведения = Неопределено) ИЛИ (НЕ СобраныСведения) Тогда
			// Если сведения не собраны, значит, объект находится в исключениях, пропускаем.
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	ОшибкаСсылка = ТекущееПравило.ОбнаруживаемыеОшибки[НомерОшибки - 1].Ошибка;
	
	// Проверяем ошибку в таблице исключений, если нашли, то не записываем.
	СтруктураОшибки = ПолучитьТипМодуляИНомерСтрокиИзМестаОбнаружения(МестоОшибки);
	СтруктураОшибки.Вставить("Объект", ОшибкаОбъект);
	СтруктураОшибки.Вставить("Ошибка", ОшибкаСсылка);
	Если ОшибкаЯвляетсяИсключениемИзПроверки(СтруктураОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	ОшибкаКод = ОшибкаСсылка.Код;
	
	КлючСоответствия = КодПравила + Символы.ПС + ОшибкаКод;
	
	// Записываем ошибку, если их менее МаксимальноеКоличествоОшибокОдногоВида.
	КоличествоОшибокОдногоВида = СоответствиеОшибок[КлючСоответствия];
	Если КоличествоОшибокОдногоВида = Неопределено Тогда
		СоответствиеОшибок.Вставить(КлючСоответствия, 1);
	ИначеЕсли КоличествоОшибокОдногоВида < МаксимальноеКоличествоОшибокОдногоВида Тогда
		СоответствиеОшибок.Вставить(КлючСоответствия, КоличествоОшибокОдногоВида + 1);
	ИначеЕсли КоличествоОшибокОдногоВида >= МаксимальноеКоличествоОшибокОдногоВида Тогда
		// Ошибки считаем, но не записываем.
		СоответствиеОшибок.Вставить(КлючСоответствия, КоличествоОшибокОдногоВида + 1);
		Возврат;
	КонецЕсли;
	
	Если РегистрироватьВТаблице = Истина Тогда
		Ключ = СтрШаблон("%1.%2.%3.%4.%5",
			ОшибкаКодОбъекта,
			КодПравила,
			ОшибкаКод,
			Лев(Уточнение, 999),
			МестоОшибки);
		
		Ключ = ВРег(Ключ);
		Ключ = УдалитьНезначащиеСимволы(Ключ);
		
		НоваяЗаписьРегистрации = НайденныеОшибки.Добавить();
		НоваяЗаписьРегистрации.Ключ = Ключ;
	Иначе
		НоваяЗаписьРегистрации = ОшибкиВОбъекте.Добавить();
	КонецЕсли;
	
	НоваяЗаписьРегистрации.Объект           = ОшибкаОбъект;
	НоваяЗаписьРегистрации.Правило          = ТекущееПравило;
	НоваяЗаписьРегистрации.Номер            = НомерПроверки;
	НоваяЗаписьРегистрации.Ошибка           = ОшибкаСсылка;
	НоваяЗаписьРегистрации.МестоОбнаружения = МестоОшибки;
	// Максимальная длина реквизита "Уточнение" РС "НайденныеОшибки" - 999 символов.
	НоваяЗаписьРегистрации.Уточнение        = Лев(Уточнение, 999);
	
	НомерПроверки = НомерПроверки + 1;
	
КонецПроцедуры

// Проверяет объект либо установленным правилом, либо всеми подходящими правилами
// из определенного ранее состава программ проверки.
//
// Параметры:
//   ПравилоДляПроверки    - СправочникСсылка.Правила   - конкретное правило проверки.
//                           Неопределено               - проверка по всем правилам, подходящим по типу объекта.
//
//   ВыборкаОбъекта        - ВыборкаИзРезультатаЗапроса - выборка из запроса с полями:
//     Ссылка             - СправочникСсылка.СтруктураКонфигурации - ссылка на проверяемый объект.
//     Код                - Число                                  - код объекта в справочнике.
//     Наименование       - Строка                                 - наименование объекта.
//     ТипОбъекта         - ПеречислениеСсылка.ТипыОбъектов        - тип объекта.
//     Путь               - Строка                                 - полный путь к объекту.
//     Родитель           - СправочникСсылка.СтруктураКонфигурации - ссылка на родителя проверяемого объекта.
//     РодительТипОбъекта - ПеречислениеСсылка.ТипыОбъектов        - тип объекта родителя проверяемого объекта.
//
//   ПравилаПроверкиПоТипу - Соответствие               - соответствие типов объектов и правил проверки:
//     Ключ     - ПеречислениеСсылка.ТипыОбъектов - тип объекта.
//     Значение - Массив                          - массив правил. Элементы:
//       СправочникСсылка.Правила - правило проверки.
//
Процедура ПроверитьОбъект(ПравилоДляПроверки, ВыборкаОбъекта, ПравилаПроверкиПоТипу = Неопределено) Экспорт
	
	УстановитьКонтекстОбъекта(ВыборкаОбъекта);
	
	Если НЕ ЗначениеЗаполнено(ОбъектПроверкиСсылка) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПравилоДляПроверки) Тогда
		Если ЗначениеЗаполнено(ПравилаПроверкиПоТипу) Тогда
			МассивПравил = ПравилаПроверкиПоТипу[ОбъектПроверкиТипОбъекта];
		Иначе
			ЗапросПравил = Новый Запрос;
			ЗапросПравил.Текст = "
			|ВЫБРАТЬ
			|	ПравилаОбслуживаемыеТипы.Ссылка
			|ИЗ
			|	Справочник.Правила.ОбслуживаемыеТипы КАК ПравилаОбслуживаемыеТипы
			|ГДЕ
			|	ПравилаОбслуживаемыеТипы.ТипОбъекта = &ТипОбъекта";
			
			ЗапросПравил.УстановитьПараметр("ТипОбъекта", ОбъектПроверкиТипОбъекта);
			МассивПравил = ЗапросПравил.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		КонецЕсли;
	Иначе
		МассивПравил = Новый Массив;
		МассивПравил.Добавить(ПравилоДляПроверки);
	КонецЕсли;
	
	Если ОбъектПроверкиЭтоРасширение И (ОбъектПроверкиПринадлежностьОбъекта = "Заимствованный") Тогда
		
		НаименованиеГруппы = "8. Требования к расширениям конфигураций, разработанным в среде ""1С:Предприятие 8.3"""; //не локализуется
		ГруппаТребованийКРасширениям = Справочники.Требования.НайтиПоНаименованию(НаименованиеГруппы, Ложь,
			Справочники.Требования.Совместимо);
		
		ЗапросПоПравиламДляРасширений = Новый Запрос;
		ЗапросПоПравиламДляРасширений.Текст = "
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ТребованияРеализацияТребования.ПравилоПроверки КАК СсылкаНаПравило
		|ИЗ
		|	Справочник.Требования.РеализацияТребования КАК ТребованияРеализацияТребования
		|ГДЕ
		|	ТребованияРеализацияТребования.Ссылка В ИЕРАРХИИ(&ГруппаРасширений)";
		
		ЗапросПоПравиламДляРасширений.УстановитьПараметр("ГруппаРасширений", ГруппаТребованийКРасширениям);
		
		МассивПравилРасширений = ЗапросПоПравиламДляРасширений.Выполнить().Выгрузить().ВыгрузитьКолонку("СсылкаНаПравило");
		
		МассивПравилНовый = Новый Массив;
		Для Каждого ПравилоПроверкиРасширения Из МассивПравилРасширений Цикл
			Если МассивПравил.Найти(ПравилоПроверкиРасширения) <> Неопределено Тогда
				МассивПравилНовый.Добавить(ПравилоПроверкиРасширения);
			КонецЕсли;
		КонецЦикла;
		
		МассивПравил = МассивПравилНовый;
		
	КонецЕсли;
	
	Для Каждого ТекущееПравило Из МассивПравил Цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		// Выполняем проверку только теми правилами, что утверждены к применению.
		Если НЕ ТекущееПравило.ИспользуетсяПриПроверке Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ РегистрироватьВТаблице Тогда
			ОшибкиВОбъекте = РегистрыСведений.НайденныеОшибки.СоздатьНаборЗаписей();
			ОшибкиВОбъекте.Отбор.Объект.Установить(ОбъектПроверкиСсылка);
			ОшибкиВОбъекте.Отбор.Правило.Установить(ТекущееПравило);
		КонецЕсли;
		
		НомерПроверки = 0;
		
		// Проверяем необходимость проверки объекта правилом с учетом уточнений.
		Уточнения = УточненияПроверок[ТекущееПравило];
		Если Уточнения <> Неопределено Тогда
			// Уточнения есть, надо проверить входит ли объект в них.
			Если Уточнения[ОбъектПроверкиПуть] = Неопределено Тогда
				// Есть уточнения по правилу и объект в них не входит, проверять не надо.
				Событие = НСтр("ru='Ошибка проверки'", Метаданные.ОсновнойЯзык.КодЯзыка);
				Комментарий = СтрШаблон(НСтр("ru='В объекте <%1> пропущена проверка <%2>'"), ОбъектПроверкиПуть, ТекущееПравило)
					+ " " + НСтр("ru='в соответствии с уточнениями, установленными для конфигурации.'");
				ЗаписьЖурналаРегистрации(Событие,,,, Комментарий);
				
				Если НЕ РегистрироватьВТаблице Тогда
					ОшибкиВОбъекте.Записать();
				КонецЕсли;
				
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// Проверяем принадлежность типа объекта к правилу.
		Если ТекущееПравило.ОбслуживаемыеТипы.Найти(ОбъектПроверкиТипОбъекта) = Неопределено Тогда
			Комментарий = НСтр("ru='Правило <%1> не проверяет объекты данного типа (%2)'");
			Комментарий = СтрШаблон(Комментарий, ТекущееПравило, ОбъектПроверкиТипОбъекта);
			
			Если РегистрироватьВТаблице = Истина Тогда
				Сообщить(Комментарий);
			Иначе
				Событие = НСтр("ru='Ошибка проверки'", Метаданные.ОсновнойЯзык.КодЯзыка);
				ЗаписьЖурналаРегистрации(Событие,,,, Комментарий);
			КонецЕсли;
			
			Продолжить;
		КонецЕсли;
		
		// Подготавливаем ресурсы правила.
		РесурсыПравила = ВсеРесурсыПравил[ТекущееПравило];
		Если РесурсыПравила = Неопределено Тогда
			РесурсыПравила = Новый Соответствие;
			Для Каждого Ресурс Из ТекущееПравило.Ресурсы Цикл
				РесурсыПравила.Вставить(Ресурс.Имя, Ресурс.Значение.Получить());
			КонецЦикла;
			ВсеРесурсыПравил.Вставить(ТекущееПравило, РесурсыПравила);
		КонецЕсли;
		
		КодПравила = ТекущееПравило.Код;
		
		Отказ = Ложь;
		
		Попытка
			Выполнить(ТекущееПравило.Алгоритм);
		Исключение
			
			СтрокаОписаниеОшибки = ОписаниеОшибки();
			Если СтрНайти(СтрокаОписаниеОшибки, "<НеЯвляетсяОшибкой>") > 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Событие = НСтр("ru='Ошибка проверки'", Метаданные.ОсновнойЯзык.КодЯзыка);
			Комментарий = СтрШаблон(НСтр("ru='Возникли ошибки при проверке объекта <%1> правилом <%2>.
				|Описание ошибки: %3'"), ОбъектПроверкиПуть, ТекущееПравило, СтрокаОписаниеОшибки);
			
			ЗаписьЖурналаРегистрации(Событие, УровеньЖурналаРегистрации.Ошибка,,, Комментарий);
			
		КонецПопытки;
		
		Если НЕ РегистрироватьВТаблице Тогда
			ОшибкиВОбъекте.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Выполняет завершающие действия при окончании проверки.
//
Процедура ЗавершитьПроверку() Экспорт
	
	// Временно пустая процедура.
	
КонецПроцедуры

// Возвращает таблицу зарегистрированных при проверке недочетов,
// если используется режим регистрации найденных недочетов во внутреннюю таблицу.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок с колонками:
//     Объект           - СправочникСсылка.СтруктураКонфигурации - ссылка на объект с ошибкой.
//     Правило          - СправочникСсылка.Правила               - ссылка на правило проверки.
//     Ошибка           - СправочникСсылка.ОбнаруживаемыеОшибки  - ссылка на ошибку.
//     Уточнение        - Строка                                 - уточнение ошибки.
//     МестоОбнаружения - Строка                                 - место обнаружения ошибки.
//     Ответственный    - СправочникСсылка.Пользователи          - пользователь, ответственный за ошибку.
//     Состояние        - ПеречислениеСсылка.СостояниеОшибки     - состояние ошибки.
//     Ключ             - Строка                                 - ключ ошибки для быстрого поиска, состоит из значения:
//                        "<КодОбъекта>.<КодПравила>.<КодОшибки>.<Уточнение>.<МестоОбнаружения>".
//     Номер            - Число                                  - номер текущей проверки.
//
Функция ПолучитьНайденныеОшибки() Экспорт
	
	Возврат НайденныеОшибки;
	
КонецФункции

// Возвращает соответствие обнаруженных ошибок и их количества.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок с колонками:
//     Ключ     - Строка - код правила + перенос строки + код ошибки.
//     Значение - Число  - количество ошибок этого вида.
//
Функция ПолучитьСоответствиеОбнаруженныхОшибок() Экспорт
	
	Возврат СоответствиеОшибок;
	
КонецФункции

// Возвращает активность исключения из проверки, если оно найдено в таблице исключений из проверки.
// Если не найдено, то возвращается Ложь.
//
// Параметры:
//   СтруктураОшибки    - Структура - структура ошибки:
//     НомерСтроки      - Число                                               - номер строки.
//     Объект           - СправочникСсылка.СтруктураКонфигурации              - ссылка на объект.
//     Ошибка           - СправочникСсылка.ОбнаруживаемыеОшибки               - ссылка на ошибку.
//     ТипМодуля        - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля объекта.
//
// Возвращаемое значение:
//   Булево - Истина, если ошибка найдена в таблице исключений из проверки, и она активна.
//            Ложь, если исключение не найдено или не активно.
//
Функция ОшибкаЯвляетсяИсключениемИзПроверки(СтруктураОшибки)
	
	Если ТаблицаИсключенийИзПроверки.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОшибкаСсылка = СтруктураОшибки.Ошибка;
	
	СтруктураОтбораОшибка = Новый Структура;
	СтруктураОтбораОшибка.Вставить("Ошибка", ОшибкаСсылка);
	
	ТаблицаИсключенийИзПроверкиПоОшибке = ТаблицаИсключенийИзПроверки.Скопировать(СтруктураОтбораОшибка);
	Если ТаблицаИсключенийИзПроверкиПоОшибке.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ОбъектСсылка = СтруктураОшибки.Объект;
	
	СтруктураОтбораОбъект = Новый Структура;
	СтруктураОтбораОбъект.Вставить("Объект", ОбъектСсылка);
	
	ТаблицаИсключенийИзПроверкиПоОбъекту = ТаблицаИсключенийИзПроверкиПоОшибке.Скопировать(СтруктураОтбораОбъект);
	Если ТаблицаИсключенийИзПроверкиПоОбъекту.Количество() = 0 Тогда
		
		ИсключениеНайдено = Ложь;
		
		// В таблице исключений нет искомого объекта, проверяем исключения по подсистемам.
		СтруктураОтбораТипОбъекта = Новый Структура;
		СтруктураОтбораТипОбъекта.Вставить("ТипОбъекта", Перечисления.ТипыОбъектов.Подсистема);
		СтруктураОтбораТипОбъекта.Вставить("Активно", Истина);
		
		МассивИсключенийИзПроверкиПоПодсистемам = ТаблицаИсключенийИзПроверкиПоОшибке.НайтиСтроки(СтруктураОтбораТипОбъекта);
		Для Каждого СтрокаИсключения Из МассивИсключенийИзПроверкиПоПодсистемам Цикл
			
			ПодсистемаСсылка = СтрокаИсключения.Объект;
			Если ОбъектВходитВПодсистему(ОбъектСсылка, ПодсистемаСсылка, Истина) Тогда
				ИсключениеНайдено = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если ИсключениеНайдено Тогда
			Возврат ИсключениеНайдено;
		КонецЕсли;
		
	КонецЕсли;
	
	НомерСтрокиОшибки = СтруктураОшибки.НомерСтроки;
	
	// Нашли исключения по объекту и ошибке, проверяем их.
	// Сначала ищем в коде модуля.
	СтруктураОтбораМестоИсключения = Новый Структура;
	СтруктураОтбораМестоИсключения.Вставить("ТипМодуля", СтруктураОшибки.ТипМодуля);
	СтруктураОтбораМестоИсключения.Вставить("МестоИсключения", "ТекстМодуля");
	
	ТаблицаИсключенийИзПроверкиПоТекстуМодуля = ТаблицаИсключенийИзПроверкиПоОбъекту.Скопировать(СтруктураОтбораМестоИсключения);
	
	// Ищем в конкретной строке.
	СтрокаИсключенияИзПроверкиПоТекстуМодуля = ТаблицаИсключенийИзПроверкиПоТекстуМодуля.Найти(НомерСтрокиОшибки, "НомерСтроки");
	Если СтрокаИсключенияИзПроверкиПоТекстуМодуля <> Неопределено Тогда
		Возврат СтрокаИсключенияИзПроверкиПоТекстуМодуля.Активно;
	КонецЕсли;
	
	// Если не нашли в конкретной строке, ищем по номерам строк начала и окончания исключения.
	Для Каждого СтрокаИсключения Из ТаблицаИсключенийИзПроверкиПоТекстуМодуля Цикл
		
		НомерСтрокиНачалоИсключения = СтрокаИсключения.НомерСтрокиНачало;
		НомерСтрокиКонецИсключения = СтрокаИсключения.НомерСтрокиКонец;
		Если (НомерСтрокиНачалоИсключения = Неопределено) ИЛИ (НомерСтрокиКонецИсключения = Неопределено) Тогда
			Продолжить;
		КонецЕсли;
		
		Если (НомерСтрокиНачалоИсключения < НомерСтрокиОшибки) И (НомерСтрокиКонецИсключения > НомерСтрокиОшибки) Тогда
			Возврат СтрокаИсключения.Активно;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если не нашли в тексте модуля, то ищем в комментарии к объекту.
	СтруктураОтбораМестоИсключения.Удалить("ТипМодуля");
	СтруктураОтбораМестоИсключения.Вставить("МестоИсключения", "Комментарий");
	
	ТаблицаИсключенийИзПроверкиПоКомментарию = ТаблицаИсключенийИзПроверкиПоОбъекту.Скопировать(СтруктураОтбораМестоИсключения);
	Если ТаблицаИсключенийИзПроверкиПоКомментарию.Количество() > 0 Тогда
		Возврат ТаблицаИсключенийИзПроверкиПоКомментарию[0].Активно;
	КонецЕсли;
	
	СтруктураОтбораРодитель = Новый Структура;
	СтруктураОтбораРодитель.Вставить("Активно", Истина);
	
	РодительОбъекта = ОбъектСсылка.Родитель;
	
	// В таблице исключений нет искомого объекта, проверяем исключения по родителю объекта.
	Пока Истина Цикл
		
		Если РодительОбъекта.Пустая() Тогда
			Прервать;
		КонецЕсли;
		
		Если РодительОбъекта.ТипОбъекта = Перечисления.ТипыОбъектов.ВеткаМетаданных Тогда
			Прервать;
		КонецЕсли;
		
		СтруктураОтбораРодитель.Вставить("Объект", РодительОбъекта);
		
		МассивИсключенийИзПроверкиПоРодителю = ТаблицаИсключенийИзПроверкиПоОшибке.НайтиСтроки(СтруктураОтбораРодитель);
		Если МассивИсключенийИзПроверкиПоРодителю.Количество() > 0 Тогда
			Возврат Истина;
		КонецЕсли;
		
		РодительОбъекта = РодительОбъекта.Родитель;
		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает длину поля указанного объекта (в байтах) в зависимости от типа объекта.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//
// Возвращаемое значение:
//   Число - длина поля в байтах.
//
Функция ПолучитьДлинуПоляОбъектаМетаданных(ОбъектКонфигурации)
	
	СоставнаяДлинаПоля = 0;
	
	СвойствоТип = ПолучитьСоставноеСвойство("Тип", ОбъектКонфигурации);
	Если СвойствоТип = Неопределено Тогда
		Возврат СоставнаяДлинаПоля;
	КонецЕсли;
	
	МассивТипов = СвойствоТип.Тип;
	
	// Если поле составного типа (т.е. указано > 1 типа данных),
	// то в любом случае добавляется поле "_TYPE" длиной 1 байт.
	// Оно содержит фактический тип хранимого значения.
	ЭтоСоставнойТип = (МассивТипов.Количество() > 1);
	Если ЭтоСоставнойТип Тогда
		СоставнаяДлинаПоля = СоставнаяДлинаПоля + 1;
	КонецЕсли;
	
	// Если выбран тип "Ссылка" (ИД, GUID) на объекты базы данных более чем одного типа,
	// то добавляется поле "_RTRef" длиной 4 байта.
	// Оно содержит номер таблицы, на которую ссылается значение.
	// Создадим флаг ссылки, установим его в цикле и проверим после цикла.
	ЕстьТипСсылка = Ложь;
	
	// Проверяем все типы из массива.
	Для Каждого ЭлементТипа Из МассивТипов Цикл
		
		Если ЭлементТипа = "Число" Тогда
			ДлинаТипа = СвойствоТип.Разрядность;
			ДлинаПоля = (ДлинаТипа + 1) / 2 + (ДлинаТипа + 1) % 2;
			ДлинаПоля = Окр(ДлинаПоля, 0, РежимОкругления.Окр15как20);
		ИначеЕсли ЭлементТипа = "Строка" Тогда
			ДлинаТипа = СвойствоТип.Длина;
			ДлинаПоля = ДлинаТипа * 2;
		ИначеЕсли ЭлементТипа = "Дата" Тогда
			ДлинаПоля = 8;
		ИначеЕсли ЭлементТипа = "Булево" Тогда
			ДлинаПоля = 1;
		ИначеЕсли ЕстьТипСсылка Тогда
			// Если уже был ссылочный тип, то пропускаем, т.к. под различные типы ссылок добавляется только 1 колонка binary(16).
			Продолжить;
		ИначеЕсли СтрНайти(ЭлементТипа, ".") > 0 Тогда
			ЕстьТипСсылка = Истина;
			ДлинаПоля = 16;
		ИначеЕсли ЭлементТипа = "УникальныйИдентификатор" Тогда
			ЕстьТипСсылка = Истина;
			ДлинаПоля = 16;
		Иначе
			// Для других полей индексы не создаются, поэтому можно их не учитывать.
			ДлинаПоля = 0;
		КонецЕсли;
		
		СоставнаяДлинаПоля = СоставнаяДлинаПоля + ДлинаПоля;
		
	КонецЦикла;
	
	// Если в массиве типов была ссылка, добавим поле "_RTRef" длиной 4 байта.
	Если ЭтоСоставнойТип И ЕстьТипСсылка Тогда
		СоставнаяДлинаПоля = СоставнаяДлинаПоля + 4;
	КонецЕсли;
	
	Возврат СоставнаяДлинаПоля;
	
КонецФункции

// Возвращает ссылку на объект ссылочного типа.
//
// Параметры:
//   ОбъектКонфигурации    - СправочникСсылка.СтруктураКонфигурации - ссылка на объект.
//   ТипыСсылочныхОбъектов - Массив                                 - массив ссылочных типов.
//
// Возвращаемое значение:
//   СправочникСсылка.СтруктураКонфигурации - ссылка на объект ссылочного типа.
//
// Пример:
//   Если параметр "ОбъектКонфигурации" - реквизит справочника, то возвращаемое значение - его родитель справочник.
//   Если параметр "ОбъектКонфигурации" - справочник, то возвращаемое значение - тот же объект справочник.
//
Функция ПолучитьОбъектСсылочногоТипа(ОбъектКонфигурации, ТипыСсылочныхОбъектов = Неопределено)
	
	Если ТипыСсылочныхОбъектов = Неопределено Тогда
		ТипыСсылочныхОбъектов = ПолучитьТипыСсылочныхОбъектов();
	КонецЕсли;
	
	ПроверяемыйОбъект = ОбъектКонфигурации;
	Пока НЕ ПроверяемыйОбъект.Пустая() Цикл
		Если ТипыСсылочныхОбъектов.Найти(ПроверяемыйОбъект.ТипОбъекта) <> Неопределено Тогда
			Возврат ПроверяемыйОбъект;
		КонецЕсли;
		ПроверяемыйОбъект = ПроверяемыйОбъект.Родитель;
	КонецЦикла;
	
	Возврат ПроверяемыйОбъект;
	
КонецФункции

// Возвращает массив ссылочных типов.
//
// Возвращаемое значение:
//   Массив - массив ссылочных типов.
//
Функция ПолучитьТипыСсылочныхОбъектов()
	
	ПеречисленияТипы = Перечисления.ТипыОбъектов;
	ТипыСсылочныхОбъектов = Новый Массив;
	
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.БизнесПроцесс);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.Документ);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.Задача);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.Константа);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.ПланВидовРасчета);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.ПланВидовХарактеристик);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.ПланОбмена);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.ПланСчетов);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.РегистрБухгалтерии);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.РегистрНакопления);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.РегистрРасчета);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.РегистрСведений);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.РегламентноеЗадание);
	ТипыСсылочныхОбъектов.Добавить(ПеречисленияТипы.Справочник);
	
	Возврат ТипыСсылочныхОбъектов;
	
КонецФункции

// Определяет, является ли проверяемая конфигурация демо-конфигурацией:
// если наименование корня конфигурации заканчивается на "Демо", то вернется Истина.
//
// Возвращаемое значение:
//   Булево - флаг, является ли проверяемая конфигурация демо-конфигурацией.
//
Функция ОпределитьЭтоДемоКонфигурация()
	
	КлючКонтекста = "ЭтоДемоКонфигурация";
	ФлагЭтоДемоКонфигурация = Контекст[КлючКонтекста];
	Если ФлагЭтоДемоКонфигурация <> Неопределено Тогда
		Возврат ФлагЭтоДемоКонфигурация;
	КонецЕсли;
	
	ФлагЭтоДемоКонфигурация = Ложь;
	
	ОбъектКонфигурация = ПолучитьКореньКонфигурации();
	Если НЕ ОбъектКонфигурация.Пустая() Тогда
		Если СтрЗаканчиваетсяНа(ВРег(ОбъектКонфигурация.Наименование), "ДЕМО") Тогда
			ФлагЭтоДемоКонфигурация = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ФлагЭтоДемоКонфигурация);
	
	Возврат ФлагЭтоДемоКонфигурация;
	
КонецФункции

// Получает таблицу соответствия типов объектов в ед., мн.ч. и на английском языке.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица типов объектов с колонками:
//     Группа     - Строка - группа, которой принадлежит тип объекта, например, "Общие".
//     ИмяАнгл    - Строка - имя типа объекта на английском языке.
//     Имя        - Строка - имя типа объекта в ед.ч.
//     ИмяМнФормы - Строка - имя типа объекта во мн.ч.
//     ТипОбъекта - ПеречислениеСсылка.ТипыОбъектов                     - тип объекта из перечисления.
//                  ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - идентификатор содержания объекта.
//
Функция ПолучитьТаблицуТиповОбъектовИзКонтекста()
	
	КлючКонтекста = "ТаблицаТиповОбъектов";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ТаблицаТиповОбъектов = ПолучитьТаблицуТиповОбъектов();
	
	Контекст.Вставить(КлючКонтекста, ТаблицаТиповОбъектов);
	
	Возврат ТаблицаТиповОбъектов;
	
КонецФункции

// Возвращает значение свойства конфигурации "РежимСовместимости".
//
// Возвращаемое значение:
//   Строка - режим совместимости конфигурации.
//
Функция ПолучитьРежимСовместимости()
	
	КлючКонтекста = "РежимСовместимости";
	РежимСовместимости = Контекст[КлючКонтекста];
	Если РежимСовместимости <> Неопределено Тогда
		Возврат РежимСовместимости;
	КонецЕсли;
	
	КореньКонфигурации = ПолучитьКореньКонфигурации();
	
	РежимСовместимости = ПолучитьСвойство("РежимСовместимости", КореньКонфигурации);
	Если РежимСовместимости = Неопределено Тогда
		РежимСовместимости = "НеИспользовать";
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, РежимСовместимости);
	
	Возврат РежимСовместимости;
	
КонецФункции

// Получает номер версии платформы "1С:Предприятие", путь к которой указан в карточке проверяемой конфигурации.
// Номер версии состоит из 3-х чисел через точку (без номера сборки).
//
// Возвращаемое значение:
//   Строка - номер версии платформы.
//
Функция ПолучитьВерсиюПлатформы()
	
	КлючКонтекста = "ВерсияПлатформы";
	ВерсияПлатформы = Контекст[КлючКонтекста];
	Если ВерсияПлатформы <> Неопределено Тогда
		Возврат ВерсияПлатформы;
	КонецЕсли;

	СистемнаяИнформация = Новый СистемнаяИнформация;
	ВерсияПлатформыПоУмолчанию = СистемнаяИнформация.ВерсияПриложения;
	
	СтрокаЗапускаПлатформы = Версия.Владелец.СтрокаЗапускаПлатформы;
	
	Если ПустаяСтрока(СтрокаЗапускаПлатформы) Тогда
		
		ВерсияПлатформы = ВерсияПлатформыПоУмолчанию;
		
	Иначе
	
		СтрокаЗапускаПлатформы = СтрЗаменить(СтрокаЗапускаПлатформы, "/", "\");
		МассивКаталогов = СтрРазделить(СтрокаЗапускаПлатформы, "\", Ложь);
		
		КоличествоКаталогов = МассивКаталогов.Количество();
		
		Для НомерЭлемента = 0 По КоличествоКаталогов - 1 Цикл
			
			Каталог = МассивКаталогов[КоличествоКаталогов - 1 - НомерЭлемента];
			
			Если СтрЧислоВхождений(Каталог, ".") <> 3 Тогда
				Продолжить;
			КонецЕсли;
			
			МассивЭлементовВерсии = СтрРазделить(Каталог, ".", Ложь);
			
			ВсеЭлементыЧисла = Истина;
			Для Каждого ЭлементВерсии Из МассивЭлементовВерсии Цикл
				Если НЕ ЭтоЧисло(ЭлементВерсии) Тогда
					ВсеЭлементыЧисла = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ВсеЭлементыЧисла Тогда
				ВерсияПлатформы = Каталог;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если НЕ ЗначениеЗаполнено(ВерсияПлатформы) Тогда
			ВерсияПлатформы = ВерсияПлатформыПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
	ВерсияПлатформы = ПолучитьНомерВерсииБезСборки(ВерсияПлатформы);
	
	Контекст.Вставить(КлючКонтекста, ВерсияПлатформы);
	
	Возврат ВерсияПлатформы;
	
КонецФункции

// Возвращает номер версии подсистемы "СтандартныеПодсистемы" проверяемой конфигурации.
//
// Возвращаемое значение:
//   Строка - номер версии подсистемы БСП.
//   Если подсистема БСП не определена в проверяемой конфигурации, то возвращается пустая строка.
//
Функция ПолучитьВерсиюБСП()
	
	КлючКонтекста = "ВерсияБСП";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ВерсияБСП = "";
	
	ПодсистемаБСП = ПолучитьПодсистемуСтандартныеПодсистемы();
	Если НЕ ПодсистемаБСП.Пустая() Тогда
		ВерсияБСП = ПолучитьСвойство("Версия", ПодсистемаБСП);
		Если ВерсияБСП = Неопределено Тогда
			ВерсияБСП = "";
		КонецЕсли;
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ВерсияБСП);
	
	Возврат ВерсияБСП;
	
КонецФункции

// Получает соответствие разделителей слов в коде.
// Включает операторы языка платформы и различные знаки.
//
// Возвращаемое значение:
//   Соответствие - соответствие разделителей слов:
//     Ключ     - Строка - разделитель слов в верхнем регистре.
//     Значение - Булево - Истина.
//
Функция ПолучитьРазделителиСлов()
	
	КлючКонтекста = "РазделителиСлов";
	РазделителиСлов = Контекст[КлючКонтекста];
	Если РазделителиСлов <> Неопределено Тогда
		Возврат РазделителиСлов;
	КонецЕсли;
	
	РазделителиСлов = Новый Соответствие;
	РазделителиСлов.Вставить("ЕСЛИ", 				Истина);
	РазделителиСлов.Вставить("#ЕСЛИ", 				Истина);
	РазделителиСлов.Вставить("ИНАЧЕЕСЛИ", 			Истина);
	РазделителиСлов.Вставить("КОНЕЦЕСЛИ", 			Истина);
	РазделителиСлов.Вставить("#КОНЕЦЕСЛИ", 			Истина);
	РазделителиСлов.Вставить("ТОГДА", 				Истина);
	РазделителиСлов.Вставить("И", 					Истина);
	РазделителиСлов.Вставить("ИЛИ", 				Истина);
	РазделителиСлов.Вставить("НЕ", 					Истина);
	РазделителиСлов.Вставить("ИЗ", 					Истина);
	РазделителиСлов.Вставить("КАЖДОГО", 			Истина);
	РазделителиСлов.Вставить("ДЛЯ", 				Истина);
	РазделителиСлов.Вставить("ЦИКЛ", 				Истина);
	РазделителиСлов.Вставить("ПОКА", 				Истина);
	РазделителиСлов.Вставить("ПРОЦЕДУРА", 			Истина);
	РазделителиСлов.Вставить("ФУНКЦИЯ", 			Истина);
	РазделителиСлов.Вставить("КОНЕЦПРОЦЕДУРЫ", 		Истина);
	РазделителиСлов.Вставить("КОНЕЦФУНКЦИИ", 		Истина);
	РазделителиСлов.Вставить("ЭКСПОРТ", 			Истина);
	РазделителиСлов.Вставить("ПЕРЕМ", 				Истина);
	РазделителиСлов.Вставить("ЗНАЧ", 				Истина);
	РазделителиСлов.Вставить("НОВЫЙ", 				Истина);
	РазделителиСлов.Вставить("ПЕРЕЙТИ", 			Истина);
	РазделителиСлов.Вставить("ВЫЗВАТЬИСКЛЮЧЕНИЕ", 	Истина);
	РазделителиСлов.Вставить("ПОПЫТКА", 			Истина);
	РазделителиСлов.Вставить("ИСКЛЮЧЕНИЕ", 			Истина);
	РазделителиСлов.Вставить("КОНЕЦПОПЫТКИ", 		Истина);
	РазделителиСлов.Вставить("ДОБАВИТЬОБРАБОТЧИК", 	Истина);
	РазделителиСлов.Вставить("УДАЛИТЬОБРАБОТЧИК", 	Истина);
	РазделителиСлов.Вставить("ВОЗВРАТ", 			Истина);
	РазделителиСлов.Вставить("НЕОПРЕДЕЛЕНО", 		Истина);
	РазделителиСлов.Вставить("НЕОПРЕДЕЛЕНО;", 		Истина);
	РазделителиСлов.Вставить("НЕОПРЕДЕЛЕНО,", 		Истина);
	РазделителиСлов.Вставить("<", 					Истина);
	РазделителиСлов.Вставить(">", 					Истина);
	РазделителиСлов.Вставить("=", 					Истина);
	РазделителиСлов.Вставить("+", 					Истина);
	РазделителиСлов.Вставить("*", 					Истина);
	РазделителиСлов.Вставить("/", 					Истина);
	РазделителиСлов.Вставить("%", 					Истина);
	РазделителиСлов.Вставить(".", 					Истина);
	РазделителиСлов.Вставить(",", 					Истина);
	РазделителиСлов.Вставить(";", 					Истина);
	РазделителиСлов.Вставить("(", 					Истина);
	РазделителиСлов.Вставить(")", 					Истина);
	
	Контекст.Вставить(КлючКонтекста, РазделителиСлов);
	
	Возврат РазделителиСлов;
	
КонецФункции

// Получает таблицу служебных слов (операторов языка платформы) с положением их в строке кода.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица служебных слов с колонками:
//     Имя       - Строка - оператор языка платформы.
//     Положение - Строка - положение слова в строке ("Начало" или "Конец").
//
Функция ПолучитьТаблицуСлужебныхСлов()
	
	КлючКонтекста = "ТаблицаСлужебныхСлов";
	ТаблицаСлужебныхСлов = Контекст[КлючКонтекста];
	Если ТаблицаСлужебныхСлов <> Неопределено Тогда
		Возврат ТаблицаСлужебныхСлов;
	КонецЕсли;
	
	ТаблицаСлужебныхСлов = Новый ТаблицаЗначений;
	ТаблицаСлужебныхСлов.Колонки.Добавить("Имя");
	ТаблицаСлужебныхСлов.Колонки.Добавить("Положение");
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ТОГДА";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ЦИКЛ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ИНАЧЕ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "КОНЕЦФУНКЦИИ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "КОНЕЦПРОЦЕДУРЫ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ЭКСПОРТ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "КОНЕЦПОПЫТКИ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПРОДОЛЖИТЬ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПРЕРВАТЬ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ФУНКЦИЯ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПРОЦЕДУРА";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ЕСЛИ ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "КОНЕЦЕСЛИ";
	НоваяСтрока.Положение = "Конец";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ДЛЯ ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПЕРЕМ ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПОПЫТКА";
	НоваяСтрока.Положение = "Строка";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ИНАЧЕЕСЛИ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ПОКА ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ИСКЛЮЧЕНИЕ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "ВОЗВРАТ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "#ОБЛАСТЬ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "#КОНЕЦОБЛАСТИ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "|";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "#ЕСЛИ";
	НоваяСтрока.Положение = "Начало";
	
	НоваяСтрока = ТаблицаСлужебныхСлов.Добавить();
	НоваяСтрока.Имя = "#КОНЕЦЕСЛИ";
	НоваяСтрока.Положение = "Начало";
	
	Контекст.Вставить(КлючКонтекста, ТаблицаСлужебныхСлов);
	
	Возврат ТаблицаСлужебныхСлов;
	
КонецФункции

// Получает массив незначащих символов.
// Включает различные знаки, цифры и буквы английского алфавита.
//
// Возвращаемое значение:
//   Массив - массив незначащих символов.
//
Функция ПолучитьНезначащиеСимволы()
	
	КлючКонтекста = "НезначащиеСимволы";
	НезначащиеСимволы = Контекст[КлючКонтекста];
	Если НезначащиеСимволы <> Неопределено Тогда
		Возврат НезначащиеСимволы;
	КонецЕсли;
	
	НезначащиеСимволы = Новый Массив;
	
	НезначащиеСимволы.Добавить(";");
	НезначащиеСимволы.Добавить(".");
	НезначащиеСимволы.Добавить(",");
	НезначащиеСимволы.Добавить("/");
	НезначащиеСимволы.Добавить("|");
	НезначащиеСимволы.Добавить("\");
	НезначащиеСимволы.Добавить("_");
	НезначащиеСимволы.Добавить("!");
	НезначащиеСимволы.Добавить("@");
	НезначащиеСимволы.Добавить("#");
	НезначащиеСимволы.Добавить("$");
	НезначащиеСимволы.Добавить("%");
	НезначащиеСимволы.Добавить("^");
	НезначащиеСимволы.Добавить("&");
	НезначащиеСимволы.Добавить("*");
	НезначащиеСимволы.Добавить("+");
	НезначащиеСимволы.Добавить("-");
	НезначащиеСимволы.Добавить("(");
	НезначащиеСимволы.Добавить(")");
	НезначащиеСимволы.Добавить("[");
	НезначащиеСимволы.Добавить("]");
	НезначащиеСимволы.Добавить("{");
	НезначащиеСимволы.Добавить("}");
	НезначащиеСимволы.Добавить(":");
	НезначащиеСимволы.Добавить("<");
	НезначащиеСимволы.Добавить(">");
	НезначащиеСимволы.Добавить("~");
	НезначащиеСимволы.Добавить("=");
	НезначащиеСимволы.Добавить("?");
	НезначащиеСимволы.Добавить("'");
	
	НезначащиеСимволы.Добавить("0");
	НезначащиеСимволы.Добавить("1");
	НезначащиеСимволы.Добавить("2");
	НезначащиеСимволы.Добавить("3");
	НезначащиеСимволы.Добавить("4");
	НезначащиеСимволы.Добавить("5");
	НезначащиеСимволы.Добавить("6");
	НезначащиеСимволы.Добавить("7");
	НезначащиеСимволы.Добавить("8");
	НезначащиеСимволы.Добавить("9");
	
	НезначащиеСимволы.Добавить("Q");
	НезначащиеСимволы.Добавить("W");
	НезначащиеСимволы.Добавить("E");
	НезначащиеСимволы.Добавить("R");
	НезначащиеСимволы.Добавить("T");
	НезначащиеСимволы.Добавить("Y");
	НезначащиеСимволы.Добавить("U");
	НезначащиеСимволы.Добавить("I");
	НезначащиеСимволы.Добавить("O");
	НезначащиеСимволы.Добавить("P");
	НезначащиеСимволы.Добавить("A");
	НезначащиеСимволы.Добавить("S");
	НезначащиеСимволы.Добавить("D");
	НезначащиеСимволы.Добавить("F");
	НезначащиеСимволы.Добавить("G");
	НезначащиеСимволы.Добавить("H");
	НезначащиеСимволы.Добавить("J");
	НезначащиеСимволы.Добавить("K");
	НезначащиеСимволы.Добавить("L");
	НезначащиеСимволы.Добавить("Z");
	НезначащиеСимволы.Добавить("X");
	НезначащиеСимволы.Добавить("C");
	НезначащиеСимволы.Добавить("V");
	НезначащиеСимволы.Добавить("B");
	НезначащиеСимволы.Добавить("N");
	НезначащиеСимволы.Добавить("M");
	
	Контекст.Вставить(КлючКонтекста, НезначащиеСимволы);
	
	Возврат НезначащиеСимволы;
	
КонецФункции

// Получает массив вариантов обращения к объектам метаданных в ед. и мн.ч.
//
// Возвращаемое значение:
//   Массив - массив строк вызова объектов метаданных.
//
Функция ПолучитьСтрокиВызововОбъектовМетаданных()
	
	КлючКонтекста = "СтрокиВызововОбъектовМетаданных";
	СтрокиВызовов = Контекст[КлючКонтекста];
	Если СтрокиВызовов <> Неопределено Тогда
		Возврат СтрокиВызовов;
	КонецЕсли;
	
	СтрокиВызовов = Новый Массив;

	СтрокиВызовов.Добавить("Константа.");
	СтрокиВызовов.Добавить("Константы.");
	СтрокиВызовов.Добавить("Справочник.");
	СтрокиВызовов.Добавить("Справочники.");
	СтрокиВызовов.Добавить("Документ.");
	СтрокиВызовов.Добавить("Документы.");
	СтрокиВызовов.Добавить("Перечисление.");
	СтрокиВызовов.Добавить("Перечисления.");
	СтрокиВызовов.Добавить("Отчет.");
	СтрокиВызовов.Добавить("Отчеты.");
	СтрокиВызовов.Добавить("Обработка.");
	СтрокиВызовов.Добавить("Обработки.");
	СтрокиВызовов.Добавить("ЖурналДокументов.");
	СтрокиВызовов.Добавить("ЖурналыДокументов.");
	СтрокиВызовов.Добавить("ПланВидовХарактеристик.");
	СтрокиВызовов.Добавить("ПланыВидовХарактеристик.");
	СтрокиВызовов.Добавить("ПланСчетов.");
	СтрокиВызовов.Добавить("ПланыСчетов.");
	СтрокиВызовов.Добавить("ПланВидовРасчета.");
	СтрокиВызовов.Добавить("ПланыВидовРасчета.");
	СтрокиВызовов.Добавить("РегистрСведений.");
	СтрокиВызовов.Добавить("РегистрыСведений.");
	СтрокиВызовов.Добавить("РегистрНакопления.");
	СтрокиВызовов.Добавить("РегистрыНакопления.");
	СтрокиВызовов.Добавить("РегистрБухгалтерии.");
	СтрокиВызовов.Добавить("РегистрыБухгалтерии.");
	СтрокиВызовов.Добавить("РегистрРасчета.");
	СтрокиВызовов.Добавить("РегистрыРасчета.");
	СтрокиВызовов.Добавить("БизнесПроцесс.");
	СтрокиВызовов.Добавить("БизнесПроцессы.");
	СтрокиВызовов.Добавить("Задача.");
	СтрокиВызовов.Добавить("Задачи.");
	
	Контекст.Вставить(КлючКонтекста, СтрокиВызовов);
	
	Возврат СтрокиВызовов;
	
КонецФункции

// Получает массив строк текста запроса. Содержит секции и операторы запроса.
//
// Возвращаемое значение:
//   Массив - массив строк текста запроса.
//
Функция ПолучитьСтрокиТекстаЗапроса()
	
	КлючКонтекста = "СтрокиТекстаЗапроса";
	СтрокиЗапроса = Контекст[КлючКонтекста];
	Если СтрокиЗапроса <> Неопределено Тогда
		Возврат СтрокиЗапроса;
	КонецЕсли;
	
	СтрокиЗапроса = Новый Массив;
	СтрокиЗапроса.Добавить("ВЫБРАТЬ");
	СтрокиЗапроса.Добавить("Выбрать Первые");
	СтрокиЗапроса.Добавить("Выбрать *");
	СтрокиЗапроса.Добавить("ПЕРВЫЕ");
	СтрокиЗапроса.Добавить("РАЗЛИЧНЫЕ");
	СтрокиЗапроса.Добавить("ИЗ");
	СтрокиЗапроса.Добавить("ГДЕ");
	СтрокиЗапроса.Добавить("ИСТИНА");
	СтрокиЗапроса.Добавить("ЛОЖЬ");
	СтрокиЗапроса.Добавить("ПОМЕСТИТЬ");
	СтрокиЗапроса.Добавить("ВЫРАЗИТЬ");
	СтрокиЗапроса.Добавить("ВЫБОР");
	СтрокиЗапроса.Добавить("КОГДА");
	СтрокиЗапроса.Добавить("ТОГДА");
	СтрокиЗапроса.Добавить("ИНАЧЕ");
	СтрокиЗапроса.Добавить("КОНЕЦ");
	СтрокиЗапроса.Добавить("ИНДЕКСИРОВАТЬ");
	СтрокиЗапроса.Добавить("УПОРЯДОЧИТЬ");
	СтрокиЗапроса.Добавить("СГРУППИРОВАТЬ");
	СтрокиЗапроса.Добавить("ИМЕЮЩИЕ");
	СтрокиЗапроса.Добавить("ОБЪЕДИНИТЬ");
	СтрокиЗапроса.Добавить("УНИЧТОЖИТЬ");
	СтрокиЗапроса.Добавить("NULL");
	СтрокиЗапроса.Добавить("КАК");
	СтрокиЗапроса.Добавить(" Как ");
	СтрокиЗапроса.Добавить("ВОЗР");
	СтрокиЗапроса.Добавить("Возр");
	СтрокиЗапроса.Добавить("возр");
	СтрокиЗапроса.Добавить("УБЫВ");
	СтрокиЗапроса.Добавить("Убыв");
	СтрокиЗапроса.Добавить("ИТОГИ");
	СтрокиЗапроса.Добавить("В (");
	СтрокиЗапроса.Добавить("В(");
	СтрокиЗапроса.Добавить("В ИЕРАРХИИ");
	СтрокиЗапроса.Добавить("ПЕРВЫЕ");
	СтрокиЗапроса.Добавить("ПОДОБНО");
	СтрокиЗапроса.Добавить("ПОМЕСТИТЬ");
	СтрокиЗапроса.Добавить("СОЕДИНЕНИЕ");
	СтрокиЗапроса.Добавить("ПО");
	СтрокиЗапроса.Добавить("НЕОПРЕДЕЛЕНО");
	СтрокиЗапроса.Добавить("ЗНАЧЕНИЕ");
	СтрокиЗапроса.Добавить("СУММА(");
	СтрокиЗапроса.Добавить("МЕЖДУ");
	СтрокиЗапроса.Добавить("НЕ ");
	СтрокиЗапроса.Добавить(" = &");
	СтрокиЗапроса.Добавить("ИЛИ");
	СтрокиЗапроса.Добавить(".ЭтоГруппа");
	СтрокиЗапроса.Добавить(".Ссылка");
	СтрокиЗапроса.Добавить("ДОБАВИТЬКДАТЕ(");
	
	// Просто текст "И " нельзя считать строкой запроса, т.к. такое написание часто встречается в сообщениях пользователю.
	// Добавляем примеры реальных запросов для "И".
	СтрокиЗапроса.Добавить("	И ");
	СтрокиЗапроса.Добавить("И Таблица");
	СтрокиЗапроса.Добавить("И (Таблица");
	СтрокиЗапроса.Добавить("И (&");
	СтрокиЗапроса.Добавить("И ДокументПоиска.");
	СтрокиЗапроса.Добавить("И ТабличнаяЧасть.");
	СтрокиЗапроса.Добавить("И СправочникСопоставления.");
	СтрокиЗапроса.Добавить("И ДатыНачалаИнтервалов.");
	СтрокиЗапроса.Добавить("И Истина");
	СтрокиЗапроса.Добавить("И ПоказателиРасчетаЗарплаты.");
	СтрокиЗапроса.Добавить("И Не ");
	
	Контекст.Вставить(КлючКонтекста, СтрокиЗапроса);
	
	Возврат СтрокиЗапроса;
	
КонецФункции

// Получает соответствие проверки латинских символов.
// Содержит правильные слова и строки без случайных латинских символов.
//
// Возвращаемое значение:
//   Соответствие - соответствие проверки латинских символов:
//     Ключ     - Строка - строка или слово без случайных латинских символов.
//     Значение - Булево - Истина.
//
Функция ПолучитьСоответствиеПроверкиЛатинскихСимволов()
	
	КлючКонтекста = "ПроверкаЛатинскихСимволов";
	ПроверкаЛатинскихСимволов = Контекст[КлючКонтекста];
	Если ПроверкаЛатинскихСимволов <> Неопределено Тогда
		Возврат ПроверкаЛатинскихСимволов;
	КонецЕсли;
	
	ПроверкаЛатинскихСимволов = Новый Соответствие;
	
	Контекст.Вставить(КлючКонтекста, ПроверкаЛатинскихСимволов);
	
	Возврат ПроверкаЛатинскихСимволов;
	
КонецФункции

// Устанавливает соответствие проверки латинских символов.
//
// Параметры:
//   Соответствие - соответствие проверки латинских символов:
//     Ключ     - Строка - строка или слово без случайных латинских символов.
//     Значение - Булево - Истина.
//
Процедура УстановитьСоответствиеПроверкиЛатинскихСимволов(ПроверкаЛатинскихСимволов)
	
	КлючКонтекста = "ПроверкаЛатинскихСимволов";
	Контекст.Вставить(КлючКонтекста, ПроверкаЛатинскихСимволов);
	
КонецПроцедуры

// Получает массив слов по заглавным буквам из связного слова.
//
// Параметры:
//   СвязноеСлово - Строка - связное слово, например, "СвязноеСлово".
//
// Возвращаемое значение:
//   Массив - массив слов по заглавным буквам.
//
Функция ПолучитьМассивСловПоЗаглавнымБуквам(СвязноеСлово)
	
	Возврат Проверка.ПолучитьМассивСловПоЗаглавнымБуквам(СвязноеСлово);
	
КонецФункции

// Ищет функцию "РолиДоступны()" в общем модуле "Пользователи" проверяемой конфигурации.
// Если нашла, возвращает Истину, иначе Ложь.
//
// Возвращаемое значение:
//   Булево - флаг существования функции "РолиДоступны()" в общем модуле "Пользователи".
//
Функция ПолучитьФлагФункцияРолиДоступныСуществует()
	
	КлючКонтекста = "ФлагФункцияРолиДоступныСуществует";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ФлагФункцияРолиДоступныСуществует = Ложь;
	
	ОбщийМодульПользователи = ПолучитьЭлементСтруктурыМетаданных(Версия,, "Пользователи",
		Перечисления.ТипыОбъектов.ОбщийМодуль, Расширение);
	
	Если НЕ ОбщийМодульПользователи.Пустая() Тогда
		
		ТекстРолиДоступны = ВРег("РолиДоступны");
		
		ВсеМодулиОбъекта = ПолучитьСоставМодулей(ОбщийМодульПользователи);
		Для Каждого МодульОбъекта Из ВсеМодулиОбъекта Цикл
			
			ТаблицаМетодов = ПолучитьТаблицуМетодовМодуля(МодульОбъекта, ОбщийМодульПользователи);
			
			Метод = ТаблицаМетодов.Найти(ТекстРолиДоступны, "ИмяМетодаВРег");
			Если Метод <> Неопределено Тогда
				ФлагФункцияРолиДоступныСуществует = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Контекст.Вставить(КлючКонтекста, ФлагФункцияРолиДоступныСуществует);
	
	Возврат ФлагФункцияРолиДоступныСуществует;
	
КонецФункции

// Получает соответствие наименований прикладных объектов метаданных и их ссылок.
//
// Возвращаемое значение:
//   Соответствие - соответствие прикладных объектов метаданных:
//     Ключ     - полный путь к объекту метаданных в верхнем регистре.
//     Значение - ссылка на объект.
//
Функция ПолучитьСоответствиеПрикладныхОбъектов()
	
	КлючКонтекста = "СоответствиеПрикладныхОбъектов";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	МассивТиповПрикладныхОбъектов = Новый Массив;
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Константа);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Справочник);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Документ);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.ЖурналДокументов);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Перечисление);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Отчет);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Обработка);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.ПланВидовХарактеристик);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.ПланСчетов);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.ПланВидовРасчета);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.РегистрСведений);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.РегистрНакопления);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.РегистрБухгалтерии);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.РегистрРасчета);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.БизнесПроцесс);
	МассивТиповПрикладныхОбъектов.Добавить(Перечисления.ТипыОбъектов.Задача);
	
	ТаблицаОбъектовКонфигурации = ПолучитьОбъектыКонфигурации();
	ТаблицаОбъектовКонфигурации.Индексы.Добавить("ТипОбъекта");
	
	СтруктураОтбора = Новый Структура;
	
	СоответствиеПрикладныхОбъектов = Новый Соответствие;
	
	Для Каждого ТипПрикладныхОбъектов Из МассивТиповПрикладныхОбъектов Цикл
		
		СтруктураОтбора.Вставить("ТипОбъекта", ТипПрикладныхОбъектов);
		
		МассивОбъектов = ТаблицаОбъектовКонфигурации.НайтиСтроки(СтруктураОтбора);
		Для Каждого СтрокаОбъекта Из МассивОбъектов Цикл
			СоответствиеПрикладныхОбъектов.Вставить(ВРег(СтрокаОбъекта.Путь), СтрокаОбъекта.Ссылка);
		КонецЦикла;
		
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, СоответствиеПрикладныхОбъектов);
	
	Возврат СоответствиеПрикладныхОбъектов;
	
КонецФункции

// Получает таблицу ключевых слов запроса. Содержит секции и операторы запроса.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ключевых слов запроса с колонками:
//     Эталон          - Строка - ключевое слово запроса в верхнем регистре.
//     ЭталонДляПоиска - Строка - ключевое слово запроса в верхнем регистре с пробелами по краям.
//     ДлинаЭталона    - Число  - длина строки ключевого слова (Эталона).
//
Функция ПолучитьТаблицуКлючевыхСловЗапроса()
	
	КлючКонтекста = "ТаблицаКлючевыхСловЗапроса";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	// Составляем набор эталонов.
	// "ПО" и "В" не проверяем, т.к. находится много ложных случаев (строковые константы в запросе).
	МассивЭталонов = Новый Массив;
	МассивЭталонов.Добавить("ВЫБРАТЬ");
	МассивЭталонов.Добавить("КАК");
	МассивЭталонов.Добавить("ПОМЕСТИТЬ");
	МассивЭталонов.Добавить("УНИЧТОЖИТЬ");
	МассивЭталонов.Добавить("АВТОУПОРЯДОЧИВАНИЕ");
	МассивЭталонов.Добавить("ИЕРАРХИЯ");
	МассивЭталонов.Добавить("ВЫБОР");
	МассивЭталонов.Добавить("ТОГДА");
	МассивЭталонов.Добавить("КОГДА");
	МассивЭталонов.Добавить("ЕСЛИ");
	МассивЭталонов.Добавить("КОНЕЦ");
	МассивЭталонов.Добавить("ИНАЧЕ");
	МассивЭталонов.Добавить("МЕЖДУ");
	МассивЭталонов.Добавить("ИЕРАРХИИ");
	МассивЭталонов.Добавить("ПОДОБНО");
	МассивЭталонов.Добавить("ИМЕЮЩИЕ");
	МассивЭталонов.Добавить("УПОРЯДОЧИТЬ");
	МассивЭталонов.Добавить("ГДЕ");
	МассивЭталонов.Добавить("ИЗ");
	МассивЭталонов.Добавить("ИСТИНА");
	МассивЭталонов.Добавить("ЛОЖЬ");
	МассивЭталонов.Добавить("ПЕРВЫЕ");
	МассивЭталонов.Добавить("РАЗРЕШЕННЫЕ");
	МассивЭталонов.Добавить("ИТОГИ");
	МассивЭталонов.Добавить("ПОЛНОЕ");
	МассивЭталонов.Добавить("СОЕДИНЕНИЕ");
	МассивЭталонов.Добавить("ЛЕВОЕ");
	МассивЭталонов.Добавить("ПРАВОЕ");
	МассивЭталонов.Добавить("ВНУТРЕННЕЕ");
	МассивЭталонов.Добавить("РАЗЛИЧНЫЕ");
	МассивЭталонов.Добавить("УБЫВ");
	МассивЭталонов.Добавить("ВОЗР");
	МассивЭталонов.Добавить("СГРУППИРОВАТЬ");
	МассивЭталонов.Добавить("ОБЩИЕ");
	МассивЭталонов.Добавить("НЕ");
	МассивЭталонов.Добавить("И");
	МассивЭталонов.Добавить("ИЛИ");
	МассивЭталонов.Добавить("ЕСТЬ");
	МассивЭталонов.Добавить("NULL");
	МассивЭталонов.Добавить("ОБЪЕДИНИТЬ");
	МассивЭталонов.Добавить("ВСЕ");
	
	ТаблицаЭталонов = Новый ТаблицаЗначений;
	ТаблицаЭталонов.Колонки.Добавить("Эталон");
	ТаблицаЭталонов.Колонки.Добавить("ЭталонДляПоиска");
	ТаблицаЭталонов.Колонки.Добавить("ДлинаЭталона");
	
	Для Каждого Эталон Из МассивЭталонов Цикл
		СтрокаЭталона = ТаблицаЭталонов.Добавить();
		СтрокаЭталона.Эталон = Эталон;
		СтрокаЭталона.ЭталонДляПоиска = " " + Эталон + " ";
		СтрокаЭталона.ДлинаЭталона = СтрДлина(Эталон);
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, ТаблицаЭталонов);
	
	Возврат ТаблицаЭталонов;
	
КонецФункции

// Возвращает флаг соответствия строковой константы правилам образования имен переменных.
//
// Параметры:
//   СтроковаяКонстанта - Строка - строковая константа.
//
// Возвращаемое значение:
//   Булево - Истина, если соответствует, иначе Ложь.
//
Функция СтроковаяКонстантаСоответствуетПравиламОбразованияИменПеременных(СтроковаяКонстанта)
	
	Структура = Новый Структура;
	Попытка
		Структура.Вставить(СтроковаяКонстанта);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Если СтрДлина(СтроковаяКонстанта) = 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрНачинаетсяС(СтроковаяКонстанта, "_") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает преобразованный текст для сравнения.
// Убирает лишние символы и текст для удаления из переданного текста.
//
// Параметры:
//   Текст            - Строка - исходный текст.
//   ТекстДляУдаления - Строка - текст, который будет удален из исходного текста.
//
// Возвращаемое значение:
//   Строка - преобразованный текст.
//
Функция ПреобразоватьТекстДляСравнения(Знач Текст, ТекстДляУдаления = "Группа")
	
	СтрокаСимволов = " ,.;""'!?\/_" + Символы.Таб + Символы.ПС;
	
	ПреобразованныйТекст = ВРег(Текст);
	
	КоличествоСимволов = СтрДлина(СтрокаСимволов);
	Для НомерСимвола = 1 По КоличествоСимволов Цикл
		Символ = Сред(СтрокаСимволов, НомерСимвола, 1);
		ПреобразованныйТекст = СтрЗаменить(ПреобразованныйТекст, Символ, "");
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекстДляУдаления) Тогда
		ПреобразованныйТекст = СтрЗаменить(ПреобразованныйТекст, ВРег(ТекстДляУдаления), "");
	КонецЕсли;
	
	Возврат ПреобразованныйТекст;
	
КонецФункции

// Возвращает таблицу типов обнаруживаемых ошибок из правила "Платформенная проверка конфигурации".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица типов ошибок платформенной проверки. Колонки:
//     Наименование - Строка                                - наименование ошибки в верхнем регистре.
//     НомерСтроки  - Число                                 - номер ошибки в табличной части правила проверки.
//     Ошибка       - СправочникСсылка.ОбнаруживаемыеОшибки - ссылка на ошибку.
//     ИскатьВызов  - Булево                                - флаг, надо ли искать вызов метода.
//
Функция ПолучитьТипыОшибокПлатформеннойПроверки()
	
	КлючКонтекста = "ТипыОшибокПлатформеннойПроверки";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	НаименованиеПравилаПлатформеннойПроверки = НСтр("ru='Платформенная проверка конфигурации'");
	
	ПравилоПлатформеннойПроверки = ТекущееПравило;
	Если (ПравилоПлатформеннойПроверки = Неопределено)
	 ИЛИ (СтрСравнить(ПравилоПлатформеннойПроверки.Наименование, НаименованиеПравилаПлатформеннойПроверки) <> 0) Тогда
		
		ТребованиеПлатформеннойПроверки = Справочники.Требования.ПлатформеннаяПроверкаКонфигурации;
		ТаблицаПравил = ТребованиеПлатформеннойПроверки.РеализацияТребования.Выгрузить();
		Если ТаблицаПравил.Количество() = 0 Тогда
			ПравилоПлатформеннойПроверки = Справочники.Правила.НайтиПоНаименованию(НаименованиеПравилаПлатформеннойПроверки);
		Иначе
			ПравилоПлатформеннойПроверки = ТаблицаПравил[0].ПравилоПроверки;
		КонецЕсли;
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПравилоПлатформеннойПроверки) Тогда
		
		ТаблицаТиповОшибокПлатформеннойПроверки = Новый ТаблицаЗначений;
		ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("НомерСтроки");
		ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("Ошибка");
		ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("Наименование");
		ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("ИскатьВызов");
		
		Возврат ТаблицаТиповОшибокПлатформеннойПроверки;
		
	КонецЕсли;
	
	МассивТиповОшибокИскатьВызов = Новый Массив;
	МассивТиповОшибокИскатьВызов.Добавить(ВРег(НСтр("ru='Использование модального вызова'")));
	МассивТиповОшибокИскатьВызов.Добавить(ВРег(НСтр("ru='Использование синхронного вызова'")));
	
	// Получим номера ошибок и их текст из правила платформенной проверки.
	ТаблицаТиповОшибокПлатформеннойПроверки = ПравилоПлатформеннойПроверки.ОбнаруживаемыеОшибки.Выгрузить();
	ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("Наименование");
	ТаблицаТиповОшибокПлатформеннойПроверки.Колонки.Добавить("ИскатьВызов");
	Для Каждого СтрокаОшибки Из ТаблицаТиповОшибокПлатформеннойПроверки Цикл
		
		ОшибкаСсылка = СтрокаОшибки.Ошибка;
		ОшибкаНаименование = ВРег(ОшибкаСсылка.Наименование);
		ОшибкаНаименование = СтрЗаменить(ОшибкаНаименование, ".", "");
		
		ПозицияДвоеточия = СтрНайти(ОшибкаНаименование, ":");
		Если ПозицияДвоеточия > 0 Тогда
			ОшибкаНаименование = Сред(ОшибкаНаименование, ПозицияДвоеточия + 1);
		КонецЕсли;
		
		ОшибкаНаименование = СокрЛП(ОшибкаНаименование);
		СтрокаОшибки.Наименование = ОшибкаНаименование;
		СтрокаОшибки.ИскатьВызов = (МассивТиповОшибокИскатьВызов.Найти(ОшибкаНаименование) <> Неопределено);
		
	КонецЦикла;
	
	Контекст.Вставить(КлючКонтекста, ТаблицаТиповОшибокПлатформеннойПроверки);
	
	Возврат ТаблицаТиповОшибокПлатформеннойПроверки;
	
КонецФункции

// Получает таблицу ошибок платформенной проверки всех объектов конфигурации.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок платформенной проверки:
//     Уточнение        - Строка                                 - уточнение ошибки.
//     МестоОбнаружения - Строка                                 - место обнаружения ошибки.
//     Объект           - СправочникСсылка.СтруктураКонфигурации - ссылка объект конфигурации.
//
Функция ПолучитьОшибкиПлатформеннойПроверки()
	
	КлючКонтекста = "ОшибкиПлатформеннойПроверки";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ЗапросПоОшибкамПлатформеннойПроверки = Новый Запрос;
	ЗапросПоОшибкамПлатформеннойПроверки.Текст = "
	|ВЫБРАТЬ
	|	ОшибкиПроверкиКонфигурации.Уточнение,
	|	ОшибкиПроверкиКонфигурации.МестоОбнаружения,
	|	ОшибкиПроверкиКонфигурации.Объект
	|ИЗ
	|	РегистрСведений.ОшибкиПроверкиКонфигурации КАК ОшибкиПроверкиКонфигурации
	|ГДЕ
	|	ОшибкиПроверкиКонфигурации.Версия = &Версия
	|	И ОшибкиПроверкиКонфигурации.Объект.Расширение = &Расширение";
	
	ЗапросПоОшибкамПлатформеннойПроверки.УстановитьПараметр("Версия", Версия);
	ЗапросПоОшибкамПлатформеннойПроверки.УстановитьПараметр("Расширение", Расширение);
	
	ТаблицаОшибокПлатформеннойПроверки = ЗапросПоОшибкамПлатформеннойПроверки.Выполнить().Выгрузить();
	ТаблицаОшибокПлатформеннойПроверки.Индексы.Добавить("Объект");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОшибокПлатформеннойПроверки);
	
	Возврат ТаблицаОшибокПлатформеннойПроверки;
	
КонецФункции

// Получает таблицу ошибок платформенной проверки указанного объекта конфигурации.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается таблица ошибок текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок платформенной проверки:
//     Уточнение        - Строка                                 - уточнение ошибки.
//     МестоОбнаружения - Строка                                 - место обнаружения ошибки.
//     Объект           - СправочникСсылка.СтруктураКонфигурации - ссылка объект конфигурации.
//
Функция ПолучитьОшибкиПлатформеннойПроверкиОбъекта(ОбъектКонфигурации = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектКонфигурации = Неопределено) ИЛИ (ОбъектКонфигурации = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьОшибкиПлатформеннойПроверкиОбъекта";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТаблицаОшибокПлатформеннойПроверки = ПолучитьОшибкиПлатформеннойПроверки();
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектКонфигурации);
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Объект", ОбъектСсылка);
	ТаблицаОшибокОбъекта = ТаблицаОшибокПлатформеннойПроверки.Скопировать(СтруктураОтбора);
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаОшибокОбъекта);
	КонецЕсли;
	
	Возврат ТаблицаОшибокОбъекта;
	
КонецФункции

// Возвращает структуру данных для проверки.
// Функция пока используется только в правиле проверки
// "Контроль наличия общего модуля, подсистемы, метода и контроль состава параметров".
//
// Возвращаемое значение:
//   Структура - структура данных для проверки, ключи и значения:
//     ТаблицаМетодыМодулей - ТаблицаЗначений - таблица с методами модулей.
//     ТаблицаВызововМодулей - ТаблицаЗначений - таблица с вызовами модулей.
//     СоответствиеВызововМодулей - Соответствие - соответствие вызовов модулей.
//     СоответствиеПодсистем - Соответствие - соответствие подсистем.
//     ПлатформенныеМетодыТаблиц - Соответствие - соответствие методов для таблиц.
//     ПлатформенныеМетодыОбъектов - Соответствие - соответствие платформенных объектов.
//
Функция ПолучитьСтруктуруДанныхДляПравилаПроверкиКонтрольНаличия()
	
	КлючКонтекста = СтрШаблон("СтруктураДанныхДляПравилаПроверкиКонтрольНаличия_%1", ОбъектПроверкиЭтоРасширение);
	СтруктураДанных = Контекст[КлючКонтекста];
	Если СтруктураДанных <> Неопределено Тогда
		Возврат СтруктураДанных;
	КонецЕсли;
	
	СтрДлинаТекстОбщиеПодсистемы = СтрДлина("Общие.Подсистемы.") + 1;
	
	// Создадим таблицу, содержащую описание методов общих модулей, чтобы проверять по ней каждый модуль.
	ТаблицаМетодыМодулей = Новый ТаблицаЗначений;
	ТаблицаМетодыМодулей.Колонки.Добавить("ИмяМодуля");
	ТаблицаМетодыМодулей.Колонки.Добавить("ИмяМетода");
	ТаблицаМетодыМодулей.Колонки.Добавить("ОписаниеМетода");
	ТаблицаМетодыМодулей.Колонки.Добавить("МассивПараметров");
	ТаблицаМетодыМодулей.Колонки.Добавить("ТипМетода");
	ТаблицаМетодыМодулей.Колонки.Добавить("НомерСтроки");
	ТаблицаМетодыМодулей.Колонки.Добавить("Объект");
	
	СтруктураОтбораЭкспортныхМетодов = Новый Структура("ЕстьЭкспорт", Истина);
	
	// Если проверяется объект расширения, то получаем таблицу объектов основной конфигурации и расширения.
	Если ОбъектПроверкиЭтоРасширение Тогда
		ТаблицаОбщиеМодулиИМодулиМенеджеровРасширения = ПолучитьТаблицуОбъектовОбщиеМодулиИМодулиМенеджера(Расширение);
		ТаблицаОбщиеМодулиИМодулиМенеджеров = ПолучитьТаблицуОбъектовОбщиеМодулиИМодулиМенеджера(Справочники.Расширения.ПустаяСсылка());
		
		// Объединяем таблицы объектов конфигурации и расширения.
		Для Каждого СтрокаТаблицы Из ТаблицаОбщиеМодулиИМодулиМенеджеровРасширения Цикл
			ЗаполнитьЗначенияСвойств(ТаблицаОбщиеМодулиИМодулиМенеджеров.Добавить(), СтрокаТаблицы);
		КонецЦикла;
	Иначе
		// Иначе только объектов конфигурации.
		ТаблицаОбщиеМодулиИМодулиМенеджеров = ПолучитьТаблицуОбъектовОбщиеМодулиИМодулиМенеджера();
	КонецЕсли;
	
	ТаблицаВызововМодулей = Новый ТаблицаЗначений;
	ТаблицаВызововМодулей.Колонки.Добавить("ИмяМодуля");
	ТаблицаВызововМодулей.Колонки.Добавить("ВызовМодуля");
	ТаблицаВызововМодулей.Колонки.Добавить("ИмяПеременной", Новый ОписаниеТипов("Строка"));
	ТаблицаВызововМодулей.Колонки.Добавить("ПозицияОпределения");
	ТаблицаВызововМодулей.Колонки.Добавить("ПозицияПереопределения");
	
	СоответствиеВызововМодулей = Новый Соответствие;
	
#Область СборМетодовМодулей
	
	// Обход общих модулей для формирования описания определений методов.
	Для Каждого СтрокаОбъекта Из ТаблицаОбщиеМодулиИМодулиМенеджеров Цикл
		
		ОбъектСсылка = СтрокаОбъекта.Объект;
		ОбъектИмя = СтрокаОбъекта.Имя;
		
		ЭтоОбщийМодуль = (СтрокаОбъекта.ТипОбъекта = Перечисления.ТипыОбъектов.ОбщийМодуль);
		ИмяМодуля = ?(ЭтоОбщийМодуль, "", СтрокаОбъекта.ИмяРодителя + ".") + ОбъектИмя;
		ИмяМодуля = ВРег(ИмяМодуля);
		
		ВызовМодуля = ТаблицаВызововМодулей.Добавить();
		ВызовМодуля.ИмяМодуля = ИмяМодуля;
		ВызовМодуля.ВызовМодуля = ИмяМодуля + ".";
		
		СоответствиеВызововМодулей.Вставить(ИмяМодуля, ВызовМодуля);
		
		ВсеМодулиОбъекта = ПолучитьСоставМодулей(ОбъектСсылка);
		Для Каждого МодульОбъекта Из ВсеМодулиОбъекта Цикл
			
			// Проверяем только общие модули и модули менеджера, в остальных случаях невозможно отследить объект.
			Если (МодульОбъекта <> Перечисления.ИдентификаторыСодержанияОбъектов.МодульМенеджера)
			   И (МодульОбъекта <> Перечисления.ИдентификаторыСодержанияОбъектов.Модуль) Тогда
				Продолжить;
			КонецЕсли;
			
			ТаблицаМетодов = ПолучитьТаблицуМетодовМодуля(МодульОбъекта, ОбъектСсылка);
			МассивЭкспортныхМетодов = ТаблицаМетодов.НайтиСтроки(СтруктураОтбораЭкспортныхМетодов);
			
			Для Каждого СтрокаМетода Из МассивЭкспортныхМетодов Цикл
				
				НовыйМетод = ТаблицаМетодыМодулей.Добавить();
				
				НовыйМетод.ИмяМодуля = ИмяМодуля;
				НовыйМетод.ИмяМетода = ВРег(СтрокаМетода.ИмяМетода);
				НовыйМетод.ОписаниеМетода = СтрокаМетода.ОписаниеМетода;
				НовыйМетод.МассивПараметров = СтрокаМетода.МассивПараметров;
				НовыйМетод.ТипМетода = СтрокаМетода.ТипМетода;
				НовыйМетод.НомерСтроки = СтрокаМетода.НомерСтрокиНачало;
				НовыйМетод.Объект = ОбъектСсылка;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
#КонецОбласти
	
	ТаблицаМетодыМодулей.Индексы.Добавить("ИмяМодуля, ИмяМетода");
	
	// Заполним соответствие подсистем для поиска в нем.
	ТаблицаПодсистем = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.Подсистема);
	СоответствиеПодсистем = Новый Соответствие;
	Для Каждого Подсистема Из ТаблицаПодсистем Цикл
		ПодсистемаПуть = Подсистема.Путь;
		ПодсистемаИмя = Сред(ПодсистемаПуть, СтрДлинаТекстОбщиеПодсистемы);
		СоответствиеПодсистем.Вставить(ВРег(ПодсистемаИмя), Подсистема.Ссылка);
	КонецЦикла;
	
	// Составим исключения для методов, которые скорее всего являются методами таблиц (ТЗ, ТП, ТЧ, реквизитов и т.д.),
	// но бывает, что при этом, например, совпадают имена ТЧ и общего модуля, в итоге регистрируется ложная ошибка.
	ПлатформенныеМетодыТаблиц = Новый Соответствие;
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Вставить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("ВыбратьСтроку"), 		Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Выгрузить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("ВыгрузитьКолонки"), 	Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("ВыгрузитьКолонку"), 	Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Добавить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Загрузить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("ЗагрузитьКолонку"), 	Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("ЗаполнитьЗначения"), 	Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Индекс"), 				Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Итог"), 				Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Количество"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Найти"), 				Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("НайтиСтроки"), 		Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Очистить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Получить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Свернуть"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Сдвинуть"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Скопировать"), 		Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("СкопироватьКолонки"), 	Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Сортировать"), 		Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Удалить"), 			Истина);
	ПлатформенныеМетодыТаблиц.Вставить(ВРег("Колонки.Добавить"), 	Истина);
	
	// Составим исключения для методов, которые скорее всего являются платформенными методами объектов метаданных,
	// например, ОрганизацияПустаяСсылка = ОбщегоНазначения.ОбщийМодуль("Справочники.Организации").ПустаяСсылка();
	ПлатформенныеМетодыОбъектов = Новый Соответствие;
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("Выбрать"), 										Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ВыбратьИерархически"), 							Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("НайтиПоКоду"), 									Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("НайтиПоНаименованию"), 							Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("НайтиПоРеквизиту"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьДанныеВыбора"), 							Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьИмяПредопределенного"), 					Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьИнициализациюПредопределенныхДанных"), 	Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьМакет"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьОбновлениеПредопределенныхДанных"), 		Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьСсылку"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФорму"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФормуВыбора"), 							Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФормуВыбораГруппы"), 					Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФормуНовогоЭлемента"), 					Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФормуНовойГруппы"), 						Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПолучитьФормуСписка"), 							Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("ПустаяСсылка"), 									Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("СоздатьГруппу"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("СоздатьЭлемент"), 								Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("УстановитьИнициализациюПредопределенныхДанных"), Истина);
	ПлатформенныеМетодыОбъектов.Вставить(ВРег("УстановитьОбновлениеПредопределенныхДанных"), 	Истина);
	
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("ТаблицаМетодыМодулей", ТаблицаМетодыМодулей);
	СтруктураДанных.Вставить("ТаблицаВызововМодулей", ТаблицаВызововМодулей);
	СтруктураДанных.Вставить("СоответствиеВызововМодулей", СоответствиеВызововМодулей);
	СтруктураДанных.Вставить("СоответствиеПодсистем", СоответствиеПодсистем);
	СтруктураДанных.Вставить("ПлатформенныеМетодыТаблиц", ПлатформенныеМетодыТаблиц);
	СтруктураДанных.Вставить("ПлатформенныеМетодыОбъектов", ПлатформенныеМетодыОбъектов);
	
	Контекст.Вставить(КлючКонтекста, СтруктураДанных);
	
	Возврат СтруктураДанных;
	
КонецФункции

// Возвращает структуру данных из места обнаружения, состоящую из типа модуля и номера строки.
//
// Параметры:
//   МестоОбнаружения - Строка - место обнаружения ошибки, как правило в виде "Модуль, стр. 100".
//
// Возвращаемое значение:
//   Структура - структура данных, состоящая из типа модуля и номера строки:
//     ТипМодуля   - ПеречислениеСсылка.ИдентификаторыСодержанияОбъектов - тип модуля.
//     НомерСтроки - Число                                               - номер строки.
//
Функция ПолучитьТипМодуляИНомерСтрокиИзМестаОбнаружения(МестоОбнаружения)
	
	СтруктураОшибки = Новый Структура;
	СтруктураОшибки.Вставить("ТипМодуля", Перечисления.ИдентификаторыСодержанияОбъектов.ПустаяСсылка());
	СтруктураОшибки.Вставить("НомерСтроки", 0);
	
	Если ПустаяСтрока(МестоОбнаружения) Тогда
		Возврат СтруктураОшибки;
	КонецЕсли;
	
	// Разделяем место обнаружения на части по запятой.
	МассивЧастейМестаОбнаружения = СтрРазделить(МестоОбнаружения, ",");
	
	// И пытаемся выделить тип модуля из места обнаружения.
	ТипМодуляСтрока = МассивЧастейМестаОбнаружения[0];
	ТипМодуляСтрока = СтрЗаменить(ТипМодуляСтрока, " ", "");
	
	ТипМодуляОбъект = Метаданные.Перечисления.ИдентификаторыСодержанияОбъектов.ЗначенияПеречисления.Найти(ТипМодуляСтрока);
	Если ТипМодуляОбъект <> Неопределено Тогда
		ТипМодуляСтрока = ТипМодуляОбъект.Имя;
		ТипМодуляСсылка = ИмяСостСвойства[ТипМодуляСтрока];
		
		СтруктураОшибки.Вставить("ТипМодуля", ТипМодуляСсылка);
	КонецЕсли;
	
	// Если количество частей места обнаружения меньше 2-х, значит, номер строки не указан, выходим.
	Если МассивЧастейМестаОбнаружения.Количество() < 2 Тогда
		Возврат СтруктураОшибки;
	КонецЕсли;
	
	// Получаем номер строки и пишем ошибку.
	НомерСтроки = МассивЧастейМестаОбнаружения[1];
	НомерСтроки = ВРег(НомерСтроки);
	НомерСтроки = СтрЗаменить(НомерСтроки, ВРег("стр."), "");
	НомерСтроки = СокрЛП(НомерСтроки);
	
	Если ЭтоЧисло(НомерСтроки) Тогда
		СтруктураОшибки.Вставить("НомерСтроки", НомерСтроки);
	КонецЕсли;
	
	Возврат СтруктураОшибки;
	
КонецФункции

// Возвращает таблицу локализуемых объектов конфигурации.
// Такие объекты перечислены в текстовых макетах ЛокализуемыеОбъектыXXX, например, "ОбщийМакет.ЛокализуемыеОбъектыБСП".
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица значений с колонками:
//     Ссылка  - СправочникСсылка.СтруктураКонфигурации - ссылка на объект конфигурации.
//
Функция ПолучитьЛокализуемыеОбъектыКонфигурации()
	
	КлючКонтекста = "ЛокализуемыеОбъектыКонфигурации";
	ТаблицаЛокализуемыхОбъектов = Контекст[КлючКонтекста];
	Если ТаблицаЛокализуемыхОбъектов <> Неопределено Тогда
		Возврат ТаблицаЛокализуемыхОбъектов;
	КонецЕсли;
	
	ТаблицаЛокализуемыхОбъектов = Новый ТаблицаЗначений;
	ТаблицаЛокализуемыхОбъектов.Колонки.Добавить("Ссылка");
	ТаблицаЛокализуемыхПодсистем = ТаблицаЛокализуемыхОбъектов.СкопироватьКолонки();
	
	ТекстЛокализуемыеОбъекты = ВРег("ЛокализуемыеОбъекты");
	ТаблицаТиповОбъектов = Неопределено;
	ТипОбъектаПодсистема = Перечисления.ТипыОбъектов.Подсистема;
	
	ТаблицаОбщихМакетов = ПолучитьОбъектыКонфигурации(Перечисления.ТипыОбъектов.ОбщийМакет, Истина);
	Для Каждого СтрокаОбщегоМакета Из ТаблицаОбщихМакетов Цикл
		
		// Проверяем наименование макета, если не начинается с "ЛокализуемыеОбъекты", тогда пропускаем.
		Если НЕ СтрНачинаетсяС(ВРег(СтрокаОбщегоМакета.Наименование), ТекстЛокализуемыеОбъекты) Тогда
			Продолжить;
		КонецЕсли;
		
		МакетСсылка = СтрокаОбщегоМакета.Ссылка;
		
		// Проверяем тип макета, если не текстовый документ, то пропускаем.
		СвойстваОбъекта = ПолучитьСвойства(МакетСсылка);
		Если НЕ СвойстваОбъекта.Свойство("ТипМакета") Тогда
			Продолжить;
		КонецЕсли;
		
		Если СвойстваОбъекта.ТипМакета <> "ТекстовыйДокумент" Тогда
			Продолжить;
		КонецЕсли;
		
		// Получаем содержимое макета текстового документа.
		СодержимоеМакета = ПолучитьСоставноеСвойствоМакета("Текст", МакетСсылка);
		Если СодержимоеМакета = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстСодержимогоМакета = СодержимоеМакета.Значение;
		Если ПустаяСтрока(ТекстСодержимогоМакета) Тогда
			Продолжить;
		КонецЕсли;
		
		ТекстСодержимогоМакета = ПолучитьТекстМодуляБезКомментариев(ТекстСодержимогоМакета, Истина, Ложь);
		
		ДокументТекст = Новый ТекстовыйДокумент;
		ДокументТекст.УстановитьТекст(ТекстСодержимогоМакета);
		
		КоличествоСтрок = ДокументТекст.КоличествоСтрок();
		
		Для НомерСтроки = 1 По КоличествоСтрок Цикл
			
			СтрокаМакета = ДокументТекст.ПолучитьСтроку(НомерСтроки);
			Если ПустаяСтрока(СтрокаМакета) Тогда
				Продолжить;
			КонецЕсли;
			
			// Получаем ссылку на объект.
			ОбъектСсылка = ПолучитьСсылкуНаОбъектПоПути(Версия, СокрЛП(СтрокаМакета), ТаблицаТиповОбъектов);
			Если ОбъектСсылка.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			// Если тип объекта - подсистема, то добавляем подсистему в таблицу локализуемых подсистем.
			ТипОбъекта = ПолучитьРеквизитОбъекта(ОбъектСсылка, "ТипОбъекта");
			Если ТипОбъекта = ТипОбъектаПодсистема Тогда
				НовыйЛокализуемыйОбъект = ТаблицаЛокализуемыхПодсистем.Добавить();
			Иначе
				// Иначе добавляем объект в таблицу локализуемых объектов.
				НовыйЛокализуемыйОбъект = ТаблицаЛокализуемыхОбъектов.Добавить();
			КонецЕсли;
			
			НовыйЛокализуемыйОбъект.Ссылка = ОбъектСсылка;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Добавляем в таблицу локализуемых объектов подчиненные подсистемы.
	МассивЛокализуемыхПодсистем = ТаблицаЛокализуемыхПодсистем.ВыгрузитьКолонку("Ссылка");
	
	ЗапросПоПодчиненным = Новый Запрос;
	ЗапросПоПодчиненным.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурации.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СтруктураКонфигурации КАК СтруктураКонфигурации
	|ГДЕ
	|	СтруктураКонфигурации.Владелец = &Версия
	|	И НЕ СтруктураКонфигурации.ПометкаУдаления
	|	И СтруктураКонфигурации.Расширение = &Расширение
	|	И СтруктураКонфигурации.Ссылка В ИЕРАРХИИ (&МассивОбъектовРодителей)";
	
	ЗапросПоПодчиненным.УстановитьПараметр("Версия", Версия);
	ЗапросПоПодчиненным.УстановитьПараметр("МассивОбъектовРодителей", МассивЛокализуемыхПодсистем);
	ЗапросПоПодчиненным.УстановитьПараметр("Расширение", Расширение);
	
	ТаблицаЛокализуемыхПодсистем = ЗапросПоПодчиненным.Выполнить().Выгрузить();
	ТаблицаЛокализуемыхПодсистем.Свернуть("Ссылка");
	МассивЛокализуемыхПодсистем = ТаблицаЛокализуемыхПодсистем.ВыгрузитьКолонку("Ссылка");
	
	// Ищем все объекты, входящие во все локализуемые подсистемы с учетом подчиненных.
	ЗапросПоОбъектамПодсистем = Новый Запрос;
	ЗапросПоОбъектамПодсистем.Текст = "
	|ВЫБРАТЬ
	|	СтруктураКонфигурацииПодсистемы.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.СтруктураКонфигурации.Подсистемы КАК СтруктураКонфигурацииПодсистемы
	|ГДЕ
	|	СтруктураКонфигурацииПодсистемы.Ссылка.Владелец = &Версия
	|	И НЕ СтруктураКонфигурацииПодсистемы.Ссылка.ПометкаУдаления
	|	И СтруктураКонфигурацииПодсистемы.Подсистема В(&МассивПодсистем)";
	
	ЗапросПоОбъектамПодсистем.УстановитьПараметр("Версия", Версия);
	ЗапросПоОбъектамПодсистем.УстановитьПараметр("МассивПодсистем", МассивЛокализуемыхПодсистем);
	
	ТаблицаЛокализуемыхОбъектовПоПодсистемам = ЗапросПоОбъектамПодсистем.Выполнить().Выгрузить();
	ОбъединитьТаблицы(ТаблицаЛокализуемыхОбъектов, ТаблицаЛокализуемыхОбъектовПоПодсистемам);
	ТаблицаЛокализуемыхОбъектов.Свернуть("Ссылка");
	МассивЛокализуемыхОбъектов = ТаблицаЛокализуемыхОбъектов.ВыгрузитьКолонку("Ссылка");
	
	// Ищем все подчиненные объекты из таблицы локализуемых объектов.
	ЗапросПоПодчиненным.УстановитьПараметр("МассивОбъектовРодителей", МассивЛокализуемыхОбъектов);
	
	ТаблицаЛокализуемыхОбъектов = ЗапросПоПодчиненным.Выполнить().Выгрузить();
	
	// Добавляем сами подсистемы.
	ОбъединитьТаблицы(ТаблицаЛокализуемыхОбъектов, ТаблицаЛокализуемыхПодсистем);
	ТаблицаЛокализуемыхОбъектов.Свернуть("Ссылка");
	
	ТаблицаЛокализуемыхОбъектов.Индексы.Добавить("Ссылка");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаЛокализуемыхОбъектов);
	
	Возврат ТаблицаЛокализуемыхОбъектов;
	
КонецФункции

// Возвращает префикс имен расширения.
//
// Возвращаемое значение:
//   Строка - префикс имен расширения.
//
Функция ПолучитьПрефиксИменРасширения()
	
	КлючКонтекста = "ПрефиксИменРасширения";
	ПрефиксИменРасширения = Контекст[КлючКонтекста];
	Если ПрефиксИменРасширения <> Неопределено Тогда
		Возврат ПрефиксИменРасширения;
	КонецЕсли;
	
	КореньРасширения = ПолучитьКореньКонфигурации();
	ПрефиксИменРасширения = ПолучитьСвойство("ПрефиксИмен", КореньРасширения);
	ПрефиксИменРасширения = Строка(ПрефиксИменРасширения);
	
	Контекст.Вставить(КлючКонтекста, ПрефиксИменРасширения);
	
	Возврат ПрефиксИменРасширения;
	
КонецФункции

// Получает таблицу ошибок проверки применения расширения для всех объектов расширения.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок проверки применения расширения:
//     Уточнение        - Строка                                 - уточнение ошибки.
//     Объект           - СправочникСсылка.СтруктураКонфигурации - ссылка объект расширения.
//
Функция ПолучитьОшибкиПримененияРасширения()
	
	КлючКонтекста = "ОшибкиПримененияРасширения";
	ЗначениеКонтекста = Контекст[КлючКонтекста];
	Если ЗначениеКонтекста <> Неопределено Тогда
		Возврат ЗначениеКонтекста;
	КонецЕсли;
	
	ЗапросПоОшибкамПримененияРасширения = Новый Запрос;
	ЗапросПоОшибкамПримененияРасширения.Текст = "
	|ВЫБРАТЬ
	|	ОшибкиПримененияРасширений.Объект,
	|	ОшибкиПримененияРасширений.Уточнение
	|ИЗ
	|	РегистрСведений.ОшибкиПримененияРасширений КАК ОшибкиПримененияРасширений
	|ГДЕ
	|	ОшибкиПримененияРасширений.Конфигурация = &Конфигурация
	|	И ОшибкиПримененияРасширений.Расширение = &Расширение";
	
	ЗапросПоОшибкамПримененияРасширения.УстановитьПараметр("Конфигурация", Версия.Владелец);
	ЗапросПоОшибкамПримененияРасширения.УстановитьПараметр("Расширение", Расширение);
	
	ТаблицаОшибокПримененияРасширения = ЗапросПоОшибкамПримененияРасширения.Выполнить().Выгрузить();
	ТаблицаОшибокПримененияРасширения.Индексы.Добавить("Объект");
	
	Контекст.Вставить(КлючКонтекста, ТаблицаОшибокПримененияРасширения);
	
	Возврат ТаблицаОшибокПримененияРасширения;
	
КонецФункции

// Получает таблицу ошибок проверки применения расширения для указанного объекта расширения.
//
// Параметры:
//   ОбъектКонфигурации - СправочникСсылка.СтруктураКонфигурации, Неопределено - ссылка на объект.
//                        Если не заполнен, то возвращается таблица ошибок текущего проверяемого объекта.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица ошибок проверки применения расширения:
//     Уточнение        - Строка                                 - уточнение ошибки.
//     Объект           - СправочникСсылка.СтруктураКонфигурации - ссылка объект расширения.
//
Функция ПолучитьОшибкиПримененияРасширенияДляОбъекта(ОбъектРасширения = Неопределено)
	
	ФлагИспользованиеКэша = (ОбъектРасширения = Неопределено) ИЛИ (ОбъектРасширения = ОбъектПроверкиСсылка);
	Если ФлагИспользованиеКэша Тогда
		КлючЗначенияКэша = "Функция_ПолучитьОшибкиПримененияРасширенияДляОбъекта";
		ЗначениеИзКэша = КэшЗначений[КлючЗначенияКэша];
		Если ЗначениеЗаполнено(ЗначениеИзКэша) Тогда
			Возврат ЗначениеИзКэша;
		КонецЕсли;
	КонецЕсли;
	
	ТаблицаОшибокПримененияРасширения = ПолучитьОшибкиПримененияРасширения();
	
	ОбъектСсылка = ?(ФлагИспользованиеКэша, ОбъектПроверкиСсылка, ОбъектРасширения);
	
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Объект", ОбъектСсылка);
	ТаблицаОшибокОбъекта = ТаблицаОшибокПримененияРасширения.Скопировать(СтруктураОтбора);
	
	Если ФлагИспользованиеКэша Тогда
		КэшЗначений.Вставить(КлючЗначенияКэша, ТаблицаОшибокОбъекта);
	КонецЕсли;
	
	Возврат ТаблицаОшибокОбъекта;
	
КонецФункции

// Убирает скобки ограничений доступа "#Если &ОграничениеДоступаНаУровнеЗаписейУниверсально" в RLS ролей
// для сравнения ограничений.
// Используется в правиле проверки "Проверка ограничений прав доступа (RLS)".
//
// Параметры:
//   ТекстОграничения - Строка - ограничение доступа.
//
// Возвращаемое значение:
//   Строка - ограничение доступа без скобок "#Если &ОграничениеДоступаНаУровнеЗаписейУниверсально".
//
Функция УбратьСкобкиОграничениеДоступаНаУровнеЗаписейУниверсально(Знач ТекстОграничения)
	
	Если СтрНачинаетсяС(ТекстОграничения, "#Если &ОграничениеДоступаНаУровнеЗаписейУниверсально") Тогда
		ТекстДляПоиска = "#Иначе";
		Позиция = СтрНайти(ТекстОграничения, ТекстДляПоиска);
		Если Позиция > 0 Тогда
			ТекстОграничения = Сред(ТекстОграничения, Позиция + СтрДлина(ТекстДляПоиска));
			ТекстДляПоиска = "#КонецЕсли";
			Если СтрЗаканчиваетсяНа(ТекстОграничения, ТекстДляПоиска) Тогда
				ТекстОграничения = Лев(ТекстОграничения, СтрДлина(ТекстОграничения) - СтрДлина(ТекстДляПоиска));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТекстОграничения;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляРаботыСРегулярнымиВыражениями

// Инициализирует объект регулярных выражений.
//
// Параметры:
//   ИмяОбъекта - Строка - имя объекта регулярных выражений.
//
// Возвращаемое значение:
//   COMОбъект - COM-Объект, предназначенный для работы с регулярными выражениями.
//
Функция РегулярныеВыраженияИнициализация(ИмяОбъекта = "ОбъектРегулярныхВыражений")
	
	ОбъектРегулярныхВыражений = Контекст[ИмяОбъекта];
	Если ОбъектРегулярныхВыражений <> Неопределено Тогда
		Возврат ОбъектРегулярныхВыражений;
	КонецЕсли;
	
	ОбъектРегулярныхВыражений = Новый COMОбъект("VBScript.RegExp");
	
	Контекст.Вставить(ИмяОбъекта, ОбъектРегулярныхВыражений);
	
	Возврат ОбъектРегулярныхВыражений;
	
КонецФункции

// Возвращает результат поиска в тексте по шаблону.
//
// Параметры:
//   Текст               - Строка - текст, в котором будет производиться поиск.
//   ШаблонПоиска        - Строка - шаблон для поиска.
//   ИгнорироватьРегистр - Булево - флаг, надо ли игнорировать регистр символов при поиске.
//   ПоискВсехВхождений  - Булево - флаг, надо искать все вхождения по шаблону.
//   МногострочныйТекст  - Булево - флаг, является ли переданный текст многострочным.
//
// Возвращаемое значение:
//   COMОбъект - COM-Объект, предназначенный для работы с регулярными выражениями.
//               Булево - Ложь, если поиск выполнен с ошибками.
//
Функция РегулярныеВыраженияНайти(Текст, ШаблонПоиска, ИгнорироватьРегистр = Истина, ПоискВсехВхождений = Ложь,
	МногострочныйТекст = Ложь)
	
	Попытка
		
		ОбъектРегулярныхВыражений = РегулярныеВыраженияИнициализация();
		ОбъектРегулярныхВыражений.Pattern = ШаблонПоиска;
		ОбъектРегулярныхВыражений.IgnoreCase = ИгнорироватьРегистр;
		ОбъектРегулярныхВыражений.Global = ПоискВсехВхождений;
		ОбъектРегулярныхВыражений.Multiline = МногострочныйТекст;
		
		Возврат ОбъектРегулярныхВыражений.Execute(Текст);
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

// Проверяет, есть ли в тексте искомый текст по шаблону.
//
// Параметры:
//   Текст               - Строка - текст, в котором будет производиться поиск.
//   ШаблонПоиска        - Строка - шаблон для поиска.
//   ИгнорироватьРегистр - Булево - флаг, надо ли игнорировать регистр символов при поиске.
//
// Возвращаемое значение:
//   Булево - флаг:
//     Истина - в тексте присутствует вхождения искомого текста по шаблону.
//     Ложь   - искомый текст не найден.
//
Функция РегулярныеВыраженияТекстПрисутствует(Текст, ШаблонПоиска, ИгнорироватьРегистр = Истина)
	
	Попытка
		
		ОбъектРегулярныхВыражений = РегулярныеВыраженияИнициализация();
		ОбъектРегулярныхВыражений.Pattern = ШаблонПоиска;
		ОбъектРегулярныхВыражений.IgnoreCase = ИгнорироватьРегистр;
		ОбъектРегулярныхВыражений.Global = Ложь;
		
		Возврат ОбъектРегулярныхВыражений.Test(Текст);
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

// Производит поиск текста по шаблону и заменяет указанным текстом.
//
// Параметры:
//   Текст               - Строка - текст, в котором будет производиться замена.
//   ТекстЗамены         - Строка - текст для замены.
//   ШаблонПоиска        - Строка - шаблон для поиска.
//   ИгнорироватьРегистр - Булево - флаг, надо ли игнорировать регистр символов при поиске.
//   ПоискВсехВхождений  - Булево - флаг, надо искать все вхождения по шаблону.
//   МногострочныйТекст  - Булево - флаг, является ли переданный текст многострочным.
//
// Возвращаемое значение:
//   Строка - результирующий текст с произведенными заменами.
//   Булево - Ложь, если замена прошла с ошибками.
//
Функция РегулярныеВыраженияТекстЗаменить(Текст, ТекстЗамены, ШаблонПоиска, ИгнорироватьРегистр = Истина,
	ПоискВсехВхождений = Ложь, МногострочныйТекст = Ложь)
	
	Попытка
		
		ОбъектРегулярныхВыражений = РегулярныеВыраженияИнициализация();
		ОбъектРегулярныхВыражений.Pattern = ШаблонПоиска;
		ОбъектРегулярныхВыражений.IgnoreCase = ИгнорироватьРегистр;
		ОбъектРегулярныхВыражений.Global = ПоискВсехВхождений;
		ОбъектРегулярныхВыражений.Multiline = МногострочныйТекст;
		
		Возврат ОбъектРегулярныхВыражений.Replace(Текст, ТекстЗамены);
		
	Исключение
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область Инициализация

ИдентификаторыСодержанияОбъектов = Перечисления.ИдентификаторыСодержанияОбъектов;

ЗаполнитьИмяСтруктурыПоМодулю();
ЗаполнитьСоответствиеИменМодулей();
ЗаполнитьИмяСостСвойства();
ЗаполнитьСписокПолномочий();

ИнициализироватьПроверкуОрфографии();

УточненияПроверок = Неопределено;

Контекст = Новый Соответствие;
ВсеРесурсыПравил = Новый Соответствие;
СоответствиеОшибок = Новый Соответствие;
Расширение = Справочники.Расширения.ПустаяСсылка();

#КонецОбласти

#КонецЕсли